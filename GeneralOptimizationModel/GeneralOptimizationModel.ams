## ams_version=1.0

LibraryModule GeneralOptimizationModel {
	Prefix: gom;
	Interface: {
		data { sInputZeroNodes, sOutputZeroNodes, sNodesMaterialBalance, p01MapFlowFrom, 
		       p01MapFlowTo, vInputFlow, vOutputFlow, vFlow, vFlowPlus, vFlowMinus, cFlowPlusMinus1, 
		       cFlowPlusMinus2, cMatBalanceFlowNodes, cSetInputFlowZero, cSetOutputFlowZero, 
		       cSetInputFlowNodes, cSetOutputFlowNodes, cSetFlashTank, v01Box, v01boxFlowPositiveRateChange, 
		       v01boxFlowNegativeRateChange, cMinFlowbox, cMaxFlowbox, cboxDirectionRateChange1, 
		       cboxDirectionRateChange2, cboxDirectionRateChange3, cboxMaxPositiveRateChange, 
		       cboxMaxNegativeRateChange, cboxSteadyStateAfterRamp1, cboxSteadyStateAfterRamp2, 
		       cboxMinStayTimeInSteadyState1, cboxMinStayTimeInSteadyState2, p01boxFlowDirection, 
		       vboxPower, p01Coldbox, cSetInputFlowColdboxNodes, cSetOutputFlowColdboxNodes, 
		       cSetInternalFlowColdbox, vAirHp, vAirMp, vLpGOx, vLpGOxVent, vHpGOx, vHpGOxVent, 
		       vMpGOx, vMpGOxVent, vHpGaN, vHpGaNVent, vMpGaN, vMpGaNVent, vLpGaN, vLpGaNVent, 
		       vLiN, vLiNAssist, vLOx, vLOxAssist, vLAr, vLArPurge, vLoxPurge, vLinPurge, 
		       vLinAsssistColdStandby, cMaterialBalanceN2, cMaterialBalanceO2, cMaterialBalanceAr, 
		       cNitrogenMode, vPowerBalanceSlackPos, vPowerBalanceSlackNeg, cNoPowerBalanceSlackPos, 
		       cNoPowerBalanceSlackNeg, cPowerBalance_GOK_AOK, cPowerBalance_Gas, cLiquidBalance, 
		       vInternalLiquid, vRectificationPower, cCalcRectificationPower, cMinRectificationPower, 
		       cMaxRectificationPower, cCalcO2RecoveryLambda, cCalcO2RecoveryNoLambda, cCalcArRecoveryLambda, 
		       cCalcArRecoveryNoLambda, vO2Recovery, vArRecovery, cMinO2Recovery, cMaxO2Recovery, 
		       cMinArRecovery, cMaxArRecovery, vColdboxInternalFlow, v01ColdboxInternalFlowPositiveRateChange, 
		       v01ColdboxInternalFlowNegativeRateChange, cMinInternalFlowColdbox, cMaxInternalFlowColdbox, 
		       cColdboxDirectionRateChange1, cColdboxDirectionRateChange2, cColdboxDirectionRateChange3, 
		       cColdboxMaxPositiveRateChange, cColdboxMaxNegativeRateChange, cColdboxSteadyStateAfterRamp1, 
		       cColdboxSteadyStateAfterRamp2, cColdboxMinStayTimeInSteadyState1, cColdboxMinStayTimeInSteadyState2, 
		       p01ColdboxFlowDirection, cSetPressureColdboxNodes, vWaste, vWasteO2, vWasteN2, 
		       vGOxToWaste, cCalcWasteFlow, cCalcWasteO2, cGOxToWasteContentMax, cWasteGOxToWaste, 
		       cRegeneration, cRegenerationNitrogenMode, vAirTurbineLp, cLinAssistColdStandby, 
		       cColdBoxPowerNull, vPressure, vPressureSlackPos, vPressureSlackNeg, vPressurePenalty, 
		       cSetPressureSetpoint, v01Backup, vFlashBackup, cFlashBackup, cMaxFlowBackup, 
		       cMinFlowBackup, v01BackupFlowPositiveRateChange, v01BackupFlowNegativeRateChange, 
		       cBackupDirectionRateChange1, cBackupDirectionRateChange2, cBackupDirectionRateChange3, 
		       cBackupMaxPositiveRateChange, cBackupMaxNegativeRateChange, cBackupSteadyStateAfterRamp1, 
		       cBackupSteadyStateAfterRamp2, cBackupMinStayTimeInSteadyState1, cBackupMinStayTimeInSteadyState2, 
		       p01BackupDirectionFlow, vLiquidSlackMax, vLiquidSlackMin, vTankLevel, cNoSlackMin, 
		       cNoSlackMax, cMinTargetLevelLiquid, cMaxTargetLevelLiquid, cMaterialBalanceTank, 
		       vFlashTank, cFlashTank, vCompressorPower, vCompressorEfficiency, v01Compressor, 
		       cCalcKwCompressor, cCalcEfficiencyCompressor, cMinFlowCompressor, cMaxFlowCompressor, 
		       pMaxTheoreticalCompressorPower, cMaxPowerCompressor, cSetCompressorSimultaneous, 
		       cSetCompressorExclusion, cCompressionRateMax, vCompressorFlowMinSlack, vCompressorFlowMaxSlack, 
		       cNoSlackCompressorFlowMin, cNoSlackCompressorFlowMax, v01CompressorFlowPositiveRateChange, 
		       v01CompressorFlowNegativeRateChange, cCompressorDirectionRateChange1, cCompressorDirectionRateChange2, 
		       cCompressorDirectionRateChange3, cCompressorMaxPositiveRateChange, cCompressorMaxNegativeRateChange, 
		       cCompressorSteadyStateAfterRamp1, cCompressorSteadyStateAfterRamp2, cCompressorMinStayTimeInSteadyState1, 
		       cCompressorMinStayTimeInSteadyState2, p01CompressorDirectionFlow, v01Liquefier, 
		       vLiquefierPower, cCalcKwLiquefierOrCycleFlow, cMinFlowLiquefier, cMaxFlowLiquefier, 
		       pMaxTheoreticalLiquefierPower, cMaxPowerLiquefier, cCycle, cBinaryLiquefier, 
		       cSetPoutCompCycle, cSetPinCompressorCycle1, cSetPinCompressorCycle2, v01LiquefierFlowPositiveRateChange, 
		       v01LiquefierFlowNegativeRateChange, cLiquefierDirectionRateChange1, cLiquefierDirectionRateChange2, 
		       cLiquefierDirectionRateChange3, cLiquefierMaxPositiveRateChange, cLiquefierMaxNegativeRateChange, 
		       cLiquefierSteadyStateAfterRamp1, cLiquefierSteadyStateAfterRamp2, cLiquefierMinStayTimeInSteadyState1, 
		       cLiquefierMinStayTimeInSteadyState2, p01LiquefierDirectionFlow, vDeltaPValve, 
		       cCalcDeltaP, cValveFlowDeltaP_1, cValveFlowDeltaP_2, cSetValveSetpoint, cCheckValve, 
		       vPressureDropSlackPos, vPressureDropSlackNeg, vFrictionFactor, cCalcPressureDrop, 
		       cCalcFrictionFactor, pEstimatedPipeLinearPressureDropParam1, pEstimatedPipeLinearPressureDropFrictionFactor, 
		       vAccuBuffer, vBufferMinPressureSlack, vBufferMaxPressureSlack, cAccumulationBuffer, 
		       cMassBalanceBuffer, cMinPressureBuffer, cMaxPressureBuffer, vOutputFlowVariable, 
		       cOutputFlowVariableMax, cOutputFlowVariableMin, v01OutputFlowNodePositiveRateChange, 
		       v01OutputFlowNodeNegativeRateChange, cOutputFlowNodeDirectionRateChange1, 
		       cOutputFlowNodeDirectionRateChange2, cOutputFlowNodeDirectionRateChange3, 
		       cOutputFlowNodeMaxPositiveRateChange, cOutputFlowNodeMaxNegativeRateChange, 
		       cOutputFlowNodeSteadyStateAfterRamp1, cOutputFlowNodeSteadyStateAfterRamp2, 
		       cOutputFlowNodeMinStayTimeInSteadyState1, cOutputFlowNodeMinStayTimeInSteadyState2, 
		       p01OutputFlowNodeDirection, cInputFlowNodeVariableMax, cInputFlowNodeVariableMin, 
		       v01InputFlowNodePositiveRateChange, v01InputFlowNodeNegativeRateChange, vInputFlowVariable, 
		       cInputFlowNodeDirectionRateChange1, cInputFlowNodeDirectionRateChange2, cInputFlowNodeDirectionRateChange3, 
		       cInputFlowNodeMaxPositiveRateChange, cInputFlowNodeMaxNegativeRateChange, 
		       cInputFlowNodeSteadyStateAfterRamp1, cInputFlowNodeSteadyStateAfterRamp2, 
		       cInputFlowNodeMinStayTimeInSteadyState1, cInputFlowNodeMinStayTimeInSteadyState2, 
		       p01InputFlowNodeDirection, vAuxPower, sStayTime, v01ElementInOperatingMode, 
		       v01ElementSwitchOperatingMode, vCompressorExtraPower, vLiquefierExtraPower, 
		       vBackupExtraPower, vBoxExtraPower, cOnlyOneActiveMode, cSwitch, cOnlyOneSwitch, 
		       cMinStayTime, cMaxStayTime, cForceOperatingModeCompressor, cForceOperatingModeBackup, 
		       cForceOperatingModeLiquefier, cForceOperatingModebox, cLinkToCompressor, cLinkToBackup, 
		       cLinkToLiquefier, cLinkToColdbox, cVentingOperatingModeColdbox, vFlashBackupCoolDown, 
		       cBackupCoolDown, cLiquefierCoolDown_disable, cForceCompressorStatus, cForceBackupStatus, 
		       cForceLiquefierStatus, cForceboxStatus, vObjectiveCost, vObjective, pObjectiveCost, 
		       pObjective, pCostCompressor, pCostLiquefier, pCostBox, pCostAuxiliary, pCostBackup, 
		       pCostInputFlowNode, pCostOutputFlowNode, pEnergyCost, pInputFlowCost, pOutputFlowCost, 
		       pCostBuffer, pCostTank, pCostSlackOthers, sMPConstraints_General, sMPVariables_General, 
		       sMPConstraintsExcluded_gom, sMPVarialblesExcluded_gom, mpGeneralModel, epProgramStatus, 
		       spProgramStatus, pTimeUsed, pGap, procSolve, procCheckSevereErrors, procSolveGeneralModel, 
		       procSolveLinearBlockGeneral, pMIP_Relative_Optimality_Tolerance, pTime_Limit, 
		       procDefineProjectOptim, procConfigureMathProgram, procFixFlowVariablesFromData, 
		       procNodeSetsDefinition, procInitializeAccuBuffers, procMakeAllVariablesVar, 
		       procFixAllBinaryVariables, procClear, procClearBeforeSolve, pEnergykWh, v01ValveOnOff, 
		       cOnOffValve_Off1, cOnOffValve_Off2, cOnOffValve_On1, cOnOffValve_On2, cOnOffValve_SetPointMinFlow }
	}
	Section Optimization_model {
		Section Network_model {
			DeclarationSection Architecture {
				Set sInputZeroNodes {
					SubsetOf: gdm::sNodes;
					Definition: {
						!Defined in the procConfigureMathProgram for each entity specific
					}
					Comment: "These node have input flow and cost equal to 0";
				}
				Set sOutputZeroNodes {
					SubsetOf: gdm::sNodes;
					Definition: {
						!Defined in the procConfigureMathProgram for each entity specific
					}
					Comment: "These nodes have output flow and cost equal to 0";
				}
				Set sNodesMaterialBalance {
					SubsetOf: gdm::sNodes;
					Definition: {
						!Defined in the procNodeInputOutputZero
					}
					Comment: "To these nodes we applied the generic material balance equation";
				}
				Parameter p01MapFlowFrom {
					IndexDomain: (gdm::iNode,gdm::iArc);
					Range: binary;
					Definition: gdm::iNode=gdm::epNodeFrom(gdm::iArc);
					Comment: "This map construction is sometimes used in sum statements";
				}
				Parameter p01MapFlowTo {
					IndexDomain: (gdm::iNode,gdm::iArc);
					Range: binary;
					Definition: gdm::iNode=gdm::epNodeTo(gdm::iArc);
					Comment: "This map construction is sometimes used in sum statements";
				}
			}
			DeclarationSection Flow_Declaration {
				Variable vInputFlow {
					IndexDomain: (gdm::iNode,gdm::iTime);
					Text: "In flow";
					Range: nonnegative;
					Comment: "Input flow of a liquid or gas at a node";
				}
				Variable vOutputFlow {
					IndexDomain: (gdm::iNode,gdm::iTime);
					Text: "Out flow";
					Range: nonnegative;
					Comment: "Output flow of a liquid or gas of a node";
				}
				Variable vFlow {
					IndexDomain: (gdm::iArc,gdm::iTime);
					Text: "Flow";
					Range: [gdm::pArcMinFlow(gdm::iArc), gdm::pArcMaxFlow(gdm::iArc)];
					Comment: "Flow of liquid or gas on an arc";
				}
				Variable vFlowPlus {
					IndexDomain: (gdm::iArc,gdm::iTime);
					Range: nonnegative;
					Default: 0;
					Comment: "Flows may be negative. Because cost are not negative for negative flow, it is split up in positive and negative flow";
				}
				Variable vFlowMinus {
					IndexDomain: (gdm::iArc,gdm::iTime);
					Range: nonnegative;
					Default: 0;
					Comment: "Flows may be negative. Because cost are not negative for negative flow, it is split up in positive and negative flow";
				}
				Constraint cFlowPlusMinus1 {
					IndexDomain: (gdm::iArc, gdm::iTime);
					Definition: {
						
						vFlow(gdm::iArc, gdm::iTime)
						=
						vFlowPlus(gdm::iArc, gdm::iTime)-vFlowMinus(gdm::iArc, gdm::iTime)
					}
				}
				Constraint cFlowPlusMinus2 {
					IndexDomain: (gdm::iArc, gdm::iTime);
					Definition: {
						
						vFlowPlus(gdm::iArc, gdm::iTime)*vFlowMinus(gdm::iArc, gdm::iTime)<= 1.e-04
					}
					Comment: "This makes sure that either FlowMinus or FlowPlus is equal to 0 (we cannot have flow in both directions)";
				}
				Constraint cMatBalanceFlowNodes {
					IndexDomain: (gdm::iNode, gdm::iTime) | gdm::iNode in sNodesMaterialBalance;
					Definition: {
						!Flow on the arc leaving the node
						-sum(gdm::iArc,p01MapFlowFrom(gdm::iNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime))
						!Flow on the arc entering the node
						+sum(gdm::iArc,p01MapFlowTo(gdm::iNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime))
						=
						vOutputFlow(gdm::iNode, gdm::iTime)
						-vInputFlow(gdm::iNode, gdm::iTime)
					}
					Comment: "Material balance (liquid or gas) at each node";
				}
				Constraint cSetInputFlowZero {
					IndexDomain: (gdm::iNode, gdm::iTime)|gdm::iNode in sInputZeroNodes;
					Definition: vInputFlow(gdm::iNode, gdm::iTime)=0;
					Comment: "Some nodes have no inflow. Note that these variables are deleted by presolver.";
				}
				Constraint cSetOutputFlowZero {
					IndexDomain: (gdm::iNode, gdm::iTime)|gdm::iNode in sOutputZeroNodes;
					Definition: vOutputFlow(gdm::iNode, gdm::iTime)=0;
					Comment: "Some nodes have no outflow. Note that these variables are deleted by presolver.";
				}
			}
			DeclarationSection Link_to_Input_Flow {
				Constraint cSetInputFlowNodes {
					IndexDomain: (gdm::iInputFlowNode, gdm::iTime);
					Definition: {
						vinputFlow(gdm::iInputFlowNode, gdm::iTime)  
						= 
						gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime) 
						+
						vInputFlowVariable(gdm::iInputFlowNode, gdm::iTime)
					}
				}
			}
			DeclarationSection Link_to_Output_Flow {
				Constraint cSetOutputFlowNodes {
					IndexDomain: (gdm::iOutputFlowNode, gdm::iTime);
					Definition: {
						
						vOutputFlow(gdm::iOutputFlowNode, gdm::iTime) 
						=
						gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime)
						+
						vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime)
					}
				}
			}
			DeclarationSection Link_to_Tank {
				Constraint cSetFlashTank {
					IndexDomain: (gdm::iTankNode, gdm::iTime);
					Definition: {
						
						vOutputFlow(gdm::iTankNode, gdm::iTime) = vFlashTank(gdm::iTankNode, gdm::iTime)
					}
				}
			}
		}
		Section Box_ {
			DeclarationSection Box_status {
				Variable v01Box {
					IndexDomain: (gdm::iBox,gdm::iTime);
					Range: binary;
				}
			}
			DeclarationSection Box_Flow_constraints {
				Variable v01boxFlowPositiveRateChange {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
						and ( p01boxFlowDirection(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) or 
						    ( gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) > 1) )
						and
						    not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Range: binary;
				}
				Variable v01boxFlowNegativeRateChange {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
						and ( p01boxFlowDirection(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) or 
						    ( gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) > 1) )
						and
						  not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Range: binary;
				}
				Constraint cMinFlowbox {
					IndexDomain: (gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)| not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType);
					Definition: {
						
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox,gdm::iBoxNodeConnectionType), gdm::iTime)
							>=gdm::pboxMinFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*v01box(gdm::iBox,gdm::iTime)
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
						
							gom::vInputFlow(gdm::epboxNode(gdm::iBox,gdm::iBoxNodeConnectionType), gdm::iTime)
							>=gdm::pboxMinFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*v01box(gdm::iBox,gdm::iTime)
						
						else
							0>=0
						endif
					}
					Comment: "constraiint apply only on input flow since output = input";
				}
				Constraint cMaxFlowbox {
					IndexDomain: (gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType);
					Definition: {
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox,gdm::iBoxNodeConnectionType), gdm::iTime)
							<=gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*v01box(gdm::iBox,gdm::iTime)
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
							gom::vInputFlow(gdm::epboxNode(gdm::iBox,gdm::iBoxNodeConnectionType), gdm::iTime)
							<=gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*v01box(gdm::iBox,gdm::iTime)
						
						else
							0<=0
						endif
					}
					Comment: "constraiint apply only on input flow since output = input";
				}
				Constraint cboxDirectionRateChange1 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
						and ( p01boxFlowDirection(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) or 
						    ( gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) > 1) )
						and
						  not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						v01boxFlowPositiveRateChange(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)
						+
						v01boxFlowNegativeRateChange(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)
						<= 
						1
					}
				}
				Constraint cboxDirectionRateChange2 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
						and ( p01boxFlowDirection(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) or 
						    ( gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) > 1) )
						and
						  not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							>=
							((gdm::pboxMinPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) + 1) * v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
							- 
							gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) * v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)) * gdm::pPeriodInHours
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
							gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							>=
							((gdm::pboxMinPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) + 1) * v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
							- 
							gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) * v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)) * gdm::pPeriodInHours
						
						else
							0>=0
						endif
					}
				}
				Constraint cboxDirectionRateChange3 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
						and ( p01boxFlowDirection(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) or 
						    ( gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) > 1) )
						and
						  not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							<= 
							(gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) * v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
							+ 
							(gdm::pboxMinNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) - 1) * v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)) * gdm::pPeriodInHours
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
							gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							<= 
							(gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) * v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
							+ 
							(gdm::pboxMinNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) - 1) * v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)) * gdm::pPeriodInHours
						
						else
							0<=0
						endif
					}
				}
				Constraint cboxMaxPositiveRateChange {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
						and gdm::pboxMaxPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							<=
							( gdm::pboxMaxPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) +
							  gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1 - v01box(gdm::iBox,gdm::iTime-1))
							)*gdm::pPeriodInHours
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
							gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							<=
							( gdm::pboxMaxPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) +
							  gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1 - v01box(gdm::iBox,gdm::iTime-1))
							)*gdm::pPeriodInHours
						
						else
							0<=0
						endif
					}
				}
				Constraint cboxMaxNegativeRateChange {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
						and gdm::pboxMaxNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						if gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeInputs then
							gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vOutputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							>=
							( gdm::pboxMaxNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) -
						 	  gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1 - v01box(gdm::iBox,gdm::iTime))
							)*gdm::pPeriodInHours
						
						elseif gdm::iBoxNodeConnectionType in gdm::sboxNodeConnectionTypeOutputs then
							gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime) - gom::vInputFlow(gdm::epboxNode(gdm::iBox, gdm::iBoxNodeConnectionType), gdm::iTime-1)
							>=
							( gdm::pboxMaxNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) -
							  gdm::pboxMaxFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1 - v01box(gdm::iBox,gdm::iTime))
							)*gdm::pPeriodInHours
						else
							0>=0
						endif
					}
				}
				Constraint cboxSteadyStateAfterRamp1 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)|  (gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) > 1)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
								   and ord(gdm::iTime2) > ord(gdm::iTime),  
						v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime2) ) 
						<=
						(gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 1)  
						* 
						( ( 1 - v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) )
						   +
						  (1 - v01box(gdm::iBox, gdm::iTime))
						)
					}
				}
				Constraint cboxSteadyStateAfterRamp2 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)|  (gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) > 1)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)
								   and ord(gdm::iTime2) > ord(gdm::iTime), 
						v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime2) ) 
						<=
						(gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 1)  
						* 
						( ( 1 - v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) )
						   +
						  (1 - v01box(gdm::iBox, gdm::iTime))
						)
					}
				}
				Constraint cboxMinStayTimeInSteadyState1 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)|  (gdm::iTime <> gdm::epFirstTimeUnit) 
						and (gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) > 1)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						
						sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 1) 
								     and ord(gdm::iTime2) > ord(gdm::iTime),
						v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime2) ) 
						<=
						(gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 2)  
						* 
						( 1 + v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)  
						    - v01boxFlowPositiveRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime-1) 
						)
					}
				}
				Constraint cboxMinStayTimeInSteadyState2 {
					IndexDomain: {
						(gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime)|  (gdm::iTime <> gdm::epFirstTimeUnit) 
						and (gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) > 1)
						and not gdm::p01BoxFlowSpecificEquation(gdm::iBox, gdm::iBoxNodeConnectionType)
					}
					Definition: {
						
						
						sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 1) 
								     and ord(gdm::iTime2) > ord(gdm::iTime), 
						v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime2) ) 
						<=
						(gdm::pBoxMinStayTimeSteadyStateFlow(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime) - 2)  
						*
						( 1 + v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime)  
						    - v01boxFlowNegativeRateChange(gdm::iBox, gdm::iBoxNodeConnectionType, gdm::iTime-1) 
						)
					}
				}
				Parameter p01boxFlowDirection {
					IndexDomain: (gdm::iBox,gdm::iBoxNodeConnectionType,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
					Range: binary;
					Definition: {
						
						gdm::pboxMinPositiveRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) <>0 
						OR
						gdm::pboxMinNegativeRateChangeFlow(gdm::iBox,gdm::iBoxNodeConnectionType, gdm::iTime) <>0
					}
				}
			}
			DeclarationSection Box_Power {
				Variable vboxPower {
					IndexDomain: (gdm::iBox,gdm::iTime) | gdm::epboxEnergyContract(gdm::iBox);
					Range: nonnegative;
					Comment: "New this is to be sure that Power of Coldbox is 0 since Box power is now in the Obj Funtcion";
				}
			}
			Section Coldbox {
				DeclarationSection Coldbox_status {
					Parameter p01Coldbox {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Definition: {
							
							v01Box(gdm::iColdbox, gdm::iTime)
						}
						Comment: {
							"This parameter is a copy of the V01Box for the coldbox only.
							It is used in the define table extract to Excel. To avoid a warning."
						}
					}
				}
				DeclarationSection Link_to_Coldbox {
					Constraint cSetInputFlowColdboxNodes {
						IndexDomain: (gdm::icoldbox,gdm::iBoxNodeConnectionType, gdm::iTime);
						Definition: {
							
							if gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeAirMp then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox, gdm::iBoxNodeConnectionType),gdm::iTime) = 0
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeAirHp then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = 0
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGOx then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vHpGox(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGOx then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vMpGox(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGOx then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLpGox(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGAn then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vHpGan(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGAn then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vMpGan(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGAn then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLpGan(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLiN  then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLin(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLOx  then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLox(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLAr  then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLar(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLOxAssist  then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = 0
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLiNAssist  then
								vInputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = 0
							else
							0=0
							endif
						}
						Comment: {
							"The coldbox is modeled using one variable per (intermediate) product. This increases the readability of the model.
							Note that the presolver will remove the equality constraints and use one variable instead."
						}
					}
					Constraint cSetOutputFlowColdboxNodes {
						IndexDomain: (gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime);
						Definition: {
							if gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeAirMp then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vAirMp(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeAirHp then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vAirHp(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGOx then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vHpGoxVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGOx then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vMpGoxVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGOx then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLpGoxVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGAn then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vHpGanVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGAn then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vMpGanVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGAn then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLpGanVent(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLiN then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLiNPurge(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLOx then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLoxPurge(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLAr then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLarPurge(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLOxAssist then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLOxAssist(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLiNAssist then
								vOutputFlow(gdm::epBoxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime) = vLiNAssist(gdm::iColdbox, gdm::iTime) + vLinAsssistColdStandby(gdm::iColdbox,gdm::iTime)
							
							else
								0=0
							endif
						}
						Comment: {
							"The coldbox is modeled using one variable per (intermediate) product. This increases the readability of the model.
							Note that the presolver will remove the equality constraints and use one variable instead."
						}
					}
					Constraint cSetInternalFlowColdbox {
						IndexDomain: (gdm::icoldbox, gdm::iColdboxInternalFlow, gdm::iTime);
						Definition: {
							
							if gdm::iColdboxInternalFlow = gdm::epTotalAir then
								vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) = vAirMp(gdm::iColdbox, gdm::iTime) + vAirHp(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iColdboxInternalFlow = gdm::epInternalLiquid then
								vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) = vInternalLiquid(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iColdboxInternalFlow = gdm::epAirTurbineLp then
								vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) = vAirTurbineLp(gdm::iColdbox, gdm::iTime)
							
							elseif gdm::iColdboxInternalFlow = gdm::epGoxToWaste then
								vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) = vGOxToWaste(gdm::iColdbox, gdm::iTime)
							
							else
							0=0
							endif
						}
						Comment: {
							"The coldbox is modeled using one variable per (intermediate) product. This increases the readability of the model.
							Note that the presolver will remove the equality constraints and use one variable instead."
						}
					}
				}
				DeclarationSection Product_Declaration {
					Variable vAirHp {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vAirMp {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLpGOx {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLpGOxVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vHpGOx {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vHpGOxVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vMpGOx {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vMpGOxVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vHpGaN {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vHpGaNVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vMpGaN {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vMpGaNVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLpGaN {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLpGaNVent {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLiN {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLiNAssist {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLOx {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLOxAssist {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLAr {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLArPurge {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vLoxPurge {
						IndexDomain: (gdm::iColdbox, gdm::iTime);
						Range: nonnegative;
					}
					Variable vLinPurge {
						IndexDomain: (gdm::iColdbox, gdm::iTime);
						Range: nonnegative;
					}
					Variable vLinAsssistColdStandby {
						IndexDomain: (gdm::iColdbox,gdm::iTime)| gdm::p01OperatingModeAllowed(gdm::iColdbox, gdm::epOperatingModeTypeColdStandBy, gdm::iTime);
						Range: nonnegative;
					}
				}
				DeclarationSection Material_balance_Declaration {
					Constraint cMaterialBalanceN2 {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance);
						Definition: {
							gdm::pN2Content * (
								vAirMp(gdm::iColdbox, gdm::iTime)
								+ vAirHp(gdm::iColdbox, gdm::iTime)
								)
							=
							vHpGan(gdm::iColdbox, gdm::iTime)
							+ vMpGan(gdm::iColdbox, gdm::iTime)
							+ vLpGan(gdm::iColdbox, gdm::iTime)
							+ vLin(gdm::iColdbox, gdm::iTime)
							- vLinAssist(gdm::iColdbox, gdm::iTime)
							+ vWasteN2(gdm::iColdbox, gdm::iTime)
						}
					}
					Constraint cMaterialBalanceO2 {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) |
							( not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							
							
							gdm::pO2Content * (
								vAirMp(gdm::iColdbox, gdm::iTime)
								+ vAirHp(gdm::iColdbox, gdm::iTime)
								)
								* vO2Recovery(gdm::iColdbox, gdm::iTime)
							=
							 vHpGox(gdm::iColdbox, gdm::iTime)
							+ vMpGox(gdm::iColdbox, gdm::iTime)
							+ vLpGox(gdm::iColdbox, gdm::iTime)
							+ vLox(gdm::iColdbox, gdm::iTime)
							+ vGoxToWaste(gdm::iColdbox, gdm::iTime)
							- vLoxAssist(gdm::iColdbox, gdm::iTime)
						}
					}
					Constraint cMaterialBalanceAr {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) | 
							( not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance) 
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							vLar(gdm::iColdbox, gdm::iTime)
							=
							gdm::pARContent * (
								vAirMp(gdm::iColdbox, gdm::iTime)
								+ vAirHp(gdm::iColdbox, gdm::iTime)
								) * vArRecovery(gdm::iColdbox, gdm::iTime)
						}
					}
				}
				DeclarationSection Nitrogen_mode_Declaration {
					Constraint cNitrogenMode {
						IndexDomain: {
							(gdm::iColdbox,gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationNitrogenMode) and 
							(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter1) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter2) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter3) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter4))
						}
						Definition: {
							
							vAirMp(gdm::iColdbox, gdm::iTime) + 
							vAirHp(gdm::iColdbox, gdm::iTime)
							>= 
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter1) * (vHpGan(gdm::iColdbox, gdm::iTime) + vMpGan(gdm::iColdbox, gdm::iTime) + vLin(gdm::iColdbox, gdm::iTime))
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter2) * vLpGan(gdm::iColdbox, gdm::iTime)
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter3) * vLinAssist(gdm::iColdbox, gdm::iTime)
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter4) * v01Box(gdm::iColdbox, gdm::iTime)
						}
					}
				}
				DeclarationSection Power_balance_Declaration {
					Variable vPowerBalanceSlackPos {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | gdm::p01AllowSlackPowerBalance;
						Range: nonnegative;
					}
					Variable vPowerBalanceSlackNeg {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | gdm::p01AllowSlackPowerBalance;
						Range: nonnegative;
					}
					Constraint cNoPowerBalanceSlackPos {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01AllowSlackPowerBalance;
						Definition: vPowerBalanceSlackPos(gdm::iColdbox, gdm::iTime) = 0;
					}
					Constraint cNoPowerBalanceSlackNeg {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01AllowSlackPowerBalance;
						Definition: vPowerBalanceSlackNeg(gdm::iColdbox, gdm::iTime) = 0;
					}
					Constraint cPowerBalance_GOK_AOK {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) | gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok
							and not gdm::p01ColdboxTypeSpecificEquation( gdm::epColdboxProcess(gdm::iColdbox) $ (gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok), gdm::epColdboxSpecificEquationPowerBalance ) 
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox )
						}
						Definition: {
							
							vAirHp(gdm::iColdbox, gdm::iTime)*log(vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirHp), gdm::iTime)/$vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp), gdm::iTime))
							=
							  gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxPumpingProcessParameter1)
							* vHpGox(gdm::iColdbox, gdm::iTime)*log(vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGOx), gdm::iTime)/$vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx), gdm::iTime))
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxPumpingProcessParameter2)
							* vMpGox(gdm::iColdbox, gdm::iTime)*log(vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeMpGOx), gdm::iTime)/$vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx), gdm::iTime))
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxPumpingProcessParameter3)
							* vHpGan(gdm::iColdbox, gdm::iTime)*log(vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGAn), gdm::iTime)/$vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp), gdm::iTime))
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxPumpingProcessParameter4)
							* vInternalLiquid(gdm::iColdbox, gdm::iTime)
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxPumpingProcessParameter5 ) * v01Box(gdm::iColdbox,gdm::iTime)
							+ vPowerBalanceSlackPos(gdm::iColdbox, gdm::iTime) 
							- vPowerBalanceSlackNeg(gdm::iColdbox, gdm::iTime)
						}
					}
					Constraint cPowerBalance_Gas {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) | gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessGas
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox) $ (gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessGas), gdm::epColdboxSpecificEquationPowerBalance)
						}
						Definition: {
							vInternalLiquid(gdm::iColdbox, gdm::iTime) 
							+ 
							gdm::pColdboxLosses(gdm::iColdbox) * v01Box(gdm::iColdbox,gdm::iTime) 
							= 
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationManualControl) * 
							vAirTurbineLp(gdm::iColdbox, gdm::iTime) 
							+ 
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationRemoteControl) * 
							vAirMp(gdm::iColdbox,gdm::iTime) 
							+ 
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationLPLevelControl) * 
							gdm::pLiquidEqCoef(gdm::epProductAr)*vLar(gdm::iColdbox, gdm::iTime)
							
							/*
							vInternalLiquid(gdm::iColdbox, gdm::iTime) + 
							gdm::pColdboxLosses(gdm::iColdbox) * v01Coldbox(gdm::iColdbox,gdm::iTime)
							 =
							 gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxTurbInsufflationManualControl) * vTurbineInsufflation(gdm::iColdbox, gdm::iTime)
							 */
						}
					}
				}
				DeclarationSection Liquid_balance_Declaration {
					Constraint cLiquidBalance {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationLiquidBalance);
						Definition: {
							(
							gdm::pLiquidEqCoef(gdm::epProductN2)*(vLin(gdm::iColdbox, gdm::iTime) - vLinAssist(gdm::iColdbox, gdm::iTime))
							+gdm::pLiquidEqCoef(gdm::epProductO2)*(vLox(gdm::iColdbox, gdm::iTime) - vLoxAssist(gdm::iColdbox, gdm::iTime))
							+gdm::pLiquidEqCoef(gdm::epProductAr)*vLar(gdm::iColdbox, gdm::iTime)
							)
							=
							
							vInternalLiquid(gdm::iColdbox, gdm::iTime)
						}
					}
					Variable vInternalLiquid {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: free;
					}
				}
				DeclarationSection Rectification_power_Declaration {
					Variable vRectificationPower {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Constraint cCalcRectificationPower {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | ( not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower) and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) );
						Definition: {
							(1-vRectificationPower(gdm::iColdbox, gdm::iTime))*
							(
								vAirMp(gdm::iColdbox, gdm::iTime)
								+ vAirHp(gdm::iColdbox, gdm::iTime)
							)
							=
							vHpGan(gdm::iColdbox, gdm::iTime)
							+ vMpGan(gdm::iColdbox, gdm::iTime)
							+ vLin(gdm::iColdbox, gdm::iTime)-vLinAssist(gdm::iColdbox, gdm::iTime)
							+ vAirTurbineLp(gdm::iColdbox, gdm::iTime)
						}
					}
					Constraint cMinRectificationPower {
						IndexDomain: (gdm::iColdbox, gdm::iTime);
						Definition: {
							
							vRectificationPower(gdm::iColdbox, gdm::iTime) >= gdm::pColdboxMinRectifPower(gdm::iColdbox) * v01Box(gdm::iColdbox,gdm::iTime)
						}
					}
					Constraint cMaxRectificationPower {
						IndexDomain: (gdm::iColdbox, gdm::iTime);
						Definition: {
							
							vRectificationPower(gdm::iColdbox, gdm::iTime) <= gdm::pColdboxMaxRectifPower(gdm::iColdbox) * v01Box(gdm::iColdbox,gdm::iTime)
						}
					}
				}
				DeclarationSection Recovery_Declaration {
					Constraint cCalcO2RecoveryLambda {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime)| ( gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLambda) > 0 
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery) 
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							vO2Recovery(gdm::iColdbox, gdm::iTime)
							=
							0.5 *
							(
								  gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter1) * vRectificationPower(gdm::iColdbox, gdm::iTime)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter2)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter3) * vRectificationPower(gdm::iColdbox, gdm::iTime)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter4)
								- sqrt(1e-10+
									sqr(
										gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter1) * vRectificationPower(gdm::iColdbox, gdm::iTime)
										+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter2)
										- (
										gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter3) * vRectificationPower(gdm::iColdbox, gdm::iTime)
										+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter4)
										  )
									)
									+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLambda)
									)
							)
							-
							0.5 *
							(
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter2)
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter4)
							- sqrt( 
								sqr(
									gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter2)
									- gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter4)
								)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLambda)
								)
							)
							* (1 - v01Box(gdm::iColdbox,gdm::iTime))
						}
					}
					Constraint cCalcO2RecoveryNoLambda {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime)|
							( gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLambda) <= 0
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery) and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							
							 vO2Recovery(gdm::iColdbox, gdm::iTime)
							=
							(
									gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter1) * vRectificationPower(gdm::iColdbox, gdm::iTime) * vRectificationPower(gdm::iColdbox, gdm::iTime)
									+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter2) * vRectificationPower(gdm::iColdbox, gdm::iTime)
									+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2Parameter3) * v01Box(gdm::iColdbox,gdm::iTime)
							)
						}
					}
					Constraint cCalcArRecoveryLambda {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) |
							( gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLambda)>0
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							vArRecovery(gdm::iColdbox, gdm::iTime)
							=
							0.5 *
							(
								  gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter1) * vRectificationPower(gdm::iColdbox, gdm::iTime)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter2) 
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter3) * vRectificationPower(gdm::iColdbox, gdm::iTime)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter4) 
								- sqrt( 1e-10+
									sqr(
										gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter1)*vRectificationPower(gdm::iColdbox, gdm::iTime)
										+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter2) 
										- (
										gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter3)*vRectificationPower(gdm::iColdbox, gdm::iTime)
										+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter4) 
										   )
									)
									+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLambda) 
									)
							)
							-
							0.5 *
							(
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryarParameter2)
							+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryarParameter4)
							- sqrt( 
								sqr(
									gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryarParameter2)
									- gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryarParameter4)
								)
								+ gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryarParameterLambda)
								)
							)
							* (1 - v01Box(gdm::iColdbox,gdm::iTime))
						}
					}
					Constraint cCalcArRecoveryNoLambda {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) |
							( gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLambda)<=0
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
							and not gdm::p01BoxLinearEquationModel( gdm::iColdbox ) )
						}
						Definition: {
							
							vArRecovery(gdm::iColdbox, gdm::iTime)
							=
							(
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter1) * vRectificationPower(gdm::iColdbox, gdm::iTime) * vRectificationPower(gdm::iColdbox, gdm::iTime)+
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter2) * vRectificationPower(gdm::iColdbox, gdm::iTime)+
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameter3) * v01Box(gdm::iColdbox,gdm::iTime)
							)
						}
					}
					Variable vO2Recovery {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Variable vArRecovery {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Constraint cMinO2Recovery {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01BoxLinearEquationModel( gdm::iColdbox );
						Definition: {
							
							vO2Recovery(gdm::iColdbox, gdm::iTime) >= gdm::pO2RecoveryMin
						}
					}
					Constraint cMaxO2Recovery {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01BoxLinearEquationModel( gdm::iColdbox );
						Definition: vO2Recovery(gdm::iColdbox, gdm::iTime) <= gdm::pO2RecoveryMax;
					}
					Constraint cMinArRecovery {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01BoxLinearEquationModel( gdm::iColdbox );
						Definition: vArRecovery(gdm::iColdbox, gdm::iTime) >= gdm::pArRecoveryMin;
					}
					Constraint cMaxArRecovery {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01BoxLinearEquationModel( gdm::iColdbox );
						Definition: vArRecovery(gdm::iColdbox, gdm::iTime) <= gdm::pArRecoveryMax;
					}
				}
				DeclarationSection Internal_Flow_constraints_Declaration {
					Variable vColdboxInternalFlow {
						IndexDomain: (gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime);
						Range: free;
					}
					Variable v01ColdboxInternalFlowPositiveRateChange {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
							and ( p01ColdBoxFlowDirection(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) or 
							    ( gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) > 1) )
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Range: binary;
					}
					Variable v01ColdboxInternalFlowNegativeRateChange {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
							and ( p01ColdBoxFlowDirection(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) or 
							    ( gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) > 1) )
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Range: binary;
					}
					Constraint cMinInternalFlowColdbox {
						IndexDomain: (gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) | not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow);
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
							>=
							gdm::pColdboxMinInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime)*v01Box(gdm::iColdbox,gdm::iTime)
						}
					}
					Constraint cMaxInternalFlowColdbox {
						IndexDomain: (gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) | not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow);
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
							<=
							gdm::pColdboxMaxInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime)*v01Box(gdm::iColdbox,gdm::iTime)
						}
					}
					Constraint cColdboxDirectionRateChange1 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
							and ( p01ColdboxFlowDirection(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) or 
							    ( gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) > 1) )
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)
							+
							v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)
							<= 
							1
						}
					}
					Constraint cColdboxDirectionRateChange2 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
							and ( p01ColdboxFlowDirection(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) or 
							    ( gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) > 1) )
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1)
							>=
							((gdm::pColdboxMinPositiveRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) + 1) * v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
							- 
							gdm::pColdboxMaxInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) * v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)) * gdm::pPeriodInHours
						}
					}
					Constraint cColdboxDirectionRateChange3 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
							and ( p01ColdboxFlowDirection(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) or 
							    ( gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) > 1) )
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1)
							<=
							(gdm::pColdboxMaxInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) * v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
							+ 
							(gdm::pColdboxMinNegativeRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) - 1) * v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)) * gdm::pPeriodInHours
						}
					}
					Constraint cColdboxMaxPositiveRateChange {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
							and gdm::pColdboxMaxPositiveRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1)
							<=
							( gdm::pColdboxMaxPositiveRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) +
							  gdm::pColdboxMaxInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime)*(1 - v01Box(gdm::iColdbox,gdm::iTime-1))
							)*gdm::pPeriodInHours
						}
					}
					Constraint cColdboxMaxNegativeRateChange {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
							and gdm::pColdboxMaxNegativeRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - vColdboxInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1)
							>=
							( gdm::pColdboxMaxNegativeRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) -
							  gdm::pColdboxMaxInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime)*(1 - v01Box(gdm::iColdbox,gdm::iTime))
							)*gdm::pPeriodInHours
						}
					}
					Constraint cColdboxSteadyStateAfterRamp1 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)|  
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) > 1)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
									   and ord(gdm::iTime2) > ord(gdm::iTime),  
							v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime2) ) 
							<=
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 1)  
							* 
							( (1 - v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime))
							   +
							  (1 - v01Box(gdm::iColdbox, gdm::iTime))
							)
						}
					}
					Constraint cColdboxSteadyStateAfterRamp2 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)|
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) > 1)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)
									   and ord(gdm::iTime2) > ord(gdm::iTime), 
							v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime2) ) 
							<=
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 1)  
							* 
							( (1 - v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime))
							   +
							  (1 - v01Box(gdm::iColdbox, gdm::iTime))
							)
						}
					}
					Constraint cColdboxMinStayTimeInSteadyState1 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)|  (gdm::iTime <> gdm::epFirstTimeUnit) 
							and (gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) > 1)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							
							sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 1) 
									     and ord(gdm::iTime2) > ord(gdm::iTime),
							v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime2) ) 
							<=
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 2)  
							* 
							( 1 + v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)  
							    - v01ColdboxInternalFlowPositiveRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1) 
							)
						}
					}
					Constraint cColdboxMinStayTimeInSteadyState2 {
						IndexDomain: {
							(gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime)|  (gdm::iTime <> gdm::epFirstTimeUnit) 
							and (gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) > 1)
							and not gdm::p01ColdboxInternalFlowSpecificEquation(gdm::iColdbox, gdm::iColdboxInternalFlow)
						}
						Definition: {
							
							
							sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 1) 
									     and ord(gdm::iTime2) > ord(gdm::iTime), 
							v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime2) ) 
							<=
							(gdm::pColdboxMinStayTimeSteadyStateInternalFlow(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime) - 2)  
							*
							( 1 + v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime)  
							    - v01ColdboxInternalFlowNegativeRateChange(gdm::iColdbox, gdm::iColdboxInternalFlow, gdm::iTime-1) 
							)
						}
					}
					Parameter p01ColdboxFlowDirection {
						IndexDomain: (gdm::iColdbox,gdm::iColdboxInternalFlow,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
						Range: binary;
						Definition: {
							
							gdm::pColdboxMinPositiveRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) <>0 
							OR
							gdm::pColdboxMinNegativeRateChangeInternalFlow(gdm::iColdbox,gdm::iColdboxInternalFlow, gdm::iTime) <>0
						}
					}
				}
				DeclarationSection Coldbox_Pressure_Declaration {
					Constraint cSetPressureColdboxNodes {
						IndexDomain: {
							(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime) | gdm::p01boxPressureActive(gdm::iColdbox,gdm::iBoxNodeConnectionType)
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationPressure)
						}
						Definition: {
							
							
							vPressure(gdm::epboxNode(gdm::iColdbox,gdm::iBoxNodeConnectionType), gdm::iTime)
							=
							gdm::pboxParameter1Pres(gdm::iColdbox,gdm::iBoxNodeConnectionType)*vAirHp(gdm::iColdbox, gdm::iTime) +
							gdm::pboxParameter2Pres(gdm::iColdbox,gdm::iBoxNodeConnectionType)*vAirMp(gdm::iColdbox, gdm::iTime) +
							gdm::pboxParameter3Pres(gdm::iColdbox,gdm::iBoxNodeConnectionType)
						}
					}
				}
				DeclarationSection Regeneration_Declaration {
					Variable vWaste {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
						Comment: "waste";
					}
					Variable vWasteO2 {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
						Comment: "O2 partial flow in the waste";
					}
					Variable vWasteN2 {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
						Comment: "N2 partial flow in the waste";
					}
					Variable vGOxToWaste {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
					Constraint cCalcWasteFlow {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance);
						Definition: {
							
							
							vWaste(gdm::iColdbox, gdm::iTime)
							=
							vWasteO2(gdm::iColdbox, gdm::iTime) + vWasteN2(gdm::iColdbox, gdm::iTime)
						}
					}
					Constraint cCalcWasteO2 {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance);
						Definition: {
							
							! O2 not recovered is in the waste
							
							vWasteO2(gdm::iColdbox, gdm::iTime) 
							=
							gdm::pO2Content * ( vAirMp(gdm::iColdbox, gdm::iTime)+ vAirHp(gdm::iColdbox, gdm::iTime)) 
							- 
							(     vHpGox(gdm::iColdbox, gdm::iTime)
							    + vMpGox(gdm::iColdbox, gdm::iTime)
							    + vLpGox(gdm::iColdbox, gdm::iTime)
							    + vLox(gdm::iColdbox, gdm::iTime)
							    + vGoxToWaste(gdm::iColdbox, gdm::iTime)
							    - vLoxAssist(gdm::iColdbox, gdm::iTime)
							  )
						}
					}
					Constraint cGOxToWasteContentMax {
						IndexDomain: (gdm::iColdbox, gdm::iTime) | not gdm::pColdboxMaxO2ContentInWaste(gdm::iColdbox) = 0 and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance);
						Definition: {
							
							! limits the gox to waste in order to keep O2 content below a certain value
							
							(vWasteO2(gdm::iColdbox, gdm::iTime) + vGoxToWaste(gdm::iColdbox, gdm::iTime)) 
							<=
							gdm::pColdboxMaxO2ContentInWaste(gdm::iColdbox)*(vWaste(gdm::iColdbox, gdm::iTime) + vGoxToWaste(gdm::iColdbox, gdm::iTime))
						}
					}
					Constraint cWasteGOxToWaste {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) | ( (not gdm::p01BoxLinearEquationModel(gdm::iColdbox)) and gdm::pBoxMaxFlow(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx, gdm::iTime) )
							and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						}
						Definition: {
							
							vLpGaNVent(gdm::iColdbox, gdm::iTime) * vGoxToWaste(gdm::iColdbox, gdm::iTime) <= 1.e-04
						}
					}
					Constraint cRegeneration {
						IndexDomain: {
							(gdm::iColdbox, gdm::iTime) | not (gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter1) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter2) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter3) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter4))
							and gdm::pColdboxWasteToAirRatio(gdm::iColdbox) and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						}
						Definition: {
							
							! total waste flow necessary for regeneration
							
							vWaste(gdm::iColdbox, gdm::iTime) + vGoxToWaste(gdm::iColdbox, gdm::iTime)
							= 
							gdm::pColdboxWasteToAirRatio(gdm::iColdbox)*(vAirMp(gdm::iColdbox, gdm::iTime) + vAirHp(gdm::iColdbox, gdm::iTime))
						}
					}
					Constraint cRegenerationNitrogenMode {
						IndexDomain: {
							(gdm::iColdbox,gdm::iTime) | ( gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter1) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter2) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter3) or
							 gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxNitrogenModeParameter4) )
							and gdm::pColdboxWasteToAirRatio(gdm::iColdbox) and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						}
						Definition: {
							
							 vWaste(gdm::iColdbox, gdm::iTime)
							+ vGoxToWaste(gdm::iColdbox, gdm::iTime)
							>= 
							gdm::pColdboxWasteToAirRatio(gdm::iColdbox)*
							(vAirMp(gdm::iColdbox, gdm::iTime) + vAirHp(gdm::iColdbox, gdm::iTime))
						}
					}
				}
				DeclarationSection Turbine_Insufflation_Declaration {
					Variable vAirTurbineLp {
						IndexDomain: (gdm::iColdbox,gdm::iTime);
						Range: nonnegative;
					}
				}
				DeclarationSection Coldbox_Status_Declaration {
					Constraint cLinAssistColdStandby {
						IndexDomain: (gdm::iColdbox, gdm::iTime)| gdm::iColdbox in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iColdbox);
						Definition: {
							
							
							vLinAsssistColdStandby(gdm::iColdbox,gdm::iTime) = gdm::pColdboxLinAssistColdStandby(gdm::iColdbox)*v01ElementInOperatingMode(gdm::iColdbox,gdm::epOperatingModeTypeColdStandBy,gdm::iTime)
						}
					}
				}
				DeclarationSection ColdBox_Power_declaration {
					Constraint cColdBoxPowerNull {
						IndexDomain: (gdm::iColdBox,gdm::iTime);
						Definition: vboxPower(gdm::iColdBox, gdm::iTime)=0;
					}
				}
			}
		}
		DeclarationSection element_pressure_control_node {
			Variable vPressure {
				IndexDomain: (gdm::iNode,gdm::iTime);
				Text: "Pressure";
				Range: [gdm::pNodeMinPressure(gdm::iNode), gdm::pNodeMaxPressure(gdm::iNode)];
			}
			Variable vPressureSlackPos {
				IndexDomain: (gdm::iPressureControlNode,gdm::iTime) | gdm::p01AllowSlackPressure;
				Range: nonnegative;
			}
			Variable vPressureSlackNeg {
				IndexDomain: (gdm::iPressureControlNode,gdm::iTime) | gdm::p01AllowSlackPressure;
				Range: nonnegative;
			}
			Variable vPressurePenalty {
				IndexDomain: (gdm::iTime)| gdm::p01AllowPressurePenalty;
				Range: free;
				Definition: {
					
					0.01*sum(gdm::iNode,vPressure(gdm::iNode, gdm::iTime))
				}
			}
			Constraint cSetPressureSetpoint {
				IndexDomain: {
					(gdm::iPressureControlNode, gdm::iTime)|
					gdm::pPressureControlNodeSetpoint(gdm::iPressureControlNode,gdm::iTime)
				}
				Definition: {
					
					vPressure(gdm::iPressureControlNode, gdm::iTime)
					=
					gdm::pPressureControlNodeSetpoint(gdm::iPressureControlNode,gdm::iTime) + 
					vPressureSlackPos(gdm::iPressureControlNode, gdm::iTime) - 
					vPressureSlackNeg(gdm::iPressureControlNode, gdm::iTime)
				}
			}
		}
		DeclarationSection element_backup {
			Variable v01Backup {
				IndexDomain: (gdm::iBackupArc,gdm::iTime);
				Range: binary;
			}
			Variable vFlashBackup {
				IndexDomain: (gdm::iBackupArc,gdm::iTime);
				Range: nonnegative;
			}
			Constraint cFlashBackup {
				IndexDomain: (gdm::iBackupArc,gdm::iTime) | not gdm::p01BackupFlashSpecificEquation(gdm::iBackupArc);
				Definition: {
					
					vFlashBackup(gdm::iBackupArc, gdm::iTime)
					=
					gdm::pBackupPcFlash(gdm::iBackupArc,gdm::iTime) * ( gdm::pBackupMaxFlow(gdm::iBackupArc,gdm::iTime) * gom::v01Backup(gdm::iBackupArc,gdm::iTime)  - gom::vFlow(gdm::iBackupArc,gdm::iTime) )
					+
					vFlashBackupCoolDown(gdm::iBackupArc, gdm::iTime)
				}
			}
			Constraint cMaxFlowBackup {
				IndexDomain: (gdm::iBackupArc, gdm::iTime);
				Definition: {
					
					
					vFlow(gdm::iBackupArc, gdm::iTime) <= gdm::pBackupMaxFlow(gdm::iBackupArc, gdm::iTime)*v01Backup(gdm::iBackupArc, gdm::iTime)
				}
			}
			Constraint cMinFlowBackup {
				IndexDomain: (gdm::iBackupArc, gdm::iTime);
				Definition: {
					
					
					vFlow(gdm::iBackupArc, gdm::iTime) >= gdm::pBackupMinFlow(gdm::iBackupArc, gdm::iTime)*v01Backup(gdm::iBackupArc, gdm::iTime)
				}
			}
			Variable v01BackupFlowPositiveRateChange {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit)
					and ( p01BackupDirectionFlow(gdm::iBackupArc, gdm::iTime) or 
					    ( gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable v01BackupFlowNegativeRateChange {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01BackupDirectionFlow(gdm::iBackupArc, gdm::iTime) or 
					    ( gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Constraint cBackupDirectionRateChange1 {
				IndexDomain: {
					(gdm::iBackupArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01BackupDirectionFlow(gdm::iBackupArc, gdm::iTime) or 
					    ( gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime)
					+
					v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime)
					<= 
					1
				}
			}
			Constraint cBackupDirectionRateChange2 {
				IndexDomain: {
					(gdm::iBackupArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01BackupDirectionFlow(gdm::iBackupArc, gdm::iTime) or 
					    ( gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iBackupArc, gdm::iTime) - gom::vFlow(gdm::iBackupArc, gdm::iTime-1)  
					>=
					(
						(gdm::pBackupMinPositiveRateChangeFlow(gdm::iBackupArc, gdm::iTime) + 1) * v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime)  
						- 
						gdm::pBackupMaxFlow(gdm::iBackupArc, gdm::iTime) * v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cBackupDirectionRateChange3 {
				IndexDomain: {
					(gdm::iBackupArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01BackupDirectionFlow(gdm::iBackupArc, gdm::iTime) or 
					    ( gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iBackupArc, gdm::iTime) - gom::vFlow(gdm::iBackupArc, gdm::iTime-1)  
					<= 
					(
						gdm::pBackupMaxFlow(gdm::iBackupArc, gdm::iTime) * v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime) 
						+ 
						(gdm::pBackupMinNegativeRateChangeFlow(gdm::iBackupArc, gdm::iTime) - 1) * v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cBackupMaxPositiveRateChange {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pBackupMaxPositiveRateChangeFlow(gdm::iBackupArc,gdm::iTime)
				}
				Definition: {
					
					
					vFlow(gdm::iBackupArc,gdm::iTime) 
					-
					vFlow(gdm::iBackupArc,gdm::iTime-1) 
					<= 
					(
						gdm::pBackupMaxPositiveRateChangeFlow(gdm::iBackupArc,gdm::iTime)  
						+
						gdm::pBackupMaxFlow(gdm::iBackupArc, gdm::iTime)*(1 - v01Backup(gdm::iBackupArc,gdm::iTime-1))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cBackupMaxNegativeRateChange {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pBackupMaxNegativeRateChangeFlow(gdm::iBackupArc,gdm::iTime)
				}
				Definition: {
					
					
					vFlow(gdm::iBackupArc,gdm::iTime)
					-
					vFlow(gdm::iBackupArc,gdm::iTime-1) 
					>= 
					(
						gdm::pBackupMaxNegativeRateChangeFlow(gdm::iBackupArc,gdm::iTime) 
						-
						gdm::pBackupMaxFlow(gdm::iBackupArc, gdm::iTime)*(1 - v01Backup(gdm::iBackupArc,gdm::iTime))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cBackupSteadyStateAfterRamp1 {
				IndexDomain: (gdm::iBackupArc,gdm::iTime) | (gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime),  
					v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime2) ) 
					<=
					(gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 1)  
					* 
					( (1 - v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime))
					   +
					  (1 - v01Backup(gdm::iBackupArc, gdm::iTime))
					)
				}
			}
			Constraint cBackupSteadyStateAfterRamp2 {
				IndexDomain: (gdm::iBackupArc,gdm::iTime) | (gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime2) ) 
					<=
					(gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 1)  
					* 
					( (1 - v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime) )
					   +
					  (1 - v01Backup(gdm::iBackupArc, gdm::iTime))
					)
				}
			}
			Constraint cBackupMinStayTimeInSteadyState1 {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1)
				}
				Definition: {
					
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime),
					v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime2) ) 
					<=
					(gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 2)  
					* 
					( 1 + v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime)  
					    - v01BackupFlowPositiveRateChange(gdm::iBackupArc, gdm::iTime-1) 
					)
				}
			}
			Constraint cBackupMinStayTimeInSteadyState2 {
				IndexDomain: {
					(gdm::iBackupArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) > 1)
				}
				Definition: {
					
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime),
					v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime2) ) 
					<=
					(gdm::pBackupMinStayTimeSteadyState(gdm::iBackupArc,gdm::iTime) - 2)  
					* 
					( 1 + v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime) 
					    - v01BackupFlowNegativeRateChange(gdm::iBackupArc, gdm::iTime-1) 
					)
				}
			}
			Parameter p01BackupDirectionFlow {
				IndexDomain: (gdm::iBackupArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
				Range: binary;
				Definition: {
					
					gdm::pBackupMinPositiveRateChangeFlow(gdm::iBackupArc, gdm::iTime) <>0 
					OR
					gdm::pBackupMinNegativeRateChangeFlow(gdm::iBackupArc, gdm::iTime)<>0
				}
			}
		}
		DeclarationSection element_tank {
			Variable vLiquidSlackMax {
				IndexDomain: (gdm::iTankNode,gdm::iTime)| gdm::p01AllowSlackLiquid;
				Range: nonnegative;
			}
			Variable vLiquidSlackMin {
				IndexDomain: (gdm::iTankNode,gdm::iTime)| gdm::p01AllowSlackLiquid;
				Range: nonnegative;
			}
			Variable vTankLevel {
				IndexDomain: (gdm::iTankNode,gdm::iTime);
				Range: [0, gdm::pTankStorageCapacity(gdm::iTankNode)];
			}
			Constraint cNoSlackMin {
				IndexDomain: (gdm::iTankNode, gdm::iTime) | gdm::p01AllowSlackLiquid=0;
				Definition: vLiquidSlackMin(gdm::iTankNode, gdm::iTime) = 0;
			}
			Constraint cNoSlackMax {
				IndexDomain: (gdm::iTankNode, gdm::iTime) | gdm::p01AllowSlackLiquid=0;
				Definition: {
					
					vLiquidSlackMax(gdm::iTankNode, gdm::iTime) = 0
				}
			}
			Constraint cMinTargetLevelLiquid {
				IndexDomain: (gdm::iTankNode, gdm::iTime)| gdm::p01TankEnableLevelConstraints(gdm::iTankNode, gdm::iTime);
				Definition: {
					
					
					vTankLevel(gdm::iTankNode, gdm::iTime)
					>= 
					gdm::pTankMinLevel(gdm::iTankNode, gdm::iTime) - vLiquidSlackMin(gdm::iTankNode, gdm::iTime)
				}
			}
			Constraint cMaxTargetLevelLiquid {
				IndexDomain: (gdm::iTankNode, gdm::iTime)|gdm::p01TankEnableLevelConstraints(gdm::iTankNode, gdm::iTime);
				Definition: {
					
					
					vTankLevel(gdm::iTankNode, gdm::iTime)
					<=
					gdm::pTankMaxLevel(gdm::iTankNode, gdm::iTime) + vLiquidSlackMax(gdm::iTankNode, gdm::iTime)
				}
			}
			Constraint cMaterialBalanceTank {
				IndexDomain: (gdm::iTankNode,gdm::iTime);
				Definition: {
					if ( gdm::iTime <> gdm::epFirstTimeUnit ) then
						sum(gdm::iArc,p01MapFlowTo(gdm::iTankNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime)) - sum(gdm::iArc,p01MapFlowFrom(gdm::iTankNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime)) +
						vInputFlow( gdm::iTankNode, gdm::iTime ) - vOutputFlow( gdm::iTankNode, gdm::iTime )
						=
						( vTankLevel( gdm::iTankNode, gdm::iTime ) - vTankLevel( gdm::iTankNode, gdm::iTime - 1 ) ) / gdm::pPeriodInHours / gdm::pLiquidMassToVolumeUnits(gdm::epTankLiquidProduct(gdm::iTankNode))
					else
						sum(gdm::iArc,p01MapFlowTo(gdm::iTankNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime)) - sum(gdm::iArc,p01MapFlowFrom(gdm::iTankNode,gdm::iArc)*vFlow(gdm::iArc, gdm::iTime)) +
						vInputFlow( gdm::iTankNode, gdm::iTime ) - vOutputFlow( gdm::iTankNode, gdm::iTime )
						=
						( vTankLevel( gdm::iTankNode, gdm::iTime ) - gdm::pTankInitialLevel( gdm::iTankNode ) ) / gdm::pPeriodInHours / gdm::pLiquidMassToVolumeUnits(gdm::epTankLiquidProduct(gdm::iTankNode))
					endif;
				}
			}
			Variable vFlashTank {
				IndexDomain: (gdm::iTankNode,gdm::iTime);
				Range: nonnegative;
			}
			Constraint cFlashTank {
				IndexDomain: (gdm::iTankNode,gdm::iTime) | not gdm::p01TankFlashSpecificEquation(gdm::iTankNode);
				Definition: {
					
					
					vFlashTank(gdm::iTankNode,gdm::iTime)
					=
					sum(gdm::iBackupArc|gdm::epNodeFrom(gdm::iBackupArc) = gdm::iTankNode, vFlashBackup(gdm::iBackupArc, gdm::iTime))
				}
			}
		}
		DeclarationSection element_compressor {
			Variable vCompressorPower {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime);
				Range: nonnegative;
			}
			Variable vCompressorEfficiency {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime);
				Range: free;
			}
			Variable v01Compressor {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime);
				Range: binary;
			}
			Constraint cCalcKwCompressor {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) |( not gdm::p01CompressorPowerSpecificEquation(gdm::iCompressorArc) and not gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) );
				Definition: {
					
					
					vCompressorPower(gdm::iCompressorArc, gdm::iTime)*
					vCompressorEfficiency(gdm::iCompressorArc, gdm::iTime) =
					gdm::pSIunitsToPowerUnits *
					((gdm::pPreference/gdm::pTreference)/gdm::pHoursToSeconds) * 
					gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::iCompressorArc), gdm::iTime) *
					vFlow(gdm::iCompressorArc, gdm::iTime) *
					log((vPressure(gdm::epNodeTo(gdm::iCompressorArc), gdm::iTime)/$vPressure(gdm::epNodeFrom(gdm::iCompressorArc), gdm::iTime)))
				}
			}
			Constraint cCalcEfficiencyCompressor {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | ( not gdm::p01CompressorPowerSpecificEquation(gdm::iCompressorArc) and not gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) );
				Definition: {
					vCompressorEfficiency(gdm::iCompressorArc, gdm::iTime)
					=
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterEff1)*vFlow(gdm::iCompressorArc, gdm::iTime)^2/$gdm::pScaleFactorCompressorParam1
					+ gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterEff2)*vFlow(gdm::iCompressorArc, gdm::iTime)/$gdm::pScaleFactorCompressorParam2
					+ gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterEff3)*gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::iCompressorArc), gdm::iTime)/$gdm::pScaleFactorCompressorParam3
					+ gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterEff4)*vPressure(gdm::epNodeTo(gdm::iCompressorArc), gdm::iTime)/$vPressure(gdm::epNodeFrom(gdm::iCompressorArc), gdm::iTime)/$gdm::pScaleFactorCompressorParam4
					+ gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterEff5)
					
					! EL 06/04/2016 add division by scallar factor define in the interface
				}
			}
			Constraint cMinFlowCompressor {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime);
				Definition: {
					
					
					vFlow(gdm::iCompressorArc, gdm::iTime) 
					>= 
					gdm::pCompressorMinFlow(gdm::iCompressorArc, gdm::iTime)*v01Compressor(gdm::iCompressorArc,gdm::iTime)
					- 
					vCompressorFlowMinSlack(gdm::iCompressorArc, gdm::iTime)
				}
			}
			Constraint cMaxFlowCompressor {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime);
				Definition: {
					
					
					vFlow(gdm::iCompressorArc, gdm::iTime) 
					<=
					gdm::pCompressorMaxFlow(gdm::iCompressorArc, gdm::iTime)*v01Compressor(gdm::iCompressorArc,gdm::iTime)
					+ 
					vCompressorFlowMaxSlack(gdm::iCompressorArc, gdm::iTime)
				}
			}
			Parameter pMaxTheoreticalCompressorPower {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime) | gdm::pCompressorMaxPower(gdm::iCompressorArc,gdm::iTime) = 0;
				Definition: {
					
					(1/0.01) *
					gdm::pSIunitsToPowerUnits *
					((gdm::pPreference/gdm::pTreference)/gdm::pHoursToSeconds) * 
					gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::iCompressorArc), gdm::iTime) *
					gdm::pCompressorMaxFlow(gdm::iCompressorArc,gdm::iTime) *
					log((gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::iCompressorArc))/$gdm::pNodeMinPressure(gdm::epNodeFrom(gdm::iCompressorArc))))
				}
			}
			Constraint cMaxPowerCompressor {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime);
				Definition: {
					
					vCompressorPower(gdm::iCompressorArc,gdm::iTime) 
					<= 
					v01Compressor(gdm::iCompressorArc,gdm::iTime)
					*
					(gdm::pCompressorMaxPower(gdm::iCompressorArc,gdm::iTime) + pMaxTheoreticalCompressorPower(gdm::iCompressorArc, gdm::iTime))
				}
			}
			Constraint cSetCompressorSimultaneous {
				IndexDomain: (gdm::iCompressorDependency, gdm::iTime)|gdm::p01CompressorRunTogether(gdm::iCompressorDependency);
				Definition: {
					
					v01Compressor(gdm::epCompressorMapSpecial_1(gdm::iCompressorDependency),gdm::iTime) 
					=
					v01Compressor(gdm::epCompressorMapSpecial_2(gdm::iCompressorDependency),gdm::iTime)
				}
				Comment: "Special compressor is started if and only if linked compressor is started";
			}
			Constraint cSetCompressorExclusion {
				IndexDomain: (gdm::iCompressorDependency, gdm::iTime)|not gdm::p01CompressorRunTogether(gdm::iCompressorDependency);
				Definition: {
					
					v01Compressor(gdm::epCompressorMapSpecial_1(gdm::iCompressorDependency),gdm::iTime) 
					+ 
					v01Compressor(gdm::epCompressorMapSpecial_2(gdm::iCompressorDependency),gdm::iTime) 
					<=
					1
				}
				Comment: "Special compressor is not started at the same time as linked compressor";
			}
			Constraint cCompressionRateMax {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | not gdm::pCompressorMaxCompressionRatio(gdm::iCompressorArc) = 0;
				Definition: {
					
					vPressure(gdm::epNodeTo(gdm::iCompressorArc), gdm::iTime)
					<=
					vPressure(gdm::epNodeFrom(gdm::iCompressorArc), gdm::iTime) * gdm::pCompressorMaxCompressionRatio(gdm::iCompressorArc)
					+ (1 - v01Compressor(gdm::iCompressorArc, gdm::iTime) )  * gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::iCompressorArc))
				}
			}
			Variable vCompressorFlowMinSlack {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | gdm::p01AllowSlackCompressorFlow;
				Range: nonnegative;
			}
			Variable vCompressorFlowMaxSlack {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | gdm::p01AllowSlackCompressorFlow;
				Range: nonnegative;
			}
			Constraint cNoSlackCompressorFlowMin {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | not gdm::p01AllowSlackCompressorFlow;
				Definition: {
					
					vCompressorFlowMinSlack(gdm::iCompressorArc, gdm::iTime) = 0;
				}
			}
			Constraint cNoSlackCompressorFlowMax {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | not gdm::p01AllowSlackCompressorFlow;
				Definition: {
					
					vCompressorFlowMaxSlack(gdm::iCompressorArc, gdm::iTime) = 0;
				}
			}
			Variable v01CompressorFlowPositiveRateChange {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit)
					and (p01CompressorDirectionFlow(gdm::iCompressorArc, gdm::iTime) or 
					    (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable v01CompressorFlowNegativeRateChange {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (p01CompressorDirectionFlow(gdm::iCompressorArc, gdm::iTime) or 
					    (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Constraint cCompressorDirectionRateChange1 {
				IndexDomain: {
					(gdm::iCompressorArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (p01CompressorDirectionFlow(gdm::iCompressorArc, gdm::iTime) or 
					    (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime)
					+
					v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime)
					<= 
					1
				}
			}
			Constraint cCompressorDirectionRateChange2 {
				IndexDomain: {
					(gdm::iCompressorArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (p01CompressorDirectionFlow(gdm::iCompressorArc, gdm::iTime) or 
					    (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iCompressorArc, gdm::iTime) - gom::vFlow(gdm::iCompressorArc, gdm::iTime-1)  
					>=
					(
						(gdm::pCompressorMinPositiveRateChangeFlow(gdm::iCompressorArc, gdm::iTime) + 1) * v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime)  
						- 
						gdm::pCompressorMaxFlow(gdm::iCompressorArc, gdm::iTime) * v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cCompressorDirectionRateChange3 {
				IndexDomain: {
					(gdm::iCompressorArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (p01CompressorDirectionFlow(gdm::iCompressorArc, gdm::iTime) or 
					    (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iCompressorArc, gdm::iTime) - gom::vFlow(gdm::iCompressorArc, gdm::iTime-1)  
					<= 
					(
						gdm::pCompressorMaxFlow(gdm::iCompressorArc, gdm::iTime) * v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime) 
						+ 
						(gdm::pCompressorMinNegativeRateChangeFlow(gdm::iCompressorArc, gdm::iTime) - 1) * v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cCompressorMaxPositiveRateChange {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pCompressorMaxPositiveRateChangeFlow(gdm::iCompressorArc,gdm::iTime)
				}
				Definition: {
					
					vFlow(gdm::iCompressorArc,gdm::iTime) 
					-
					vFlow(gdm::iCompressorArc,gdm::iTime-1) 
					<= 
					(
						gdm::pCompressorMaxPositiveRateChangeFlow(gdm::iCompressorArc,gdm::iTime)  
						+
						gdm::pCompressorMaxFlow(gdm::iCompressorArc, gdm::iTime)*(1 - v01Compressor(gdm::iCompressorArc,gdm::iTime-1))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cCompressorMaxNegativeRateChange {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pCompressorMaxNegativeRateChangeFlow(gdm::iCompressorArc,gdm::iTime)
				}
				Definition: {
					
					vFlow(gdm::iCompressorArc,gdm::iTime)
					-
					vFlow(gdm::iCompressorArc,gdm::iTime-1) 
					>= 
					(
						gdm::pCompressorMaxNegativeRateChangeFlow(gdm::iCompressorArc,gdm::iTime) 
						-
						gdm::pCompressorMaxFlow(gdm::iCompressorArc, gdm::iTime)*(1 - v01Compressor(gdm::iCompressorArc,gdm::iTime))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cCompressorSteadyStateAfterRamp1 {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime) | (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime),  
					v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime2) ) 
					<=
					(gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 1)  
					* 
					( (1 - v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime))
					   +
					  (1 - v01Compressor(gdm::iCompressorArc, gdm::iTime))
					)
				}
			}
			Constraint cCompressorSteadyStateAfterRamp2 {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime) | (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime2) ) 
					<=
					(gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 1)  
					* 
					( (1 - v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime) )
					   +
					  (1 - v01Compressor(gdm::iCompressorArc, gdm::iTime))
					)
				}
			}
			Constraint cCompressorMinStayTimeInSteadyState1 {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1)
				}
				Definition: {
					
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime),
					v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime2) ) 
					<=
					(gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 2)  
					* 
					( 1 + v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime)  
					    - v01CompressorFlowPositiveRateChange(gdm::iCompressorArc, gdm::iTime-1) 
					)
				}
			}
			Constraint cCompressorMinStayTimeInSteadyState2 {
				IndexDomain: {
					(gdm::iCompressorArc,gdm::iTime) |(gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) > 1)
				}
				Definition: {
					
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime2) ) 
					<=
					(gdm::pCompressorMinStayTimeSteadyState(gdm::iCompressorArc,gdm::iTime) - 2)  
					* 
					( 1 + v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime)  
					    - v01CompressorFlowNegativeRateChange(gdm::iCompressorArc, gdm::iTime-1) 
					)
				}
			}
			Parameter p01CompressorDirectionFlow {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
				Range: binary;
				Definition: {
					
					gdm::pCompressorMinPositiveRateChangeFlow(gdm::iCompressorArc, gdm::iTime) <>0 
					OR
					gdm::pCompressorMinNegativeRateChangeFlow(gdm::iCompressorArc, gdm::iTime) <>0
				}
			}
		}
		DeclarationSection element_liquefier {
			Variable v01Liquefier {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime);
				Range: binary;
			}
			Variable vLiquefierPower {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime)|gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeBasic;
				Range: nonnegative;
			}
			Constraint cCalcKwLiquefierOrCycleFlow {
				IndexDomain: (gdm::iLiquefierArc, gdm::iTime) | ( not gdm::p01LiquefierPowerSpecificEquation(gdm::iLiquefierArc) and not gdm::p01LiquefierLinearEquationModel( gdm::iLiquefierArc ) );
				Definition: {
					if gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeBasic then
						vLiquefierPower(gdm::iLiquefierArc, gdm::iTime)*(
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf1)*vFlow(gdm::iLiquefierArc, gdm::iTime)+
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf2)*gdm::pCoolingTowerTemperature(gdm::epLiquefierCoolingTower(gdm::iLiquefierArc), gdm::iTime)+
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf3))
						=
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf4)*vFlow(gdm::iLiquefierArc, gdm::iTime)
					elseif gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced then
						vFlow(gdm::epLiquefierCycle(gdm::iLiquefierArc), gdm::iTime)*
						log(	vPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)), gdm::iTime)/$
							vPressure(gdm::epNodeFrom(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)), gdm::iTime))
						=
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf4)*vFlow(gdm::iLiquefierArc, gdm::iTime)
						+ gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf5)*gom::v01Liquefier(gdm::iLiquefierArc, gdm::iTime)
					else
						0 = 0
					endif
				}
			}
			Constraint cMinFlowLiquefier {
				IndexDomain: (gdm::iLiquefierArc, gdm::iTime);
				Definition: {
					
					vFlow(gdm::iLiquefierArc, gdm::iTime)
					>=
					gdm::pLiquefierMinFlow(gdm::iLiquefierArc, gdm::iTime)*v01Liquefier(gdm::iLiquefierArc,gdm::iTime)
				}
			}
			Constraint cMaxFlowLiquefier {
				IndexDomain: (gdm::iLiquefierArc, gdm::iTime);
				Definition: {
					
					vFlow(gdm::iLiquefierArc, gdm::iTime)
					<=
					gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime)*v01Liquefier(gdm::iLiquefierArc,gdm::iTime)
				}
			}
			Parameter pMaxTheoreticalLiquefierPower {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime) | gdm::pLiquefierMaxPower(gdm::iLiquefierArc,gdm::iTime) = 0;
				Definition: {
					
					If gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeBasic then
					
						if (not gdm::p01LiquefierLinearEquationModel(gdm::iLiquefierArc)) then
							(1/0.01) * gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerf4) * gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime)
						else
							gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear1)*gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime) +
							gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear2)*gdm::pCoolingTowerTemperature(gdm::epLiquefierCoolingTower(gdm::iLiquefierArc), gdm::iTime) +
							gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear3)
						endif
					else
						pMaxTheoreticalCompressorPower(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc), gdm::iTime) 
						+ 
						pMaxTheoreticalCompressorPower(gdm::epLiquefierCompressorFeed(gdm::iLiquefierArc), gdm::iTime)
					endif;
				}
			}
			Constraint cMaxPowerLiquefier {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime);
				Definition: {
					
					If gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeBasic then
					
						vLiquefierPower(gdm::iLiquefierArc,gdm::iTime) 
						<=
						v01Liquefier(gdm::iLiquefierArc,gdm::iTime) *
						(gdm::pLiquefierMaxPower(gdm::iLiquefierArc,gdm::iTime) 
						+ pMaxTheoreticalLiquefierPower(gdm::iLiquefierArc, gdm::iTime))
					
					else
					
						gom::vCompressorPower(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) +
						gom::vCompressorPower(gdm::epLiquefierCompressorFeed(gdm::iLiquefierArc),gdm::iTime)
						<=
						v01Liquefier(gdm::iLiquefierArc,gdm::iTime) *
						(gdm::pLiquefierMaxPower(gdm::iLiquefierArc,gdm::iTime) 
						+ pMaxTheoreticalLiquefierPower(gdm::iLiquefierArc, gdm::iTime))
					
					Endif
				}
			}
			Constraint cCycle {
				IndexDomain: (gdm::iCycleArc, gdm::iTime);
				Definition: {
					
					vFlow(gdm::iCycleArc, gdm::iTime)>=0
				}
			}
			Constraint cBinaryLiquefier {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime)|gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced;
				Definition: {
					
					
					v01Liquefier(gdm::iLiquefierArc, gdm::iTime)
					+
					(1 - v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc), gdm::iTime))
					<= 
					1
				}
			}
			Constraint cSetPoutCompCycle {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime) | gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced and 
					                                   gdm::pLiquefierParameterValue(gdm::iLiquefierArc,gdm::epRatioCompressorCycle)
				}
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)), gdm::iTime)
					=
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc,gdm::epRatioCompressorCycle) *
					gom::vPressure(gdm::epNodeFrom(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)), gdm::iTime)
				}
				Comment: {
					"Calculate pressures and relate them to cycle load.
					If the pressure ratio parameter is not defined, the constraint is not generated and the discharge pressure must be set through  pressure control node"
				}
			}
			Constraint cSetPinCompressorCycle1 {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime) | gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced and 
					(gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam1) or 
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2) or 
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam3) or
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam4) )
				}
				Definition: {
					
					gom::vPressure(gdm::epNodeFrom(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) 
					>=
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam1) * gom::vFlow(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) + 
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2) * gom::vPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) +
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam3) * gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) * gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) + 
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam4) * gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) 
					-
					(max(0,gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2)) * gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc))) 
					)* (1-gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime))
				}
				Comment: {
					"!Last term of equation is to avoid infeasibility due to minimum pressure of the node when cycle compressor is off"
				}
			}
			Constraint cSetPinCompressorCycle2 {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime) | gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced and 
					(gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam1) or 
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2) or 
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam3) or
					 gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam4) )
				}
				Definition: {
					
					gom::vPressure(gdm::epNodeFrom(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) 
					<=
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam1) * gom::vFlow(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) + 
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2) * gom::vPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) +
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam3) * gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc)),gdm::iTime) * gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) + 
					gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam4) * gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime) 
					+ 
					( abs(min(0,gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epPinCompressorCycleParam2)))*gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc))) 
					 +  
					 gdm::pNodeMaxPressure(gdm::epNodeFrom(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc))) 
					) * (1-gom::v01Compressor(gdm::epLiquefierCompressorCycle(gdm::iLiquefierArc),gdm::iTime))
				}
				Comment: {
					"!Last term of equation is to avoid infeasibility due to minimum pressure of the node when cycle compressor is off"
				}
			}
			Variable v01LiquefierFlowPositiveRateChange {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit)
					and ( p01LiquefierDirectionFlow(gdm::iLiquefierArc, gdm::iTime) or 
					    ( gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable v01LiquefierFlowNegativeRateChange {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01LiquefierDirectionFlow(gdm::iLiquefierArc, gdm::iTime) or 
					    ( gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Constraint cLiquefierDirectionRateChange1 {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01LiquefierDirectionFlow(gdm::iLiquefierArc, gdm::iTime) or 
					    ( gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime)
					+
					v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime)
					<= 
					1
				}
			}
			Constraint cLiquefierDirectionRateChange2 {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01LiquefierDirectionFlow(gdm::iLiquefierArc, gdm::iTime) or 
					    ( gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iLiquefierArc, gdm::iTime) - gom::vFlow(gdm::iLiquefierArc, gdm::iTime-1)  
					>=
					(
						(gdm::pLiquefierMinPositiveRateChangeFlow(gdm::iLiquefierArc, gdm::iTime) + 1) * v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime)  
						- 
						gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime) * v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cLiquefierDirectionRateChange3 {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01LiquefierDirectionFlow(gdm::iLiquefierArc, gdm::iTime) or 
					    ( gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1) )
				}
				Definition: {
					
					vFlow(gdm::iLiquefierArc, gdm::iTime) - gom::vFlow(gdm::iLiquefierArc, gdm::iTime-1)  
					<= 
					(
						gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime) * v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime) 
						+ 
						(gdm::pLiquefierMinNegativeRateChangeFlow(gdm::iLiquefierArc, gdm::iTime) - 1) * v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cLiquefierMaxPositiveRateChange {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pLiquefierMaxPositiveRateChangeFlow(gdm::iLiquefierArc,gdm::iTime)
				}
				Definition: {
					
					vFlow(gdm::iLiquefierArc,gdm::iTime) 
					-
					vFlow(gdm::iLiquefierArc,gdm::iTime-1) 
					<= 
					(
						gdm::pLiquefierMaxPositiveRateChangeFlow(gdm::iLiquefierArc,gdm::iTime)  
						+
						gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime)*(1 - v01Liquefier(gdm::iLiquefierArc,gdm::iTime-1))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cLiquefierMaxNegativeRateChange {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and gdm::pLiquefierMaxNegativeRateChangeFlow(gdm::iLiquefierArc,gdm::iTime)
				}
				Definition: {
					
					vFlow(gdm::iLiquefierArc,gdm::iTime)
					-
					vFlow(gdm::iLiquefierArc,gdm::iTime-1) 
					>= 
					(
						gdm::pLiquefierMaxNegativeRateChangeFlow(gdm::iLiquefierArc,gdm::iTime) 
						-
						gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime)*(1 - v01Liquefier(gdm::iLiquefierArc,gdm::iTime))
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cLiquefierSteadyStateAfterRamp1 {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime) | (gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime),  
					v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime2) ) 
					<=
					(gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 1)  
					* 
					( (1 - v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime) )
					   +
					  (1 - v01Liquefier(gdm::iLiquefierArc, gdm::iTime))
					)
				}
			}
			Constraint cLiquefierSteadyStateAfterRamp2 {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime) | (gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1);
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime2) ) 
					<=
					(gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 1)  
					* 
					( (1 - v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime) )
					   +
					  (1 - v01Liquefier(gdm::iLiquefierArc, gdm::iTime))
					)
				}
			}
			Constraint cLiquefierMinStayTimeInSteadyState1 {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime),
					v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime2) ) 
					<=
					(gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 2)  
					* 
					( 1 + v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime)  
					    - v01LiquefierFlowPositiveRateChange(gdm::iLiquefierArc, gdm::iTime-1) 
					)
				}
			}
			Constraint cLiquefierMinStayTimeInSteadyState2 {
				IndexDomain: {
					(gdm::iLiquefierArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and (gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime2) ) 
					<=
					(gdm::pLiquefierMinStayTimeSteadyState(gdm::iLiquefierArc,gdm::iTime) - 2)  
					* 
					( 1 + v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime)  
					    - v01LiquefierFlowNegativeRateChange(gdm::iLiquefierArc, gdm::iTime-1) 
					)
				}
			}
			Parameter p01LiquefierDirectionFlow {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
				Range: binary;
				Definition: {
					
					gdm::pLiquefierMinPositiveRateChangeFlow(gdm::iLiquefierArc, gdm::iTime) <>0 
					OR
					gdm::pLiquefierMinNegativeRateChangeFlow(gdm::iLiquefierArc, gdm::iTime)<>0
				}
			}
		}
		DeclarationSection element_valve {
			Variable vDeltaPValve {
				IndexDomain: (gdm::iValveArc,gdm::iTime);
				Range: free;
			}
			Constraint cCalcDeltaP {
				IndexDomain: (gdm::iValveArc, gdm::iTime);
				Definition: {
					
					vDeltaPValve(gdm::iValveArc, gdm::iTime) =  vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime) - vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)
				}
			}
			Constraint cValveFlowDeltaP_1 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( not gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					vFlowPlus(gdm::iValveArc, gdm::iTime)*vDeltaPValve(gdm::iValveArc, gdm::iTime) >= -1.e-04
					
					! vFlow(gdm::iValveArc)*vDeltaPValve(gdm::iValveArc) >= 0
				}
				Comment: {
					"vFlow(dm::iValveArc)*vDeltaPValve(dm::iValveArc) >= 0
					
					(vFlowPlus(dm::iValveArc) - vFlowMinus(dm::iValveArc)) * vDeltaPValve(dm::iValveArc) >= -1e-8 + sqrt(1e-8) * (vFlowPlus(dm::iValveArc) - vFlowMinus(dm::iValveArc))"
				}
			}
			Constraint cValveFlowDeltaP_2 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( not gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					vFlowMinus(gdm::iValveArc, gdm::iTime)*vDeltaPValve(gdm::iValveArc, gdm::iTime) <= 1.e-04
				}
			}
			Constraint cSetValveSetpoint {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( not gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					if gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModePressureControl then
					
						vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime) =
						(vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime) + gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime)
						- sqrt(( vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime) - gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime) )^2 + 1.e-04) ) / 2
					
					elseif gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModeFlowControl then
					
						vFlow(gdm::iValveArc, gdm::iTime)
						=
						gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime)
					
					elseif gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModeOpenValve then
					
						vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)
						=
						vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime)
					else
						0=0
					endif
				}
				Comment: {
					"Thierry\'s previous equation:
					vPressure(dm::epNodeTo(dm::iValveArc))
					=
					min(	vPressure(dm::epNodeFrom(dm::iValveArc)),
						dm::pValveSetpoint(dm::iValveArc))"
				}
			}
			Constraint cCheckValve {
				IndexDomain: (gdm::iValveArc, gdm::iTime)|gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeCheckValve;
				Definition: {
					
					vFlow(gdm::iValveArc, gdm::iTime) >= 0
				}
			}
			Variable v01ValveOnOff {
				IndexDomain: (gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff;
				Range: binary;
			}
			Constraint cOnOffValve_Off1 {
				IndexDomain: (gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff;
				Definition: {
					gom::vFlow(gdm::iValveArc, gdm::iTime)
					<=
					gdm::pArcMaxFlow(gdm::iValveArc) * v01ValveOnOff(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cOnOffValve_Off2 {
				IndexDomain: (gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff;
				Definition: {
					gom::vFlow(gdm::iValveArc, gdm::iTime)
					>=
					gdm::pArcMinFlow(gdm::iValveArc) * v01ValveOnOff(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cOnOffValve_On1 {
				IndexDomain: (gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff;
				Definition: {
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)
					-
					gom::vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime)
					<=
					gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::iValveArc))
					*
					(1-v01ValveOnOff(gdm::iValveArc, gdm::iTime))
				}
			}
			Constraint cOnOffValve_On2 {
				IndexDomain: (gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff;
				Definition: {
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)
					-
					gom::vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime)
					>=
					-gdm::pNodeMaxPressure(gdm::epNodeFrom(gdm::iValveArc))
					*
					(1-v01ValveOnOff(gdm::iValveArc, gdm::iTime))
				}
			}
			Constraint cOnOffValve_SetPointMinFlow {
				IndexDomain: {
					(gdm::iValveArc,gdm::iTime) | gdm::epValveControlMode(gdm::iValveArc, gdm::iTime)=gdm::epValveControlModeOnOff
					and gdm::pValveSetPoint(gdm::iValveArc, gdm::iTime)<>0
				}
				Definition: {
					( gom::vFlowPlus(gdm::iValveArc, gdm::iTime) - gom::vFlowMinus(gdm::iValveArc, gdm::iTime) )
					>=
					gdm::pValveSetPoint(gdm::iValveArc, gdm::iTime) * v01ValveOnOff(gdm::iValveArc, gdm::iTime)
				}
			}
		}
		DeclarationSection element_pipe {
			Variable vPressureDropSlackPos {
				IndexDomain: (gdm::iPipeArc, gdm::iTime) | gdm::p01AllowSlackPressureDrop;
				Range: nonnegative;
			}
			Variable vPressureDropSlackNeg {
				IndexDomain: (gdm::iPipeArc, gdm::iTime) | gdm::p01AllowSlackPressureDrop;
				Range: nonnegative;
			}
			Variable vFrictionFactor {
				IndexDomain: (gdm::iPipeArc,gdm::iTime);
				Range: free;
			}
			Constraint cCalcPressureDrop {
				IndexDomain: (gdm::iPipeArc, gdm::iTime) | not gdm::p01PipePressureDropSpecificEquation( gdm::iPipeArc ) and not gdm::p01PipeLinearEquationModel( gdm::iPipeArc );
				Definition: {
					
					if gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeNoPressureDrop then
					
						! No pressure drop
						vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime) - vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime)
						= 
						vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					
					elseif gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeSimplified then
					
						! Simplified (linear) model
						vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime) - vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime)
						=
						(gdm::pPipeLinearPressureDropParam1(gdm::iPipeArc) + pEstimatedPipeLinearPressureDropParam1(gdm::iPipeArc)) * vFlow(gdm::iPipeArc, gdm::iTime) 
						+ 
						vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					
					elseif gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeAdvanceQuadratic then
					
						! Advanced quadratic model
						vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime)^2 - vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime)^2
						=
						gdm::pPipePressureDropParam1(gdm::iPipeArc) * (vFlowPlus(gdm::iPipeArc, gdm::iTime)^2 - vFlowMinus(gdm::iPipeArc, gdm::iTime)^2) 
						+ 
						vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					else
						! Advanced - friction factor
						vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime)^2 - vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime)^2
						=
						vFrictionFactor(gdm::iPipeArc,gdm::iTime) * gdm::pPipeEfficiency(gdm::iPipeArc) * gdm::pCompressibility(gdm::epPipeGasType(gdm::iPipeArc)) *
						gdm::pMolecularWeight(gdm::epPipeGasType(gdm::iPipeArc)) * gdm::pTambient * gdm::pPipeLength(gdm::iPipeArc) * 
						(vFlowPlus(gdm::iPipeArc, gdm::iTime)^2 - vFlowMinus(gdm::iPipeArc, gdm::iTime)^2)*(((gdm::pPreference/gdm::pTreference)/gdm::pHoursToSeconds)*gdm::pSIunitsToPressureUnits)^2 /
						(gdm::pPipeDiameter(gdm::iPipeArc) * gdm::pPipeCalculatedArea(gdm::iPipeArc)^2 * gdm::pRconstant)
						+ 
						vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					endif
				}
			}
			Constraint cCalcFrictionFactor {
				IndexDomain: (gdm::iPipeArc,gdm::iTime) | not gdm::p01PipeFrictionFactorSpecificCorrelation( gdm::iPipeArc ) and not gdm::p01PipeLinearEquationModel( gdm::iPipeArc );
				Definition: {
					
					if gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeAdvancedConstantFF then
					
						vFrictionFactor(gdm::iPipeArc,gdm::iTime) 
						=
						gdm::pPipeFrictionFactor(gdm::iPipeArc)
					
					elseif  gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeAdvancedCalculatedFF then 
					
						vFrictionFactor(gdm::iPipeArc,gdm::iTime) 
						=
						0.25 /[log10((gdm::pPipeRoughness(gdm::iPipeArc)/(3.7*gdm::pPipeDiameter(gdm::iPipeArc))) +
							(5.74/((vFlowPlus(gdm::iPipeArc, gdm::iTime) + vFlowMinus(gdm::iPipeArc, gdm::iTime) + 1e-4)*
							(((gdm::pPreference/gdm::pTreference)/gdm::pHoursToSeconds) * gdm::pMolecularWeight(gdm::epPipeGasType(gdm::iPipeArc))/gdm::pRconstant) * gdm::pPipeDiameter(gdm::iPipeArc)
							/(gdm::pPipeCalculatedArea(gdm::iPipeArc) * gdm::pViscosity(gdm::epPipeGasType(gdm::iPipeArc))))^0.9))]^2
					else
					  	0 = 0
					endif
				}
			}
			Parameter pEstimatedPipeLinearPressureDropParam1 {
				IndexDomain: {
					gdm::iPipeArc | 
					(gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeSimplified) 
					and (gdm::pPipeLinearPressureDropParam1(gdm::iPipeArc) = 0) 
					and gdm::pPipeDiameter(gdm::iPipeArc)
				}
				Default: 0;
				Definition: {
					
					! Estimation is done at average flow and pressure using variable bounds
					! For a more accurate calculation, user needs to provide an expected value for flow and pressure OR 
					! a procedure can be written to solve the problem without pressure drop just to calculate an expected value for flow and pressure
					
					pEstimatedPipeLinearPressureDropFrictionFactor(gdm::iPipeArc) *
					gdm::pPipeEfficiency(gdm::iPipeArc) * gdm::pCompressibility(gdm::epPipeGasType(gdm::iPipeArc)) * gdm::pMolecularWeight(gdm::epPipeGasType(gdm::iPipeArc)) * gdm::pTambient * gdm::pPipeLength(gdm::iPipeArc) * 
					((gdm::pArcMinFlow(gdm::iPipeArc) + gdm::pArcMaxFlow(gdm::iPipeArc))/$2) * (((gdm::pPreference /$ gdm::pTreference) /$ gdm::pHoursToSeconds)*gdm::pSIunitsToPressureUnits)^2 /$
					(gdm::pPipeDiameter(gdm::iPipeArc) * gdm::pPipeCalculatedArea(gdm::iPipeArc)^2 * gdm::pRconstant * (gdm::pNodeMinPressure(gdm::epNodeFrom(gdm::iPipeArc)) + gdm::pNodeMaxPressure(gdm::epNodeFrom(gdm::iPipeArc))) /$ 2)
				}
				Comment: {
					"gdm::iPipeArc | 
					(( gdm::epPipeCalcualtionMode(gdm::iPipeArc) = gdm::epPipeCalculationModeSimplified ) 
					or gdm::p01PipeLinearEquationModel(gdm::iPipeArc) ) 
					and ( gdm::pPipeLinearPressureDropParam1(gdm::iPipeArc) = 0 ) 
					and gdm::pPipeDiameter(gdm::iPipeArc)"
				}
			}
			Parameter pEstimatedPipeLinearPressureDropFrictionFactor {
				IndexDomain: {
					gdm::iPipeArc | (( gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeSimplified ) or gdm::p01PipeLinearEquationModel(gdm::iPipeArc) ) 
					and ( gdm::pPipeLinearPressureDropParam1(gdm::iPipeArc) = 0 )  and gdm::pPipeDiameter(gdm::iPipeArc)
				}
				Default: 0;
				Definition: {
					
					if gdm::pPipeFrictionFactor(gdm::iPipeArc)<>0 then
					
						gdm::pPipeFrictionFactor(gdm::iPipeArc)
					
					else
						0.25 /[log10((gdm::pPipeRoughness(gdm::iPipeArc)/(3.7*gdm::pPipeDiameter(gdm::iPipeArc))) +
							(5.74/((gdm::pArcMinFlow(gdm::iPipeArc) + gdm::pArcMaxFlow(gdm::iPipeArc))/2 *
							(((gdm::pPreference/gdm::pTreference)/gdm::pHoursToSeconds) * gdm::pMolecularWeight(gdm::epPipeGasType(gdm::iPipeArc))/gdm::pRconstant) * gdm::pPipeDiameter(gdm::iPipeArc)
							/(gdm::pPipeCalculatedArea(gdm::iPipeArc) * gdm::pViscosity(gdm::epPipeGasType(gdm::iPipeArc))))^0.9))]^2
					
					endif
				}
			}
		}
		DeclarationSection element_buffer {
			Variable vAccuBuffer {
				IndexDomain: (gdm::iBufferNode,gdm::iTime);
				Range: free;
			}
			Variable vBufferMinPressureSlack {
				IndexDomain: (gdm::iBufferNode,gdm::iTime) | gdm::p01AllowSlackReliefValveBuffer;
				Range: nonnegative;
			}
			Variable vBufferMaxPressureSlack {
				IndexDomain: (gdm::iBufferNode,gdm::iTime) | gdm::p01AllowSlackReliefValveBuffer;
				Range: nonnegative;
			}
			Constraint cAccumulationBuffer {
				IndexDomain: (gdm::iBufferNode,gdm::iTime);
				Definition: {
					
					vAccuBuffer(gdm::iBufferNode,gdm::iTime)
					=
					gom::vPressure(gdm::iBufferNode, gdm::iTime) * (gdm::pBufferVolume(gdm::iBufferNode)*(gdm::pTreference/gdm::pTambient)/(gdm::pPreference*gdm::pSIunitsToPressureUnits))!/gdm::pPeriodInHours
				}
			}
			Constraint cMassBalanceBuffer {
				IndexDomain: (gdm::iBufferNode,gdm::iTime);
				Definition: {
					
					
					vAccuBuffer(gdm::iBufferNode,gdm::iTime) =
						if ( gdm::iTime <> gdm::epFirstTimeUnit ) then
								vAccuBuffer(gdm::iBufferNode,gdm::iTime-1) 
						else
								gdm::pBufferInitialAccu(gdm::iBufferNode) 
						endif
							     + (!Flow on the arcs leaving the node
								-sum( gdm::iArc, p01MapFlowFrom( gdm::iBufferNode, gdm::iArc ) * vFlow(gdm::iArc,gdm::iTime))
								!Flow on the arcs entering the node
								+ sum( gdm::iArc, p01MapFlowTo( gdm::iBufferNode, gdm::iArc ) * vFlow(gdm::iArc,gdm::iTime))
								+ vInputFlow( gdm::iBufferNode, gdm::iTime )
								- vOutputFlow( gdm::iBufferNode, gdm::iTime )
								)*gdm::pPeriodInHours
				}
			}
			Constraint cMinPressureBuffer {
				IndexDomain: (gdm::iBufferNode,gdm::iTime);
				Definition: {
					
					vPressure( gdm::iBufferNode, gdm::iTime ) 
					>=
					gdm::pBufferMinPressure(gdm::iBufferNode, gdm::iTime)
					-
					vBufferMinPressureSlack(gdm::iBufferNode, gdm::iTime)
				}
			}
			Constraint cMaxPressureBuffer {
				IndexDomain: (gdm::iBufferNode,gdm::iTime);
				Definition: {
					
					vPressure( gdm::iBufferNode, gdm::iTime ) 
					<= 
					gdm::pBufferMaxPressure(gdm::iBufferNode, gdm::iTime)
					+
					vBufferMaxPressureSlack(gdm::iBufferNode, gdm::iTime)
				}
			}
		}
		DeclarationSection element_output_flow_node {
			Variable vOutputFlowVariable {
				IndexDomain: (gdm::iOutputFlowNode,gdm::iTime) | not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime);
				Range: nonnegative;
			}
			Constraint cOutputFlowVariableMax {
				IndexDomain: (gdm::iOutputFlowNode, gdm::iTime) | not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime);
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime) 
					<=
					gdm::pOutputFlowNodeMaxFlow(gdm::iOutputFlowNode, gdm::iTime)
				}
			}
			Constraint cOutputFlowVariableMin {
				IndexDomain: (gdm::iOutputFlowNode, gdm::iTime) | not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime);
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime)  
					>=
					gdm::pOutputFlowNodeMinFlow(gdm::iOutputFlowNode, gdm::iTime)
				}
			}
			Variable v01OutputFlowNodePositiveRateChange {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit)
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and ( p01OutputFlowNodeDirection(gdm::iOutputFlowNode, gdm::iTime) or 
					    ( gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable v01OutputFlowNodeNegativeRateChange {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and ( p01OutputFlowNodeDirection(gdm::iOutputFlowNode, gdm::iTime) or 
					    ( gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Constraint cOutputFlowNodeDirectionRateChange1 {
				IndexDomain: {
					(gdm::iOutputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and ( p01OutputFlowNodeDirection(gdm::iOutputFlowNode, gdm::iTime) or 
					    ( gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1) )
				}
				Definition: {
					
					v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime)
					+
					v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime)
					<= 
					1
				}
			}
			Constraint cOutputFlowNodeDirectionRateChange2 {
				IndexDomain: {
					(gdm::iOutputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and ( p01OutputFlowNodeDirection(gdm::iOutputFlowNode, gdm::iTime) or 
					    ( gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode, gdm::iTime) > 1) )
				}
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime) - gom::vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime-1)  
					>=
					(
						( gdm::pOutputFlowNodeMinPositiveRateChangeFlow(gdm::iOutputFlowNode, gdm::iTime) + 1 ) * v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime)  
						- 
						gdm::pOutputFlowNodeMaxFlow(gdm::iOutputFlowNode, gdm::iTime) * v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cOutputFlowNodeDirectionRateChange3 {
				IndexDomain: {
					(gdm::iOutputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and ( p01OutputFlowNodeDirection(gdm::iOutputFlowNode, gdm::iTime) or 
					    ( gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode, gdm::iTime) > 1) )
				}
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime) - vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime-1)  
					<= 
					(
						gdm::pOutputFlowNodeMaxFlow(gdm::iOutputFlowNode, gdm::iTime) * v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime) 
						+ 
						(gdm::pOutputFlowNodeMinNegativeRateChangeFlow(gdm::iOutputFlowNode, gdm::iTime) - 1) * v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cOutputFlowNodeMaxPositiveRateChange {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and gdm::pOutputFlowNodeMaxPositiveRateChangeFlow(gdm::iOutputFlowNode,gdm::iTime)
				}
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime) 
					-
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime-1)
					<= 
					(
						gdm::pOutputFlowNodeMaxPositiveRateChangeFlow(gdm::iOutputFlowNode,gdm::iTime)  
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cOutputFlowNodeMaxNegativeRateChange {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and gdm::pOutputFlowNodeMaxNegativeRateChangeFlow(gdm::iOutputFlowNode,gdm::iTime)
				}
				Definition: {
					
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime) 
					-
					vOutputFlowVariable(gdm::iOutputFlowNode, gdm::iTime-1)
					>= 
					(
						gdm::pOutputFlowNodeMaxNegativeRateChangeFlow(gdm::iOutputFlowNode,gdm::iTime) 
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cOutputFlowNodeSteadyStateAfterRamp1 {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime) | (gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1)
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
				}
				Definition: {
					
					sum(gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) 
							  and ord(gdm::iTime2) > ord(gdm::iTime),  
					v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 1)  
					* 
					(1 - v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime))
				}
			}
			Constraint cOutputFlowNodeSteadyStateAfterRamp2 {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime) | (gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1)
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
				}
				Definition: {
					
					sum( gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) 
							   and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 1)  * 
					( 1 - v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime) )
				}
			}
			Constraint cOutputFlowNodeMinStayTimeInSteadyState1 {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and (gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 1) 
							    and ord(gdm::iTime2) > ord(gdm::iTime),
					v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 2)  
					* 
					( 1 + v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime)  
					    - v01OutputFlowNodePositiveRateChange(gdm::iOutputFlowNode, gdm::iTime-1) 
					)
				}
			}
			Constraint cOutputFlowNodeMinStayTimeInSteadyState2 {
				IndexDomain: {
					(gdm::iOutputFlowNode,gdm::iTime) |(gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( not gdm::pOutputFlowFixed(gdm::iOutputFlowNode, gdm::iTime) )
					and  (gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 1) 
							    and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pOutputFlowNodeMinStayTimeSteadyState(gdm::iOutputFlowNode,gdm::iTime) - 2)  
					* 
					( 1 + v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime)  
					    - v01OutputFlowNodeNegativeRateChange(gdm::iOutputFlowNode, gdm::iTime-1) 
					)
				}
			}
			Parameter p01OutputFlowNodeDirection {
				IndexDomain: (gdm::iOutputFlowNode,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
				Range: binary;
				Definition: {
					
					gdm::pOutputFlowNodeMinPositiveRateChangeFlow(gdm::iOutputFlowNode, gdm::iTime) <>0 
					OR
					gdm::pOutputFlowNodeMinNegativeRateChangeFlow(gdm::iOutputFlowNode, gdm::iTime) <>0
				}
			}
		}
		DeclarationSection element_input_flow_node {
			Constraint cInputFlowNodeVariableMax {
				IndexDomain: {
					(gdm::iInputFlowNode, gdm::iTime)
					| not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime)
				}
				Definition: {
					vInputFlowVariable(gdm::iInputFlowNode, gdm::iTime) 
					<= 
					gdm::pInputFlowNodeMaxFlow(gdm::iInputFlowNode, gdm::iTime);
					
					/*
					Old:
					vInputFlow(gdm::iInputFlowNode, gdm::iTime) 
					<=
					gdm::pInputFlowNodeMaxFlow(gdm::iInputFlowNode, gdm::iTime)
					*/
				}
			}
			Constraint cInputFlowNodeVariableMin {
				IndexDomain: {
					(gdm::iInputFlowNode, gdm::iTime)
					| not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime)
				}
				Definition: {
					vInputFlowVariable(gdm::iInputFlowNode, gdm::iTime) 
					>= 
					gdm::pInputFlowNodeMinFlow(gdm::iInputFlowNode, gdm::iTime);
					
					/*
					Old:
					vInputFlow(gdm::iInputFlowNode, gdm::iTime)  
					>=
					gdm::pInputFlowNodeMinFlow(gdm::iInputFlowNode, gdm::iTime)
					*/
				}
			}
			Variable v01InputFlowNodePositiveRateChange {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit)
					and ( p01InputFlowNodeDirection(gdm::iInputFlowNode, gdm::iTime) or 
					    ( gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable v01InputFlowNodeNegativeRateChange {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01InputFlowNodeDirection(gdm::iInputFlowNode, gdm::iTime) or 
					    ( gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1) )
				}
				Range: binary;
			}
			Variable vInputFlowVariable {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime)
					| not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime)
				}
				Range: nonnegative;
			}
			Constraint cInputFlowNodeDirectionRateChange1 {
				IndexDomain: {
					(gdm::iInputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01InputFlowNodeDirection(gdm::iInputFlowNode, gdm::iTime) or 
					    ( gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1) )
				}
				Definition: {
					
					v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime)
					+
					v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime)
					<= 
					1
				}
			}
			Constraint cInputFlowNodeDirectionRateChange2 {
				IndexDomain: {
					(gdm::iInputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01InputFlowNodeDirection(gdm::iInputFlowNode, gdm::iTime) or 
					    ( gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1) )
				}
				Definition: {
					
					vInputFlow(gdm::iInputFlowNode, gdm::iTime) - gom::vInputFlow(gdm::iInputFlowNode, gdm::iTime-1)  
					>=
					(
						(gdm::pInputFlowNodeMinPositiveRateChangeFlow(gdm::iInputFlowNode, gdm::iTime) + 1) * v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime)  
						- 
						gdm::pInputFlowNodeMaxFlow(gdm::iInputFlowNode, gdm::iTime) * v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cInputFlowNodeDirectionRateChange3 {
				IndexDomain: {
					(gdm::iInputFlowNode, gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) 
					and ( p01InputFlowNodeDirection(gdm::iInputFlowNode, gdm::iTime) or 
					    ( gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1) )
				}
				Definition: {
					
					vInputFlow(gdm::iInputFlowNode, gdm::iTime) - vInputFlow(gdm::iInputFlowNode, gdm::iTime-1)  
					<= 
					(
						gdm::pInputFlowNodeMaxFlow(gdm::iInputFlowNode, gdm::iTime) * v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime) 
						+ 
						(gdm::pInputFlowNodeMinNegativeRateChangeFlow(gdm::iInputFlowNode, gdm::iTime) - 1) * v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime)
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cInputFlowNodeMaxPositiveRateChange {
				IndexDomain: (gdm::iInputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) and gdm::pInputFlowNodeMaxPositiveRateChangeFlow(gdm::iInputFlowNode,gdm::iTime);
				Definition: {
					
					vInputFlow(gdm::iInputFlowNode, gdm::iTime) 
					-
					vInputFlow(gdm::iInputFlowNode, gdm::iTime-1)
					<= 
					(
						gdm::pInputFlowNodeMaxPositiveRateChangeFlow(gdm::iInputFlowNode,gdm::iTime)  
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cInputFlowNodeMaxNegativeRateChange {
				IndexDomain: (gdm::iInputFlowNode,gdm::iTime)| (gdm::iTime <> gdm::epFirstTimeUnit) and gdm::pInputFlowNodeMaxNegativeRateChangeFlow(gdm::iInputFlowNode,gdm::iTime);
				Definition: {
					
					vInputFlow(gdm::iInputFlowNode, gdm::iTime) 
					-
					vInputFlow(gdm::iInputFlowNode, gdm::iTime-1)
					>= 
					(
						gdm::pInputFlowNodeMaxNegativeRateChangeFlow(gdm::iInputFlowNode,gdm::iTime) 
					
					) * gdm::pPeriodInHours
				}
			}
			Constraint cInputFlowNodeSteadyStateAfterRamp1 {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime) | (gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1)
					and ( not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime) )
				}
				Definition: {
					
					sum(gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) 
							  and ord(gdm::iTime2) > ord(gdm::iTime),  
					v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 1)  
					* 
					( 1 - v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime))
				}
			}
			Constraint cInputFlowNodeSteadyStateAfterRamp2 {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime) | (gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1)
					and ( not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime) )
				}
				Definition: {
					
					sum(gdm::iTime2 | ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) 
							  and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 1)  
					* 
					( 1 - v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime) )
				}
			}
			Constraint cInputFlowNodeMinStayTimeInSteadyState1 {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit)
					and ( not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime) ) 
					and (gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime),
					v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 2)  
					* 
					( 1 + v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime)  
					    - v01InputFlowNodePositiveRateChange(gdm::iInputFlowNode, gdm::iTime-1) 
					)
				}
			}
			Constraint cInputFlowNodeMinStayTimeInSteadyState2 {
				IndexDomain: {
					(gdm::iInputFlowNode,gdm::iTime) |(gdm::iTime <> gdm::epFirstTimeUnit)
					and ( not gdm::pInputFlowNodeFixed(gdm::iInputFlowNode, gdm::iTime) )
					and  (gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) > 1)
				}
				Definition: {
					
					sum( gdm::iTime2 | ( ord(gdm::iTime2) < ord(gdm::iTime) + gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 1) 
							     and ord(gdm::iTime2) > ord(gdm::iTime), 
					v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime2) ) 
					<=
					(gdm::pInputFlowNodeMinStayTimeSteadyState(gdm::iInputFlowNode,gdm::iTime) - 2)  
					* 
					( 1 + v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime)  
					    - v01InputFlowNodeNegativeRateChange(gdm::iInputFlowNode, gdm::iTime-1) 
					)
				}
			}
			Parameter p01InputFlowNodeDirection {
				IndexDomain: (gdm::iInputFlowNode,gdm::iTime) | (gdm::iTime <> gdm::epFirstTimeUnit);
				Range: binary;
				Definition: {
					
					gdm::pInputFlowNodeMinPositiveRateChangeFlow(gdm::iInputFlowNode, gdm::iTime) <>0 
					OR
					gdm::pInputFlowNodeMinNegativeRateChangeFlow(gdm::iInputFlowNode, gdm::iTime)<>0
				}
			}
		}
		DeclarationSection element_auxiliary_power {
			Variable vAuxPower {
				IndexDomain: (gdm::iAuxPowerGroup,gdm::iTime);
				Range: free;
				Definition: {
					
					gdm::pAuxPowerGroupParam1(gdm::iAuxPowerGroup)  *
					(
					sum( gdm::iCompressorArc | gdm::epCompressorAuxPowerGroup(gdm::iCompressorArc) = gdm::iAuxPowerGroup , vCompressorPower(gdm::iCompressorArc, gdm::iTime) + sum(gdm::iOperatingMode, vCompressorExtraPower(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime)))  +
					sum( gdm::iLiquefierArc  | gdm::epLiquefierAuxPowerGroup(gdm::iLiquefierArc) = gdm::iAuxPowerGroup, vLiquefierPower(gdm::iLiquefierArc, gdm::iTime) + sum(gdm::iOperatingMode, vLiquefierExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime))) +
					sum( gdm::iBox       | gdm::epBoxAuxPowerGroup( gdm::iBox ) = gdm::iAuxPowerGroup, sum( gdm::iOperatingMode, vBoxExtraPower(gdm::iBox,gdm::iOperatingMode,gdm::iTime) ))
					)
					+ gdm::pAuxPowerGroupParam2(gdm::iAuxPowerGroup)
				}
			}
		}
		DeclarationSection operating_modes {
			Set sStayTime {
				Index: iStayTime;
				Definition: {
					if card(gdm::iOperatingMode) > 0 and max((gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2),gdm::pOperatingModeMinStayTime(gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2)) > 0 then
					elementrange(
					  1, 
					  max((gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2),gdm::pOperatingModeMinStayTime(gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2)),
					  prefix: "stay")
					endif
				}
			}
			Variable v01ElementInOperatingMode {
				IndexDomain: (gdm::iOperatingModeElement,gdm::iOperatingMode,gdm::iTime)| gdm::p01OperatingModeAllowed(gdm::iOperatingModeElement,gdm::iOperatingMode,gdm::iTime);
				Range: binary;
			}
			Variable v01ElementSwitchOperatingMode {
				IndexDomain: {
					(gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2,gdm::iTime)|
					gdm::p01OperatingModeTransitionAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2) and
					ord(gdm::iTime) > gdm::pOperatingModeInitialMinTimeRemain(gdm::iOperatingModeElement)
				}
				Range: binary;
			}
			Variable vCompressorExtraPower {
				IndexDomain: (gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime) | gdm::pOperatingModeExtraPower(gdm::iCompressorArc,gdm::iOperatingMode);
				Range: nonnegative;
				Default: 0;
				Definition: {
					
					v01ElementInOperatingMode(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime)*gdm::pOperatingModeExtraPower(gdm::iCompressorArc,gdm::iOperatingMode)
				}
			}
			Variable vLiquefierExtraPower {
				IndexDomain: (gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime)|gdm::pOperatingModeExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode);
				Range: nonnegative;
				Definition: {
					
					v01ElementInOperatingMode(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime)*gdm::pOperatingModeExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode)
				}
			}
			Variable vBackupExtraPower {
				IndexDomain: (gdm::iBackupArc,gdm::iOperatingMode,gdm::iTime) | gdm::pOperatingModeExtraPower(gdm::iBackupArc,gdm::iOperatingMode);
				Range: nonnegative;
				Definition: {
					
					v01ElementInOperatingMode(gdm::iBackupArc,gdm::iOperatingMode,gdm::iTime)*gdm::pOperatingModeExtraPower(gdm::iBackupArc,gdm::iOperatingMode)
				}
			}
			Variable vBoxExtraPower {
				IndexDomain: (gdm::iBox,gdm::iOperatingMode,gdm::iTime)|gdm::pOperatingModeExtraPower(gdm::iBox,gdm::iOperatingMode);
				Range: nonnegative;
				Definition: {
					
					gom::v01ElementInOperatingMode(gdm::iBox,gdm::iOperatingMode,gdm::iTime)*gdm::pOperatingModeExtraPower(gdm::iBox,gdm::iOperatingMode)
				}
			}
			Constraint cOnlyOneActiveMode {
				IndexDomain: (gdm::iOperatingModeElement,gdm::iTime);
				Definition: {
					sum(gdm::iOperatingMode|gdm::p01OperatingModeAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode,gdm::iTime),
					  v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iTime))
					=
					1
				}
			}
			Constraint cSwitch {
				IndexDomain: (gdm::iOperatingModeElement,gdm::iOperatingMode,gdm::iTime);
				Definition: {
					
					
					
					
					sum(gdm::iOperatingMode2|gdm::p01OperatingModeTransitionAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode2, gdm::iOperatingMode),
					  	v01ElementSwitchOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode2, gdm::iOperatingMode, gdm::iTime))
					-   	
					sum(gdm::iOperatingMode2|gdm::p01OperatingModeTransitionAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iOperatingMode2),
					  	v01ElementSwitchOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iOperatingMode2, gdm::iTime))
					=
					v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iTime)
					  -
					if gdm::iTime <> gdm::epFirstTimeUnit then
					  v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iTime-1)
					else 
					  gdm::iOperatingMode = gdm::epOperatingModeInitialMode(gdm::iOperatingModeElement)
					endif
				}
			}
			Constraint cOnlyOneSwitch {
				IndexDomain: (gdm::iOperatingModeElement,gdm::iTime);
				Definition: {
					sum((gdm::iOperatingMode1,gdm::iOperatingMode2),
					v01ElementSwitchOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2, gdm::iTime)) <= 1
				}
			}
			Constraint cMinStayTime {
				IndexDomain: {
					(gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2,gdm::iTime)|
					gdm::p01OperatingModeTransitionAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2) and
					ord(gdm::iTime) > gdm::pOperatingModeInitialMinTimeRemain(gdm::iOperatingModeElement) and
					gdm::pOperatingModeMinStayTime(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2)
				}
				Definition: {
					sum(iStayTime|
						ord(iStayTime) <=
						min(
							gdm::pOperatingModeMinStayTime(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2),
							ord(gdm::iTime)-gdm::pOperatingModeInitialMinTimeRemain(gdm::iOperatingModeElement)
						),
						v01ElementSwitchOperatingMode(
							gdm::iOperatingModeElement, 
							gdm::iOperatingMode1, 
							gdm::iOperatingMode2, 
							gdm::iTime-ord(iStayTime)+1)
					)
					
					<= 
					
					v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode2, gdm::iTime)
				}
			}
			Constraint cMaxStayTime {
				IndexDomain: {
					(gdm::iOperatingModeElement,gdm::iOperatingMode1,gdm::iOperatingMode2,gdm::iTime)|
					gdm::p01OperatingModeTransitionAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2) and
					gdm::pOperatingModeMaxStayTime(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2)
				}
				Definition: {
					
					if ord(gdm::iTime) > gdm::pOperatingModeMaxStayTime(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2) then
						v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode2, gdm::iTime)
						<=
						1 - 
						v01ElementSwitchOperatingMode(gdm::iOperatingModeElement,
									      gdm::iOperatingMode1,
									      gdm::iOperatingMode2,
									      gdm::iTime - gdm::pOperatingModeMaxStayTime(gdm::iOperatingModeElement, gdm::iOperatingMode1, gdm::iOperatingMode2)
								      	     )
					else
						v01ElementInOperatingMode(gdm::iOperatingModeElement, gdm::iOperatingMode2, Element(gdm::calHorizon,gdm::pOperatingModeInitialMaxTimeRemain(gdm::iOperatingModeElement)+1))
						<= 0
					
					endif;
				}
			}
			Constraint cForceOperatingModeCompressor {
				IndexDomain: {
					(gdm::iCompressorArc, gdm::iOperatingMode, gdm::iTime) | 
					gdm::iCompressorArc in gdm::sOperatingModeElements 
					and 
					gdm::p01OperatingModeForced(gdm::iCompressorArc, gdm::iOperatingMode, gdm::iTime)
				}
				Definition: {
					
					
					v01ElementInOperatingMode(gdm::iCompressorArc, gdm::iOperatingMode, gdm::iTime) = 1
				}
			}
			Constraint cForceOperatingModeBackup {
				IndexDomain: {
					(gdm::iBackupArc, gdm::iOperatingMode, gdm::iTime) | 
					gdm::iBackupArc in gdm::sOperatingModeElements 
					and 
					gdm::p01OperatingModeForced(gdm::iBackupArc, gdm::iOperatingMode, gdm::iTime)
				}
				Definition: {
					
					
					v01ElementInOperatingMode(gdm::iBackupArc, gdm::iOperatingMode, gdm::iTime) = 1
				}
			}
			Constraint cForceOperatingModeLiquefier {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iOperatingMode, gdm::iTime) | 
					gdm::iLiquefierArc in gdm::sOperatingModeElements
					and 
					gdm::p01OperatingModeForced(gdm::iLiquefierArc, gdm::iOperatingMode, gdm::iTime)
				}
				Definition: {
					
					v01ElementInOperatingMode(gdm::iLiquefierArc, gdm::iOperatingMode, gdm::iTime) = 1
				}
			}
			Constraint cForceOperatingModebox {
				IndexDomain: {
					(gdm::iBox,gdm::iOperatingMode, gdm::iTime)| 
					gdm::iBox in gdm::sOperatingModeElements
					and 
					gdm::p01OperatingModeForced(gdm::iBox, gdm::iOperatingMode, gdm::iTime)
				}
				Definition: {
					
					
					gom::v01ElementInOperatingMode(gdm::iBox, gdm::iOperatingMode, gdm::iTime) = 1
				}
			}
			Constraint cLinkToCompressor {
				IndexDomain: (gdm::iCompressorArc,gdm::iTime) | gdm::iCompressorArc in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iCompressorArc);
				Definition: {
					
					! If Compressor is in OperatingMode On or Start, vFlow >= 0, otherwise vFlow = 0
					v01ElementInOperatingMode(gdm::iCompressorArc,gdm::epOperatingModeTypeOn,gdm::iTime)
					+
					v01ElementInOperatingMode(gdm::iCompressorArc,gdm::epOperatingModeTypeStart,gdm::iTime)
					= 
					v01Compressor(gdm::iCompressorArc, gdm::iTime)
				}
			}
			Constraint cLinkToBackup {
				IndexDomain: (gdm::iBackupArc,gdm::iTime) | gdm::iBackupArc in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iBackupArc);
				Definition: {
					
					
					! If Backup is in OperatingMode On, Cool-down, start, vFlow >= 0, otherwise vFlow = 0
					
					v01ElementInOperatingMode(gdm::iBackupArc,gdm::epOperatingModeTypeOn,gdm::iTime) + 
					v01ElementInOperatingMode(gdm::iBackupArc,gdm::epOperatingModeTypeStart,gdm::iTime) 
					= 
					v01Backup(gdm::iBackupArc,gdm::iTime)
				}
			}
			Constraint cLinkToLiquefier {
				IndexDomain: (gdm::iLiquefierArc,gdm::iTime) | gdm::iLiquefierArc in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iLiquefierArc);
				Definition: {
					! If Liquefier is in OperatingMode On or Start, vFlow >= 0, otherwise vFlow = 0
					v01ElementInOperatingMode(gdm::iLiquefierArc, gdm::epOperatingModeTypeOn, gdm::iTime)
					+ v01ElementInOperatingMode(gdm::iLiquefierArc, gdm::epOperatingModeTypeStart, gdm::iTime)
					!+ v01ElementInOperatingMode(gdm::iLiquefierArc, gdm::epOperatingModeTypeCoolDown, gdm::iTime)      (1)
					= 
					v01Liquefier(gdm::iLiquefierArc, gdm::iTime)
				}
				Comment: "(1) EL 13/01/2022 (v3) : Decide with TR to come back to the solution of the v222c about this modification \"cooldown for liquefire\" it was a bad idea.";
			}
			Constraint cLinkToColdbox {
				IndexDomain: (gdm::iColdbox,gdm::iTime) | gdm::iColdbox in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iColdbox);
				Definition: {
					
					! If Coldbox is in OperatingMode On, Start, Cool-Down, or Argon-Start, vFlow >= 0, otherwise vFlow = 0
					v01ElementInOperatingMode(gdm::iColdbox, gdm::epOperatingModeTypeOn, gdm::iTime)
					+
					v01ElementInOperatingMode(gdm::iColdbox, gdm::epOperatingModeTypeStart, gdm::iTime)
					+
					v01ElementInOperatingMode(gdm::iColdbox, gdm::epOperatingModeTypeCoolDown, gdm::iTime)
					+
					v01ElementInOperatingMode(gdm::iColdbox, gdm::epOperatingModeTypeArgonStart, gdm::iTime)
					= 
					v01Box(gdm::iColdbox, gdm::iTime)
				}
			}
			Constraint cVentingOperatingModeColdbox {
				IndexDomain: (gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)| gdm::iColdbox in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iColdbox);
				Definition: {
					
					! If Coldbox in COOL-DOWN operating mode --> Vent all products 
					! If Colbox in ARGON-START operating mode --> Vent only LAR
					
					if gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGOx then
						vHpGox(gdm::iColdbox, gdm::iTime)-vHpGoxVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGOx then
						vMpGox(gdm::iColdbox, gdm::iTime)-vMpGoxVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGOx then
						vLpGox(gdm::iColdbox, gdm::iTime)-vLpGoxVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeHpGAn then
						vHpGAn(gdm::iColdbox, gdm::iTime)-vHpGAnVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeMpGAn then
						vMpGAn(gdm::iColdbox, gdm::iTime)-vMpGAnVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLpGAn then
						vLpGAn(gdm::iColdbox, gdm::iTime)-vLpGAnVent(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLiN then
						vLiN(gdm::iColdbox, gdm::iTime)-vLiNpurge(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLOx then
						vLOx(gdm::iColdbox, gdm::iTime)-vLOxpurge(gdm::iColdbox, gdm::iTime)<=gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)*(1-v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime))
					
					elseif gdm::iBoxNodeConnectionType=gdm::epColdboxNodeConnectionTypeLAr then
						vLAr(gdm::iColdbox, gdm::iTime)-vLArpurge(gdm::iColdbox, gdm::iTime)
						<=
						gdm::pBoxMaxFlow(gdm::iColdbox,gdm::iBoxNodeConnectionType, gdm::iTime)
						*(1- (v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeCoolDown, gdm::iTime) + v01ElementInOperatingMode(gdm::iColdBox, gdm::epOperatingModeTypeArgonStart, gdm::iTime)))
					else
						0<=0
					endif
				}
			}
			Variable vFlashBackupCoolDown {
				IndexDomain: (gdm::iBackupArc,gdm::iTime)| gdm::iBackupArc in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iBackupArc);
				Range: nonnegative;
			}
			Constraint cBackupCoolDown {
				IndexDomain: (gdm::iBackupArc,gdm::iTime)| gdm::iBackupArc in gdm::sOperatingModeElements and not gdm::p01OperatingModeUseSpecificDescription(gdm::iBackupArc);
				Definition: {
					
					vFlashBackupCoolDown(gdm::iBackupArc, gdm::iTime)
					=
					gdm::pBackupPcFlash(gdm::iBackupArc,gdm::iTime) * gdm::pBackupMaxFlow(gdm::iBackupArc,gdm::iTime) * v01ElementInOperatingMode(gdm::iBackupArc, gdm::epOperatingModeTypeCoolDown, gdm::iTime)
				}
			}
			Constraint cLiquefierCoolDown_disable {
				IndexDomain: {
					(gdm::iLiquefierArc, gdm::iTime) | 
					(gdm::iLiquefierArc in gdm::sOperatingModeElements 
					and not gdm::p01OperatingModeUseSpecificDescription(gdm::iLiquefierArc))
					and 0
				}
				Definition: {
					vOutputFlow(gdm::epNodeTo(gdm::iLiquefierArc), gdm::iTime) 
					>= 
					vFlow(gdm::iLiquefierArc, gdm::iTime) 
					-  
					(1 - v01ElementInOperatingMode(gdm::iLiquefierArc, gdm::epOperatingModeTypeCoolDown, gdm::iTime)) 
					* 
					gdm::pLiquefierMaxFlow(gdm::iLiquefierArc, gdm::iTime)
				}
				Comment: "EL 13/01/2022 (v3) : Decide with TR to come back to the solution of the v222c about this modification \"cooldown for liquefire\" it was a bad idea.";
			}
		}
		DeclarationSection status_modes {
			Constraint cForceCompressorStatus {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | gdm::epControlModeElement(gdm::iCompressorArc) = gdm::epStatusMode;
				Definition: {
					
					if gdm::epStatusElement(gdm::iCompressorArc, gdm::iTime) = gdm::epStatusModeRun then
					 	v01Compressor(gdm::iCompressorArc, gdm::iTime) = 1
					elseif gdm::epStatusElement(gdm::iCompressorArc, gdm::iTime) = gdm::epStatusModeUAVL then
					 	v01Compressor(gdm::iCompressorArc, gdm::iTime) = 0
					else
						0=0
					endif
				}
			}
			Constraint cForceBackupStatus {
				IndexDomain: (gdm::iBackupArc, gdm::iTime)| gdm::epControlModeElement(gdm::iBackupArc) = gdm::epStatusMode;
				Definition: {
					
					if gdm::epStatusElement(gdm::iBackupArc, gdm::iTime) = gdm::epStatusModeRun then
						v01Backup(gdm::iBackupArc,gdm::iTime) = 1
					elseif gdm::epStatusElement(gdm::iBackupArc, gdm::iTime) = gdm::epStatusModeUAVL then
						v01Backup(gdm::iBackupArc,gdm::iTime) = 0
					else
						0=0
					endif;
				}
			}
			Constraint cForceLiquefierStatus {
				IndexDomain: (gdm::iLiquefierArc, gdm::iTime)| gdm::epControlModeElement(gdm::iLiquefierArc) = gdm::epStatusMode;
				Definition: {
					
					if gdm::epStatusElement(gdm::iLiquefierArc, gdm::iTime) = gdm::epStatusModeRun then
						v01Liquefier(gdm::iLiquefierArc, gdm::iTime) = 1
					elseif gdm::epStatusElement(gdm::iLiquefierArc, gdm::iTime) = gdm::epStatusModeUAVL then
						v01Liquefier(gdm::iLiquefierArc, gdm::iTime) = 0
					else
						0=0
					endif;
				}
			}
			Constraint cForceboxStatus {
				IndexDomain: (gdm::iBox, gdm::iTime)| gdm::epControlModeElement(gdm::iBox) = gdm::epStatusMode;
				Definition: {
					
					if gdm::epStatusElement(gdm::iBox,gdm::iTime)= gdm::epStatusModeRun then
						v01box(gdm::iBox, gdm::iTime) = 1
					elseif gdm::epStatusElement(gdm::iBox,gdm::iTime)= gdm::epStatusModeUAVL then
						v01box(gdm::iBox, gdm::iTime) = 0
					else
						0=0
					endif;
				}
			}
		}
		DeclarationSection objective_function {
			Variable vObjectiveCost {
				Text: "Objective value";
				Range: free;
				Definition: {
					! total cost (compressors + liquid assist)+ liquid credit at production cost
					( sum( ( gdm::iEnergyContract, gdm::iTime ),
						( sum( ( gdm::iCompressorArc ) | gdm::epCompressorEnergyContract( gdm::iCompressorArc ) = gdm::iEnergyContract, vCompressorPower( gdm::iCompressorArc, gdm::iTime ) + sum(gdm::iOperatingMode, vCompressorExtraPower(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iLiquefierArc )  | gdm::epLiquefierEnergyContract( gdm::iLiquefierArc ) = gdm::iEnergyContract,   vLiquefierPower( gdm::iLiquefierArc, gdm::iTime )   +  sum(gdm::iOperatingMode, vLiquefierExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iBox )       | gdm::epBoxEnergyContract( gdm::iBox ) = gdm::iEnergyContract, vboxPower(gdm::iBox, gdm::iTime)+ sum( gdm::iOperatingMode, vBoxExtraPower(gdm::iBox,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,   sum( gdm::iOperatingMode, vBackupExtraPower(gdm::iBackupArc,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iAuxPowerGroup ) | gdm::epAuxPowerGroupEnergyContract( gdm::iAuxPowerGroup ) = gdm::iEnergyContract, vAuxPower( gdm::iAuxPowerGroup, gdm::iTime ) )	+
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,  gdm::pBackupPowerPump( gdm::iBackupArc ) * v01Backup(gdm::iBackupArc, gdm::iTime ) )
						)
						*
						gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime ))
					! Cost of the Input Flow node
					+  sum( (gdm::iInputFlowNode, gdm::iTime), 
						vInputFlow(gdm::iInputFlowNode, gdm::iTime ) * gdm::pInputFlowNodeCostPerUnit(gdm::iInputFlowNode, gdm::iTime ))
					! Value of the Output Flow node
					-  sum( (gdm::iOutputFlowNode, gdm::iTime), 
					vOutputFlow(gdm::iOutputFlowNode, gdm::iTime ) * gdm::pOutputFlowNodeValuePerUnit(gdm::iOutputFlowNode, gdm::iTime ))
					) * gdm::pPeriodInHours
					! Credit or cost for buffer variation
					+ sum( gdm::iBufferNode, 
						(-vAccuBuffer( gdm::iBufferNode, gdm::epLastTimeUnit) + gdm::pBufferInitialAccu(gdm::iBufferNode)) * gdm::pBufferGasValue(gdm::iBufferNode))
					! Credit or cost for liquid tank level variation (new tank node element)
					+ sum( gdm::iTankNode, 
						(-vTankLevel( gdm::iTankNode, gdm::epLastTimeUnit) + gdm::pTankInitialLevel( gdm::iTankNode ))*gdm::pTankLiquidValue(gdm::iTankNode))
				}
			}
			Variable vObjective {
				Text: "Objective value";
				Range: free;
				Definition: {
					vObjectiveCost +
					1000*sum( (gdm::iPressureControlNode, gdm::iTime),vPressureSlackPos(gdm::iPressureControlNode, gdm::iTime)+vPressureSlackNeg(gdm::iPressureControlNode, gdm::iTime)) +
					1000*sum( (gdm::iTankNode, gdm::iTime ), vLiquidSlackMax( gdm::iTankNode, gdm::iTime ) + vLiquidSlackMin(gdm::iTankNode, gdm::iTime ) ) + 
					1000*sum( (gdm::iColdbox, gdm::iTime), vPowerBalanceSlackPos(gdm::iColdbox, gdm::iTime) + vPowerBalanceSlackNeg(gdm::iColdbox, gdm::iTime) ) +
					1000*sum( (gdm::iCompressorArc, gdm::iTime), vCompressorFlowMaxSlack(gdm::iCompressorArc, gdm::iTime) + vCompressorFlowMinSlack(gdm::iCompressorArc, gdm::iTime)) + 
					1000*sum( (gdm::iPipeArc, gdm::iTime), vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) + vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime) ) +
					1000*sum( (gdm::iBufferNode, gdm::iTime),vBufferMinPressureSlack(gdm::iBufferNode, gdm::iTime)+ vBufferMaxPressureSlack(gdm::iBufferNode, gdm::iTime)) 
					+ sum( gdm::iTime, vPressurePenalty(gdm::iTime))
				}
			}
			Parameter pObjectiveCost;
			Parameter pObjective;
			Parameter pCostCompressor {
				IndexDomain: (gdm::iEnergyContract, gdm::iTime);
				Definition: {
					
					( sum( gdm::iCompressorArc | gdm::epCompressorEnergyContract( gdm::iCompressorArc ) = gdm::iEnergyContract, 
						vCompressorPower( gdm::iCompressorArc, gdm::iTime ) + 
						sum( gdm::iOperatingMode, vCompressorExtraPower(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime) ) 
					     ) * gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostLiquefier {
				IndexDomain: (gdm::iEnergyContract, gdm::iTime);
				Definition: {
					
					( sum( gdm::iLiquefierArc | gdm::epLiquefierEnergyContract( gdm::iLiquefierArc ) = gdm::iEnergyContract, 
						vLiquefierPower( gdm::iLiquefierArc, gdm::iTime )  + 
						sum( gdm::iOperatingMode, vLiquefierExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime) ) 
					     ) * gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostBox {
				IndexDomain: (gdm::iEnergyContract,gdm::iTime);
				Definition: {
					
					( sum( gdm::ibox | gdm::epBoxEnergyContract( gdm::ibox ) = gdm::iEnergyContract, 
						sum( gdm::iOperatingMode, vBoxExtraPower(gdm::ibox,gdm::iOperatingMode,gdm::iTime)) 
					     ) * gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostAuxiliary {
				IndexDomain: (gdm::iEnergyContract, gdm::iTime);
				Definition: {
					
					( sum( gdm::iAuxPowerGroup | gdm::epAuxPowerGroupEnergyContract( gdm::iAuxPowerGroup ) = gdm::iEnergyContract, 
						vAuxPower( gdm::iAuxPowerGroup, gdm::iTime )   
					     ) * gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostBackup {
				IndexDomain: (gdm::iEnergyContract,gdm::iTime);
				Definition: {
					
					
					( sum( gdm::iBackupArc | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract, 
						gdm::pBackupPowerPump( gdm::iBackupArc ) * v01Backup(gdm::iBackupArc, gdm::iTime ) 
					     ) * gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostInputFlowNode {
				IndexDomain: (gdm::iInputFlowNode,gdm::iTime);
				Definition: {
					
					(
					  vInputFlow(gdm::iInputFlowNode, gdm::iTime ) * gdm::pInputFlowNodeCostPerUnit(gdm::iInputFlowNode, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostOutputFlowNode {
				IndexDomain: (gdm::iOutputFlowNode,gdm::iTime);
				Definition: {
					
					( vOutputFlow(gdm::iOutputFlowNode, gdm::iTime ) * gdm::pOutputFlowNodeValuePerUnit(gdm::iOutputFlowNode, gdm::iTime )
					) * gdm::pPeriodInHours
				}
			}
			Parameter pEnergyCost {
				Definition: {
					( sum( ( gdm::iEnergyContract, gdm::iTime ),
						( sum( ( gdm::iCompressorArc ) | gdm::epCompressorEnergyContract( gdm::iCompressorArc ) = gdm::iEnergyContract, vCompressorPower( gdm::iCompressorArc, gdm::iTime ) + sum(gdm::iOperatingMode, vCompressorExtraPower(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iLiquefierArc )  | gdm::epLiquefierEnergyContract( gdm::iLiquefierArc ) = gdm::iEnergyContract,   vLiquefierPower( gdm::iLiquefierArc, gdm::iTime )   +  sum(gdm::iOperatingMode, vLiquefierExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iBox )       | gdm::epBoxEnergyContract( gdm::iBox ) = gdm::iEnergyContract, vboxPower(gdm::iBox, gdm::iTime)+ sum( gdm::iOperatingMode, vBoxExtraPower(gdm::iBox,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,   sum( gdm::iOperatingMode, vBackupExtraPower(gdm::iBackupArc,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iAuxPowerGroup ) | gdm::epAuxPowerGroupEnergyContract( gdm::iAuxPowerGroup ) = gdm::iEnergyContract, vAuxPower( gdm::iAuxPowerGroup, gdm::iTime ) )	+
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,  gdm::pBackupPowerPump( gdm::iBackupArc ) * v01Backup(gdm::iBackupArc, gdm::iTime ) )
						)
						*
						gdm::pEnergyContractCost( gdm::iEnergyContract, gdm::iTime ))
					) * gdm::pPeriodInHours
				}
			}
			Parameter pInputFlowCost {
				Definition: {
					! Cost of the Input Flow node
					( sum( (gdm::iInputFlowNode, gdm::iTime), 
						vInputFlow(gdm::iInputFlowNode, gdm::iTime ) * gdm::pInputFlowNodeCostPerUnit(gdm::iInputFlowNode, gdm::iTime ))
					) * gdm::pPeriodInHours
				}
			}
			Parameter pOutputFlowCost {
				Definition: {
					! Value of the Output Flow node
					(- sum( (gdm::iOutputFlowNode, gdm::iTime), 
					vOutputFlow(gdm::iOutputFlowNode, gdm::iTime ) * gdm::pOutputFlowNodeValuePerUnit(gdm::iOutputFlowNode, gdm::iTime ))
					) * gdm::pPeriodInHours
				}
			}
			Parameter pCostBuffer {
				Definition: {
					! Credit or cost for buffer variation
					sum( gdm::iBufferNode, 
						(-vAccuBuffer( gdm::iBufferNode, gdm::epLastTimeUnit) + gdm::pBufferInitialAccu(gdm::iBufferNode)) * gdm::pBufferGasValue(gdm::iBufferNode))
				}
			}
			Parameter pCostTank {
				Definition: {
					! Credit or cost for liquid tank level variation (new tank node element)
					sum( gdm::iTankNode, 
						(-vTankLevel( gdm::iTankNode, gdm::epLastTimeUnit) + gdm::pTankInitialLevel( gdm::iTankNode ))*gdm::pTankLiquidValue(gdm::iTankNode))
				}
			}
			Parameter pCostSlackOthers {
				Definition: {
					
					vObjective - vObjectiveCost
				}
			}
			Parameter pEnergykWh {
				Definition: {
					( sum( ( gdm::iEnergyContract, gdm::iTime ),
						( sum( ( gdm::iCompressorArc ) | gdm::epCompressorEnergyContract( gdm::iCompressorArc ) = gdm::iEnergyContract, vCompressorPower( gdm::iCompressorArc, gdm::iTime ) + sum(gdm::iOperatingMode, vCompressorExtraPower(gdm::iCompressorArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iLiquefierArc )  | gdm::epLiquefierEnergyContract( gdm::iLiquefierArc ) = gdm::iEnergyContract,   vLiquefierPower( gdm::iLiquefierArc, gdm::iTime )   +  sum(gdm::iOperatingMode, vLiquefierExtraPower(gdm::iLiquefierArc,gdm::iOperatingMode,gdm::iTime)) )+
						  sum( ( gdm::iBox )       | gdm::epBoxEnergyContract( gdm::iBox ) = gdm::iEnergyContract, vboxPower(gdm::iBox, gdm::iTime)+ sum( gdm::iOperatingMode, vBoxExtraPower(gdm::iBox,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,   sum( gdm::iOperatingMode, vBackupExtraPower(gdm::iBackupArc,gdm::iOperatingMode,gdm::iTime) )) +
						  sum( ( gdm::iAuxPowerGroup ) | gdm::epAuxPowerGroupEnergyContract( gdm::iAuxPowerGroup ) = gdm::iEnergyContract, vAuxPower( gdm::iAuxPowerGroup, gdm::iTime ) )	+
						  sum( ( gdm::iBackupArc )     | gdm::epBackupEnergyContract( gdm::iBackupArc ) = gdm::iEnergyContract,  gdm::pBackupPowerPump( gdm::iBackupArc ) * v01Backup(gdm::iBackupArc, gdm::iTime ) )
						) )
					) * gdm::pPeriodInHours
				}
			}
		}
		DeclarationSection mathematical_program {
			Set sMPConstraints_General {
				SubsetOf: AllConstraints;
				Definition: {
					!Defined in the procConfigureMathProgram for each entity specific
				}
			}
			Set sMPVariables_General {
				SubsetOf: AllVariables;
				Definition: {
					!Defined in the procConfigureMathProgram for each entity specific
				}
			}
			Set sMPConstraintsExcluded_gom {
				SubsetOf: AllConstraints;
				Definition: {
					{ 'lom::cFlowDirection', 'lom::cFlowDirectionPlus', 'lom::cFlowDirectionMinus' }
				}
			}
			Set sMPVarialblesExcluded_gom {
				SubsetOf: AllVariables;
			}
			MathematicalProgram mpGeneralModel {
				Objective: vObjective;
				Direction: minimize;
				Constraints: sMPConstraints_General;
				Variables: sMPVariables_General;
				Type: Automatic;
			}
			ElementParameter epProgramStatus {
				Range: AllSolutionStates;
			}
			StringParameter spProgramStatus {
				Definition: epProgramStatus;
			}
			Parameter pTimeUsed;
			Parameter pGap;
		}
	}
	Section Solve_procedures {
		Procedure procSolve {
			Arguments: (epGMP,p01DoNotUsePresolver,splProgramStatus);
			Body: {
				spMathProgramType := GMP::Instance::GetMathematicalProgrammingType( epGMP );
				
				if ( gdm::p01AllowMultiStart and spMathProgramType <> "MIP" and spMathProgramType <> "LP" )
				then
				log_message::procLogInfo( "","Multistart used for solve" );
				if ( spMathProgramType = 'NLP'
				  or spMathProgramType = 'QP' 
				  or spMathProgramType = 'MIQP' 
				 	  or spMathProgramType = 'QCP' )
				then 
					MulStart::DoMultiStart(epGMP,30,10);
				else
					GMPOuterApprox::NLPUseInitialValues := 0;
					GMPOuterApprox::DoOuterApproximation(epGMP);
				endif;
				else
				if ( spMathProgramType = 'NLP' or spMathProgramType = 'LP' or spMathProgramType = 'MIP' 
				  or spMathProgramType = 'QP' or spMathProgramType = 'MIQP' or spMathProgramType = 'QCP' )
				then 
				
					GMP::Instance::Solve(epGMP);
				else
					if ( p01DoNotUsePresolver )
					then
						GMPOuterApprox::UsePresolver := 0;
					else
						GMPOuterApprox::UsePresolver := 1;
					endif;
					GMPOuterApprox::DoOuterApproximation(epGMP);
				endif;
				endif;
				splProgramStatus := formatstring( "%s", GMP::Solution::GetProgramStatus( epGMP, 1 ));
			}
			ElementParameter epGMP {
				Range: AllGeneratedMathematicalPrograms;
				Property: Input;
			}
			Parameter p01DoNotUsePresolver {
				Property: Input;
			}
			StringParameter splProgramStatus {
				Property: Output;
			}
			StringParameter spMathProgramType;
		}
		Procedure procCheckSevereErrors {
			Body: {
				if exists(log_message::iLogMessage|log_message::pLogMessageSeverity(log_message::iLogMessage)=2) then
				  Dialogmessage("First solve all data errors with severity 2");
				  return 0;
				else 
				  return 1;
				endif;
			}
		}
		Procedure procSolveGeneralModel {
			Body: {
				if p01ApplicationIsOnAimmsPro then
					pro::ManagedSessionRemoveFromCaseIdentifierSet := {};
				
					!Delegate the execution of the procedure to the server
					if pro::DelegateToServer( 
					waitForCompletion: 1,
					completionCallback: 'pro::session::LoadResultsCallback',
					priorityAdjustment: 0,
					timeOut: 600000
					) 
					then
					return 1;
					endif ;
				endif;
				
				gdm::procCheckData;
				if procCheckSevereErrors = 1  then
				
					!Configure math program 
					gom::procConfigureMathProgram();
				
					!Solve
					BLOCK
						epGMP := GMP::Instance::Generate( gom::mpGeneralModel );
						gom::procSolve( epGMP, 0, splProgramStatus );
					ONERROR epError
					DO
						spErrorString := errh::Message(epError);
						if( errh::Severity( epError ) = 'Warning' )
						then
							!It is a warning, mark it as handled and return.
							errh::MarkAsHandled( epError );
						else
							log_message::procLogInfo("",formatstring( "Solver failed for general model: %s", spErrorString));
							errh::MarkAsHandled( epError );	
							return 0;
						endif;
					ENDBLOCK;
				
					gdm::procLogSlackAllowed("Variant"); !log slack allowed
					log_message::procLogInfo("",formatstring( "Program status for general model: %s", splProgramStatus));
				
					!Copy objective values to parameters
					gom::pObjectiveCost:= gom::vObjectiveCost;
					gom::pObjective:= gom::vObjective;
				
					epProgramStatus := (GMP::Solution::GetProgramStatus( epGMP, 1 ));
					pTimeUsed := (GMP::Solution::GetTimeUsed( epGMP, 1 ));
					pGap :=( abs( mpGeneralModel.Incumbent - mpGeneralModel.bestbound ) / $abs( mpGeneralModel.Incumbent ) ) * 100;
				
					!Return 1 on (local)optimality
					if( splProgramStatus = "Optimal" or splProgramStatus = "LocallyOptimal" )
					then
						return 1;
					else
						return 0;
					endif;
				
				else
					return 0;
				endif;
			}
			ElementParameter epGMP {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter splProgramStatus;
			ElementParameter epError {
				Range: errh::PendingErrors;
			}
			StringParameter spErrorString;
		}
		Procedure procSolveLinearBlockGeneral {
			Body: {
				if p01ApplicationIsOnAimmsPro then
					pro::ManagedSessionRemoveFromCaseIdentifierSet := {};
				
					!Delegate the execution of the procedure to the server
					if pro::DelegateToServer( 
					waitForCompletion: 1,
					completionCallback: 'pro::session::LoadResultsCallback',
					priorityAdjustment: 0,
					timeOut: 600000
					) 
					then
					return 1;
					endif ;
				endif;
				
				gdm::procCheckData;
				if procCheckSevereErrors() = 1  then
				
					!Solve
					Empty AllVariables;
				
					!Configure linear math program 
					lom::procConfigureMathProgram_lom();
				
					if lom::procSolveLinearModel() = 0 then
						return 0;
					endif;
				
					! Fix binary variables
					procFixAllBinaryVariables();
				
					!Configure nonlinear math program 
					procConfigureMathProgram();
				
					!Solve
				        	BLOCK
				        		epGMP := GMP::Instance::Generate( gom::mpGeneralModel );
				        		gom::procSolve( epGMP, 1, splProgramStatus );
				        	ONERROR epError
				        	DO
				        		spErrorString := errh::Message(epError);
				        		if( errh::Severity( epError ) = 'Warning' )
				        		then
				        			!It is a warning, mark it as handled and return.
				        			errh::MarkAsHandled( epError );
				        		else
				        			log_message::procLogInfo("",formatstring( "Solver failed for general model: %s", spErrorString));
				        			errh::MarkAsHandled( epError );	
				        			return 0;
				        		endif;
				        	ENDBLOCK;
				
				        	gdm::procLogSlackAllowed("Variant"); !log slack allowed
				        	log_message::procLogInfo("",formatstring( "Program status for general model: %s", splProgramStatus));
				
				        	procMakeAllVariablesVar();
				
				        	!Copy objective values to parameters
				        	gom::pObjectiveCost:= gom::vObjectiveCost;
				        	gom::pObjective:= gom::vObjective;
				
				        	!Return 1 on (local)optimality
				        	if( splProgramStatus = "Optimal" or splProgramStatus = "LocallyOptimal" )
				        	then
				        		return 1;
				        	else
				        		return 0;
				        	endif;
				
				        else
				        	return 0;
				        endif;
			}
			ElementParameter epGMP {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter splProgramStatus;
			ElementParameter epError {
				Range: errh::PendingErrors;
			}
			StringParameter spErrorString;
		}
		Section Config_procedures {
			DeclarationSection Declaration_Solve_Procedure {
				Parameter pMIP_Relative_Optimality_Tolerance {
					Range: [1e-15, 1];
					InitialData: 0.001;
				}
				Parameter pTime_Limit {
					Range: [10, 600];
					InitialData: 600;
				}
			}
			Procedure procDefineProjectOptim {
				Body: {
					
					! Configure the MIP_Relative_Optimality_Tolerance (gap) and computation Time max
					option time_limit := pTime_Limit, MIP_Relative_Optimality_Tolerance := pMIP_Relative_Optimality_Tolerance;
				}
			}
			Procedure procConfigureMathProgram {
				Body: {
					/****
					This procedure is called before any solve and it configures 
					the mathematical program by setting the correct elements in 
					the sets, i.e. it defines the set of
					- Constraints
					- Variables
					... other
					****/
					
					!set definitions of p01 for linear or non-linear constraints based on data
					gdm::p01BoxLinearEquationModel( gdm::iBox ) := gdm::p01BoxLinearEquationData( gdm::iBox );
					gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) := gdm::p01CompressorLinearEquationData( gdm::iCompressorArc );
					gdm::p01LiquefierLinearEquationModel( gdm::iLiquefierArc ) := gdm::p01LiquefierLinearEquationData( gdm::iLiquefierArc );
					gdm::p01PipeLinearEquationModel( gdm::iPipeArc )   := 0; ! use the calcualtion mode defined by the user (it can even be linear)
					gdm::p01ValveLinearEquationModel( gdm::iValveArc ) := 0; !we do not linearize valve equations within the non-linear model
					
					!Set definitions of constraint and variables sets
					sMPConstraints_General := {IndexConstraints|IndexConstraints in ( GeneralOptimizationModel or LinearOptimizationModel ) }
						- sMPConstraintsExcluded_gom; ! included : exclude the linear constraints on flow, we never linearize these within the non-linear model
					
					sMPVariables_General :=
						{IndexVariables|IndexVariables in ( GeneralOptimizationModel or LinearOptimizationModel ) }
						- sMPVarialblesExcluded_gom;
					
					!Set definitions of other sets
					gom::procNodeSetsDefinition();
					
					! Call procedure to initialize pAccuBufferInitial based on initial pressures
					procInitializeAccuBuffers();
					
					! Fix unnecessary flow variables based on data
					procFixFlowVariablesFromData();
				}
			}
			Procedure procFixFlowVariablesFromData {
				Body: {
					
					
					 !Set vFlowPlus = 0 if, by definition, flow cannot be positive 
					for( (gdm::iArc, gdm::iTime) | gdm::pArcMaxFlow(gdm::iArc) <= 0 ) do
						vFlowPlus(gdm::iArc, gdm::iTime).nonvar := 1;
						vFlowPlus(gdm::iArc, gdm::iTime).level := 0;
					endfor;
					
					! Set vFlowMinus = 0 if, by definition, flow cannot be negavite 
					for( (gdm::iArc, gdm::iTime) | gdm::pArcMinFlow(gdm::iArc) >= 0 ) do
						vFlowMinus(gdm::iArc, gdm::iTime).nonvar := 1;
						vFlowMinus(gdm::iArc, gdm::iTime).level := 0;
					endfor;
				}
			}
			Procedure procNodeSetsDefinition {
				Body: {
					
					!Set definitions of node zero input and zero output
					sInputZeroNodes := 
						gdm::sNodes
						- gdm::sInputFlowNodes
						- gdm::sBoxConnectionNodes;
						;
					sOutputZeroNodes := 
						gdm::sNodes
						- gdm::sOutputFlowNodes
						- gdm::sTankNodes
						- gdm::sBoxConnectionNodes
						;
					
					!Set definitions of nodes to which cMatBalanceFlowNodes applies
					sNodesMaterialBalance := 
						gdm::sNodes
						- gdm::sBufferNodes 
						- gdm::sTankNodes ;
				}
			}
			Procedure procInitializeAccuBuffers {
				Body: {
					
					! Initialize pAccuBufferInitial based on initial pressures
					
					gdm::pBufferInitialAccu(gdm::iBufferNode):= gdm::pBufferInitialPressure(gdm::iBufferNode)*(gdm::pBufferVolume(gdm::iBufferNode)*(gdm::pTreference/gdm::pTambient)/(gdm::pPreference*gdm::pSIunitsToPressureUnits));
				}
			}
			Procedure procMakeAllVariablesVar {
				Body: {
					!check if lib already exists (then delete)
					                    if StringToElement(AllIdentifiers, "CQM_VARIABLES_VAR", 0)  <> '' then
					                      me::Delete( StringToElement(AllIdentifiers, "CQM_VARIABLES_VAR", 0) );
					                    endif;
					
					                    !Make new library
					                    epLib := me::CreateLibrary(libraryName :  "CQM_VARIABLES_VAR", prefixName  :  "cqm_var");
					
					                    !New procedrue
					                    epProc := me::Create( "MakeAllVariablesVar", 'procedure', epLib);
					
					                    !Create body
					                    spTxt:= "";
					                    for(IndexVariables ) do
					                      	!Create list of indices of the variable
					                      	spIndexList:= "";
					                    	while loopcount <= IdentifierDimension( IndexVariables )
					                    	do
					                    		spIndexList += formatstring( "%e", DomainIndex( IndexVariables, loopcount ) );
					                    		!Add ',' if it is not the last index
					                    		if loopCount < (IdentifierDimension( IndexVariables )) then
					                    			spIndexList += "," ;
					                    		endif;
					                    	endwhile;
					                    	if spIndexList <> "" then spIndexList := "("+ spIndexList +")";endif;
					
					                    	!Add the nonvar statement to the body
					                    	spTxt += formatstring("%e%s.nonvar := 0;\n", IndexVariables,spIndexList);
					                    endfor;
					
					                    me::SetAttribute(epProc, 'body', spTxt);
					
					                    !Compile and run procedure
					                    me::Compile(epLib);
					                    apply(epProc);
					
					                    !Remove the library
					                    if StringToElement(AllIdentifiers, "CQM_VARIABLES_VAR", 0)  <> '' then
					                      me::Delete( StringToElement(AllIdentifiers, "CQM_VARIABLES_VAR", 0) );
					                    endif;
				}
				Comment: "Automatically generates code that makes all variable nonvar = 0";
				ElementParameter epLib {
					Range: AllIdentifiers;
				}
				ElementParameter epProc {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
				}
				StringParameter spTxt;
				StringParameter spIndexList;
			}
			Procedure procFixAllBinaryVariables {
				Body: {
					!check if lib already exists (then delete)
					                    if StringToElement(AllIdentifiers, "CQM_BINARY_VARIABLES_VAR", 0)  <> '' then
					                      me::Delete( StringToElement(AllIdentifiers, "CQM_BINARY_VARIABLES_VAR", 0) );
					                    endif;
					
					                    !Make new library
					                    epLib := me::CreateLibrary(libraryName :  "CQM_BINARY_VARIABLES_VAR", prefixName  :  "cqm_binary_var");
					
					                    !New procedrue
					                    epProc := me::Create( "FixAllBinaryVariables", 'procedure', epLib);
					
					                    !Create body
					                    spTxt:= "";
					                    for(IndexIntegerVariables) do
					                      	!Create list of indices of the variable
					                      	spIndexList:= "";
					                    	while loopcount <= IdentifierDimension( IndexIntegerVariables )
					                    	do
					                    		spIndexList += formatstring( "%e", DomainIndex( IndexIntegerVariables, loopcount ) );
					                    		!Add ',' if it is not the last index
					                    		if loopCount < (IdentifierDimension( IndexIntegerVariables )) then
					                    			spIndexList += "," ;
					                    		endif;
					                    	endwhile;
					                    	if spIndexList <> "" then spIndexList := "("+ spIndexList +")";endif;
					
					                    	!Add the nonvar statement to the body
					                    	spTxt += formatstring("%e%s.nonvar := 1;\n", IndexIntegerVariables,spIndexList);
					                    endfor;
					
					                    me::SetAttribute(epProc, 'body', spTxt);
					
					                    !Compile and run procedure
					                    me::Compile(epLib);
					                    apply(epProc);
					
					                    !Remove the library
					                    if StringToElement(AllIdentifiers, "CQM_BINARY_VARIABLES_VAR", 0)  <> '' then
					                      me::Delete( StringToElement(AllIdentifiers, "CQM_BINARY_VARIABLES_VAR", 0) );
					                    endif;
				}
				ElementParameter epLib {
					Range: AllIdentifiers;
				}
				ElementParameter epProc {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
				}
				StringParameter spTxt;
				StringParameter spIndexList;
			}
		}
	}
	Procedure procClear {
		Body: {
			empty GeneralOptimizationModel;
			empty LinearOptimizationModel;
		}
	}
	Procedure procClearBeforeSolve {
		Body: {
			!empty GeneralSolution;
		}
	}
}
