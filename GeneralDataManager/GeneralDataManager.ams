## ams_version=1.0

LibraryModule GeneralDataManager {
	Prefix: gdm;
	Interface: {
		data { spCoreEngineVersion, sCases, epSelectedCase, spRun, spRunFriendlyName, spRunEntity, 
		       spRunSite, spRunTimeStamp, spRunTimeStampCreation, spRunLastSavedBy, spRunCreatedBy, 
		       spRunModelVersion, spWizardPicture, ob, sNodes, epNodeType, pNodeMinPressure, 
		       pNodeMaxPressure, epNodeSite, sNodeTypes, epNodeTypeInputFlow, epNodeTypeOutputFlow, 
		       epNodeTypeInOutputFlow, epNodeTypeBoxConnection, epNodeTypeTank, epNodeTypeBuffer, 
		       epNodeTypeRegular, sArcs, epArcType, epNodeFrom, epNodeTo, pArcMinFlow, pArcMaxFlow, 
		       sArcTypes, epArcTypeRegular, epArcTypeCompressor, epArcTypeLiquefier, epArcTypeCycle, 
		       epArcTypeValve, epArcTypePipe, epArcTypeBackup, sSites, sArcsAndBoxes, sControlModeElements, 
		       epControlModeElement, sControlMode, epStatusMode, epOperatingMode, sEnergyContract, 
		       pEnergyContractCost, sAuxPowerGroups, epAuxPowerGroupEnergyContract, pAuxPowerGroupParam1, 
		       pAuxPowerGroupParam2, sCoolingTowers, pCoolingTowerTemperature, sPressureControlNodes, 
		       pPressureControlNodeSetpoint, sInputFlowNodes, pInputFlowNodeMinFlow, pInputFlowNodeMaxFlow, 
		       pInputFlowNodeFixed, pInputFlowNodeMinPositiveRateChangeFlow, pInputFlowNodeMaxPositiveRateChangeFlow, 
		       pInputFlowNodeMinNegativeRateChangeFlow, pInputFlowNodeMaxNegativeRateChangeFlow, 
		       pInputFlowNodeMinStayTimeSteadyState, pInputFlowNodeCostPerUnit, sOutputFlowNodes, 
		       pOutputFlowFixed, pOutputFlowNodeMinFlow, pOutputFlowNodeMaxFlow, pOutputFlowNodeMinPositiveRateChangeFlow, 
		       pOutputFlowNodeMaxPositiveRateChangeFlow, pOutputFlowNodeMinNegativeRateChangeFlow, 
		       pOutputFlowNodeMaxNegativeRateChangeFlow, pOutputFlowNodeMinStayTimeSteadyState, 
		       pOutputFlowNodeValuePerUnit, sInOutputFlowNodes, sBoxes, sBoxConnectionNodes, 
		       epBoxNode, pBoxMinFlow, pBoxMaxFlow, pBoxMinPositiveRateChangeFlow, pBoxMaxPositiveRateChangeFlow, 
		       pBoxMinNegativeRateChangeFlow, pBoxMaxNegativeRateChangeFlow, pBoxMinStayTimeSteadyStateFlow, 
		       pBoxParameter1Pres, pBoxParameter2Pres, pBoxParameter3Pres, p01BoxPressureActive, 
		       epBoxEnergyContract, epBoxAuxPowerGroup, p01BoxFlowSpecificEquation, p01BoxLinearEquationData, 
		       p01BoxLinearEquationModel, sBoxTypes, epBoxType, sBoxNodeConnectionTypes, 
		       sBoxNodeConnectionTypeInputs, sBoxNodeConnectionTypeOutputs, epBoxNodeConnectionTypeInput1, 
		       epBoxNodeConnectionTypeInput2, epBoxNodeConnectionTypeInput3, epBoxNodeConnectionTypeInput4, 
		       epBoxNodeConnectionTypeInput5, epBoxNodeConnectionTypeInput6, epBoxNodeConnectionTypeInput7, 
		       epBoxNodeConnectionTypeInput8, epBoxNodeConnectionTypeInput9, epBoxNodeConnectionTypeInput10, 
		       epBoxNodeConnectionTypeOutput1, epBoxNodeConnectionTypeOutput2, epBoxNodeConnectionTypeOutput3, 
		       epBoxNodeConnectionTypeOutput4, epBoxNodeConnectionTypeOutput5, epBoxNodeConnectionTypeOutput6, 
		       epBoxNodeConnectionTypeOutput7, epBoxNodeConnectionTypeOutput8, epBoxNodeConnectionTypeOutput9, 
		       epBoxNodeConnectionTypeOutput10, sBoxParameters, epBoxTypeParameter, pBoxParameterValue, 
		       sColdboxNodeConnectionTypes, spColdboxNodeConnectionName, epColdboxNodeConnectionTypeAirHp, 
		       epColdboxNodeConnectionTypeAirMp, epColdboxNodeConnectionTypeLiNAssist, epColdboxNodeConnectionTypeLOxAssist, 
		       epColdboxNodeConnectionTypeLOx, epColdboxNodeConnectionTypeHpGOx, epColdboxNodeConnectionTypeMpGOx, 
		       epColdboxNodeConnectionTypeLpGOx, epColdboxNodeConnectionTypeLiN, epColdboxNodeConnectionTypeHpGaN, 
		       epColdboxNodeConnectionTypeMpGaN, epColdboxNodeConnectionTypeLpGaN, epColdboxNodeConnectionTypeLAr, 
		       epBoxTypeColdbox, sColdboxes, pColdboxMaxO2ContentInWaste, pColdboxMaxLpGanVent, 
		       pColdboxLosses, pColdboxWasteToAirRatio, pColdboxMinRectifPower, pColdboxMaxRectifPower, 
		       pColdboxLinAssistColdStandby, epColdboxProcess, p01ColdboxTypeSpecificEquation, 
		       sColdboxInternalFlows, epTotalAir, epInternalLiquid, epAirTurbineLp, epGoxToWaste, 
		       pColdboxMinInternalFlow, pColdboxMaxInternalFlow, pColdboxMinPositiveRateChangeInternalFlow, 
		       pColdboxMaxPositiveRateChangeInternalFlow, pColdboxMinNegativeRateChangeInternalFlow, 
		       pColdboxMaxNegativeRateChangeInternalFlow, pColdboxMinStayTimeSteadyStateInternalFlow, 
		       p01ColdboxInternalFlowSpecificEquation, sColdboxProcess, epColdboxProcessAokGok, 
		       epColdboxProcessGas, sColdboxSpecificEquations, epColdboxSpecificEquationMaterialBalance, 
		       epColdboxSpecificEquationPowerBalance, epColdboxSpecificEquationLiquidBalance, 
		       epColdboxSpecificEquationRectifPower, epColdboxSpecificEquationRecovery, epColdboxSpecificEquationPressure, 
		       epColdboxSpecificEquationNitrogenMode, sColdboxParameters, epColdboxPumpingProcessParameter1, 
		       epColdboxPumpingProcessParameter2, epColdboxPumpingProcessParameter3, epColdboxPumpingProcessParameter4, 
		       epColdboxPumpingProcessParameter5, epColdboxRecoveryO2Parameter1, epColdboxRecoveryO2Parameter2, 
		       epColdboxRecoveryO2Parameter3, epColdboxRecoveryO2Parameter4, epColdboxRecoveryO2ParameterLambda, 
		       epColdboxRecoveryArParameter1, epColdboxRecoveryArParameter2, epColdboxRecoveryArParameter3, 
		       epColdboxRecoveryArParameter4, epColdboxRecoveryArParameterLambda, epColdboxTurbInsufflationManualControl, 
		       epColdboxTurbInsufflationLPLevelControl, epColdboxTurbInsufflationRemoteControl, 
		       epColdboxPumpingProcessParameterLinear1, epColdboxPumpingProcessParameterLinear2, 
		       epColdboxPumpingProcessParameterLinear3, epColdboxPumpingProcessParameterLinear4, 
		       epColdboxPumpingProcessParameterLinear5, epColdboxPumpingProcessParameterLinear6, 
		       epColdboxPumpingProcessParameterLinear7, epColdboxPumpingProcessParameterLinear8, 
		       epColdboxPumpingProcessParameterLinear9, epColdboxPumpingProcessParameterLinear10, 
		       epColdboxRecoveryO2ParameterLinear1, epColdboxRecoveryO2ParameterLinear2, 
		       epColdboxRecoveryO2ParameterLinear3, epColdboxRecoveryO2ParameterLinear4, 
		       epColdboxRecoveryArParameterLinear1, epColdboxRecoveryArParameterLinear2, 
		       epColdboxRecoveryArParameterLinear3, epColdboxRecoveryArParameterLinear4, 
		       epColdboxNitrogenModeParameter1, epColdboxNitrogenModeParameter2, epColdboxNitrogenModeParameter3, 
		       epColdboxNitrogenModeParameter4, sBackupArcs, epBackupEnergyContract, pBackupMinFlow, 
		       pBackupMaxFlow, pBackupMinPositiveRateChangeFlow, pBackupMaxPositiveRateChangeFlow, 
		       pBackupMinNegativeRateChangeFlow, pBackupMaxNegativeRateChangeFlow, pBackupMinStayTimeSteadyState, 
		       pBackupPcFlash, pBackupPowerPump, p01BackupFlashSpecificEquation, sBufferNodes, 
		       pBufferMinPressure, pBufferMaxPressure, pBufferVolume, pBufferInitialPressure, 
		       pBufferGasValue, pBufferInitialAccu, sTankNodes, epTankLiquidProduct, pTankInitialLevel, 
		       pTankStorageCapacity, pTankMinLevel, pTankMaxLevel, p01TankEnableLevelConstraints, 
		       pTankLiquidValue, p01TankFlashSpecificEquation, sCompressorArcs, sCompressorDependencies, 
		       epCompressorEnergyContract, epCompressorMapSpecial_1, epCompressorMapSpecial_2, 
		       p01CompressorRunTogether, pCompressorMinFlow, pCompressorMaxFlow, pCompressorMinPositiveRateChangeFlow, 
		       pCompressorMaxPositiveRateChangeFlow, pCompressorMinNegativeRateChangeFlow, 
		       pCompressorMaxNegativeRateChangeFlow, pCompressorMinStayTimeSteadyState, pCompressorMaxPower, 
		       pCompressorMaxCompressionRatio, epCompressorAuxPowerGroup, epCompressorCoolingTower, 
		       pCompressorParameterValue, p01CompressorPowerSpecificEquation, p01CompressorLinearEquationData, 
		       p01CompressorLinearEquationModel, sCompressorParameters, epCompressorParameterEff1, 
		       epCompressorParameterEff2, epCompressorParameterEff3, epCompressorParameterEff4, 
		       epCompressorParameterEff5, epCompressorParameterLinear1, epCompressorParameterLinear2, 
		       epCompressorParameterLinear3, epCompressorParameterLinear4, epCompressorParameterLinear5, 
		       sLiquefierArcs, sCycleArcs, epLiquefierCalculationMode, epLiquefierCycle, 
		       epLiquefierCompressorFeed, epLiquefierCompressorCycle, epLiquefierEnergyContract, 
		       pLiquefierParameterValue, pLiquefierMinFlow, pLiquefierMaxFlow, pLiquefierMinPositiveRateChangeFlow, 
		       pLiquefierMaxPositiveRateChangeFlow, pLiquefierMinNegativeRateChangeFlow, 
		       pLiquefierMaxNegativeRateChangeFlow, pLiquefierMinStayTimeSteadyState, pLiquefierMaxPower, 
		       epLiquefierCoolingTower, epLiquefierAuxPowerGroup, p01LiquefierPowerSpecificEquation, 
		       p01LiquefierLinearEquationData, p01LiquefierLinearEquationModel, sLiquefierParameters, 
		       epLiquefierParameterPerf1, epLiquefierParameterPerf2, epLiquefierParameterPerf3, 
		       epLiquefierParameterPerf4, epLiquefierParameterPerf5, epLiquefierParameterPerfLinear1, 
		       epLiquefierParameterPerfLinear2, epLiquefierParameterPerfLinear3, epLiquefierParameterPerfLinear4, 
		       epRatioCompressorCycle, epPinCompressorCycleParam1, epPinCompressorCycleParam2, 
		       epPinCompressorCycleParam3, epPinCompressorCycleParam4, sLiquefierCalculationModes, 
		       epLiquefierCalculationModeBasic, epLiquefierCalculationModeAdvanced, sPipeArcs, 
		       epPipeCalculationMode, pPipeLinearPressureDropParam1, pPipePressureDropParam1, 
		       pPipeFrictionFactor, pPipeLength, pPipeDiameter, epPipeGasType, pPipeEfficiency, 
		       pPipeRoughness, p01PipePressureDropSpecificEquation, p01PipeFrictionFactorSpecificCorrelation, 
		       p01PipeLinearEquationModel, pPipeCalculatedArea, sPipeCalculationMode, epPipeCalculationModeNoPressureDrop, 
		       epPipeCalculationModeSimplified, epPipeCalculationModeAdvanceQuadratic, epPipeCalculationModeAdvancedConstantFF, 
		       epPipeCalculationModeAdvancedCalculatedFF, sProducts, epProductN2, epProductO2, 
		       epProductAr, epProductAir, pMolecularWeight, pViscosity, pCompressibility, 
		       pLiquidEqCoef, pLiquidMassToVolumeUnits, pdHvaporization, sValveArcs, epValveControlMode, 
		       pValveSetPoint, pValveDeltaPressureMax, p01ValveLinearEquationModel, sValveControlModes, 
		       epValveControlModePressureControl, epValveControlModeFlowControl, epValveControlModeRemoteControl, 
		       epValveControlModeCheckValve, epValveControlModeOpenValve, epValveControlModeOnOff, 
		       pEps1, pEps2, pN2Content, pO2Content, pArContent, pRconstant, pTambient, pTreference, 
		       pPreference, pO2RecoveryMin, pO2RecoveryMax, pArRecoveryMin, pArRecoveryMax, 
		       pScaleFactorCompressorParam1, pScaleFactorCompressorParam2, pScaleFactorCompressorParam3, 
		       pScaleFactorCompressorParam4, pSIunitsToPressureUnits, pSIunitsToPowerUnits, 
		       spBeginCalendar, spBeginCalendarExcel, spGranularityCalendar, pGranularityFrequency, 
		       spEndCalendar, spEndCalendarExcel, spFormatCalendar, pHorizonMultiplyingFactor, 
		       pPeriodInHours, epFirstTimeUnit, epLastTimeUnit, epSelectedTimeUnit, calHorizon, 
		       SI_Time_Duration, pHoursToSeconds, sOperatingModeElements, sOperatingModesAllowed, 
		       epOperatingModeForced, p01OperatingModeAllowed, p01OperatingModeForced, epOperatingModeInitialMode, 
		       pOperatingModeInitialMinTimeRemain, pOperatingModeInitialMaxTimeRemain, p01OperatingModeTransitionAllowed, 
		       pOperatingModeMinStayTime, pOperatingModeMaxStayTime, pOperatingModeExtraPower, 
		       p01OperatingModeUseSpecificDescription, sOperatingModes, epOperatingModeTypeOn, 
		       epOperatingModeTypeOff, epOperatingModeTypeStart, epOperatingModeTypeUnloaded, 
		       epOperatingModeTypeColdStandBy, epOperatingModeTypeCoolDown, epOperatingModeTypeArgonStart, 
		       sStatusModeElements, epStatusElement, sStatusModes, epStatusModeRun, epStatusModeUAvl, 
		       epStatusModeAvl, p01AllowMultiStart, p01AllowSlackPressure, p01AllowPressurePenalty, 
		       p01AllowSlackLiquid, p01AllowSlackCompressorFlow, p01AllowSlackPowerBalance, 
		       p01AllowSlackPressureDrop, p01AllowSlackReliefValveBuffer, procLogSlackAllowed, 
		       spModelVersion, spConnectionString, spSchemaName, epSelectedDatabaseType, 
		       spExcelFileDisplay, spReadErrorMessage, pPressureControlNodeSetpointConstant, 
		       pPressureControlNodeSetpointTimeDependent, p01PressureControlNodeSetPointActiveTimeDependent, 
		       pBufferMinPressureConstant, pBufferMaxPressureConstant, pBufferMinPressureTimeDependent, 
		       pBufferMaxPressureTimeDependent, p01BufferActiveTimeDependent, pBackupMinFlowConstant, 
		       pBackupMaxFlowConstant, pBackupMinPositiveRateChangeFlowConstant, pBackupMaxPositiveRateChangeFlowConstant, 
		       pBackupMinNegativeRateChangeFlowConstant, pBackupMaxNegativeRateChangeFlowConstant, 
		       pBackupMinStayTimeSteadyStateConstant, pBackupMinFlowTimeDependent, pBackupMaxFlowTimeDependent, 
		       pBackupMinPositiveRateChangeFlowTimeDependent, pBackupMaxPositiveRateChangeFlowTimeDependent, 
		       pBackupMinNegativeRateChangeFlowTimeDependent, pBackupMaxNegativeRateChangeFlowTimeDependent, 
		       pBackupMinStayTimeSteadyStateTimeDependent, p01BackupActiveTimeDependent, 
		       pBoxMinFlowConstant, pBoxMaxFlowConstant, pBoxMinPositiveRateChangeFlowConstant, 
		       pBoxMaxPositiveRateChangeFlowConstant, pBoxMinNegativeRateChangeFlowConstant, 
		       pBoxMaxNegativeRateChangeFlowConstant, pboxMinStayTimeSteadyStateConstant, 
		       pBoxMinFlowTimeDependent, pBoxMaxFlowTimeDependent, pBoxMinPositiveRateChangeFlowTimeDependent, 
		       pBoxMaxPositiveRateChangeFlowTimeDependent, pBoxMinNegativeRateChangeFlowTimeDependent, 
		       pBoxMaxNegativeRateChangeFlowTimeDependent, pboxMinStayTimeSteadyStateTimeDependent, 
		       p01BoxFlowActiveTimeDependent, p01TimeDependentBoxControlMode, pColdboxMinInternalFlowConstant, 
		       pColdboxMaxInternalFlowConstant, pColdboxMinPositiveRateChangeInternalFlowConstant, 
		       pColdboxMaxPositiveRateChangeInternalFlowConstant, pColdboxMinNegativeRateChangeInternalFlowConstant, 
		       pColdboxMaxNegativeRateChangeInternalFlowConstant, pColdboxMinStayTimeSteadyStateConstant, 
		       pColdboxMinInternalFlowTimeDependent, pColdboxMaxInternalFlowTimeDependent, 
		       pColdboxMinPositiveRateChangeInternalFlowTimeDependent, pColdboxMaxPositiveRateChangeInternalFlowTimeDependent, 
		       pColdboxMinNegativeRateChangeInternalFlowTimeDependent, pColdboxMaxNegativeRateChangeInternalFlowTimeDependent, 
		       pColdboxMinStayTimeSteadyStateTimeDependent, p01ColdboxFlowActiveTimeDependent, 
		       pCompressorMinFlowConstant, pCompressorMaxFlowConstant, pCompressorMinPositiveRateChangeFlowConstant, 
		       pCompressorMaxPositiveRateChangeFlowConstant, pCompressorMinNegativeRateChangeFlowConstant, 
		       pCompressorMaxNegativeRateChangeFlowConstant, pCompressorMinStayTimeSteadyStateConstant, 
		       pCompressorMaxPowerConstant, pCompressorMinFlowTimeDependent, pCompressorMaxFlowTimeDependent, 
		       pCompressorMinPositiveRateChangeFlowTimeDependent, pCompressorMaxPositiveRateChangeFlowTimeDependent, 
		       pCompressorMinNegativeRateChangeFlowTimeDependent, pCompressorMaxNegativeRateChangeFlowTimeDependent, 
		       pCompressorMinStayTimeSteadyStateTimeDependent, pCompressorMaxPowerTimeDependent, 
		       p01CompressorActiveTimeDependent, pCoolingTowerTemperatureConstant, pCoolingTowerTemperatureTimeDependent, 
		       p01CoolingTowerTemperatureActiveTimeDependent, pOutputFlowNodeFixedConstant, 
		       pOutputFlowNodeMinFlowConstant, pOutputFlowNodeMaxFlowConstant, pOutputFlowNodeMinPositiveRateChangeFlowConstant, 
		       pOutputFlowNodeMaxPositiveRateChangeFlowConstant, pOutputFlowNodeMinNegativeRateChangeFlowConstant, 
		       pOutputFlowNodeMaxNegativeRateChangeFlowConstant, pOutputFlowNodeMinStayTimeSteadyStateConstant, 
		       pOutputFlowNodeValuePerUnitConstant, pOutputFlowNodeFixedTimeDependent, pOutputFlowNodeMinFlowTimeDependent, 
		       pOutputFlowNodeMaxFlowTimeDependent, pOutputFlowNodeMinPositiveRateChangeFlowTimeDependent, 
		       pOutputFlowNodeMaxPositiveRateChangeFlowTimeDependent, pOutputFlowNodeMinNegativeRateChangeFlowTimeDependent, 
		       pOutputFlowNodeMaxNegativeRateChangeFlowTimeDependent, pOutputFlowNodeMinStayTimeSteadyStateTimeDependent, 
		       pOutputFlowNodeValuePerUnitTimeDependent, p01OutputFlowNodeActiveTimeDependent, 
		       pInputFlowNodeMinFlowConstant, pInputFlowNodeMaxFlowConstant, pInputFlowNodeFixedConstant, 
		       pInputFlowNodeCostPerUnitConstant, pInputFlowNodeMinPositiveRateChangeFlowConstant, 
		       pInputFlowNodeMaxPositiveRateChangeFlowConstant, pInputFlowNodeMinNegativeRateChangeFlowConstant, 
		       pInputFlowNodeMaxNegativeRateChangeFlowConstant, pInputFlowNodeMinStayTimeSteadyStateConstant, 
		       pInputFlowNodeMinFlowTimeDependent, pInputFlowNodeMaxFlowTimeDependent, pInputFlowNodeFixedTimeDependent, 
		       pInputFlowNodeMinPositiveRateChangeFlowTimeDependent, pInputFlowNodeMaxPositiveRateChangeFlowTimeDependent, 
		       pInputFlowNodeMinNegativeRateChangeFlowTimeDependent, pInputFlowNodeMaxNegativeRateChangeFlowTimeDependent, 
		       pInputFlowNodeMinStayTimeSteadyStateTimeDependent, pInputFlowNodeCostPerUnitTimeDependent, 
		       p01InputFlowNodeActiveTimeDependent, pLiquefierMinFlowConstant, pLiquefierMaxFlowConstant, 
		       pLiquefierMinFlowTimeDependent, pLiquefierMaxFlowTimeDependent, pLiquefierMinPositiveRateChangeFlowConstant, 
		       pLiquefierMaxPositiveRateChangeFlowConstant, pLiquefierMinNegativeRateChangeFlowConstant, 
		       pLiquefierMaxNegativeRateChangeFlowConstant, pLiquefierMinStayTimeSteadyStateConstant, 
		       pLiquefierMaxPowerConstant, pLiquefierMinPositiveRateChangeFlowTimeDependent, 
		       pLiquefierMaxPositiveRateChangeFlowTimeDependent, pLiquefierMinNegativeRateChangeFlowTimeDependent, 
		       pLiquefierMaxNegativeRateChangeFlowTimeDependent, pLiquefierMinStayTimeSteadyStateTimeDependent, 
		       pLiquefierMaxPowerTimeDependent, p01LiquifierActiveTimeDependent, pEnergyContractCostConstant, 
		       pEnergyContractCostTimeDependent, p01EnergyContractActiveTimeDependent, pTankMinLevelConstant, 
		       pTankMaxLevelConstant, p01TankEnableLevelConstraintsConstant, pTankMinLevelTimeDependent, 
		       pTankMaxLevelTimeDependent, p01TankEnableLevelConstraintsTimeDependent, p01TankLevelActiveTimeDependent, 
		       epValveControlModeConstant, epValveControlModeTimeDependent, pValveSetpointConstant, 
		       pValveSetpointTimeDependent, p01ValveActiveTimeDependent, p01OperatingModeAllowedConstant, 
		       p01OperatingModeAllowedTimeDependent, p01OperatingModeActiveTimeDependent, 
		       epOperatingModeForcedConstant, epOperatingModeForcedTimeDependent, p01OperatingModeElementActiveTimeDependent, 
		       epStatusElementConstant, epStatusElementTimeDependent, p01StatusElementActiveTimeDependent, 
		       procInitializeTimeDependentData, procDefineTablesTime1, procDefineTablesTime2, 
		       procReadFromExcelButton, procReadFromExcel, procWriteToExcelButton, procWriteToExcel, 
		       procChangeDateFormatExcelRead, procChangeDateFormatExcelWrite, procReadFromDatabase, 
		       procReadFromDatabaseMerge, procWriteToDatabase, procDeleteCaseFromDatabase, 
		       procControlModeElementSetDefinition, procCheckData, procCheckNodes, procCheckArcs, 
		       spSevereErrorForSolve, procClearMessages, procCheckElementParameters, procDummy, 
		       procEmptyAllData, sCounterOfTableList, pCountTableList, epCountTableList }
	}
	Section Data_declaration {
		DeclarationSection Declaration_Version {
			StringParameter spCoreEngineVersion {
				Definition: "Core Engine V4.1";
			}
		}
		Section Cases {
			Set sCases {
				Index: iCase;
				OrderBy: iCase;
			}
			ElementParameter epSelectedCase {
				Range: sCases;
				Comment: "the case that is currently read into the model";
			}
			StringParameter spRun;
			StringParameter spRunFriendlyName;
			StringParameter spRunEntity {
				Comment: "Name of the entity the data belongs to";
			}
			StringParameter spRunSite {
				Comment: "Name of the site or network the data belongs to";
			}
			StringParameter spRunTimeStamp {
				Comment: "Timestamp of the last time saved";
			}
			StringParameter spRunTimeStampCreation {
				Comment: "Timestamp of the creation of the case";
			}
			StringParameter spRunLastSavedBy {
				Comment: "User name of the person who last saved the case/run";
			}
			StringParameter spRunCreatedBy {
				Comment: "User name of the person who created the case/run";
			}
			StringParameter spRunModelVersion;
			StringParameter spWizardPicture;
			Parameter ob;
		}
		Section Architecture {
			DeclarationSection Node_Declaration {
				Set sNodes {
					Index: iNode, iNode1, iNode2;
					OrderBy: iNode, iNode1, iNode2;
					Comment: "Type of node follows from the subsets and elementparameters";
				}
				ElementParameter epNodeType {
					IndexDomain: iNode;
					Range: sNodeTypes;
				}
				Parameter pNodeMinPressure {
					IndexDomain: iNode;
					Comment: "0.1";
				}
				Parameter pNodeMaxPressure {
					IndexDomain: iNode;
					Comment: "100";
				}
				ElementParameter epNodeSite {
					IndexDomain: iNode;
					Range: sSites;
				}
			}
			DeclarationSection Node_type_Declaration {
				Set sNodeTypes {
					Index: iNodeType;
					OrderBy: iNodeType;
					Comment: "data {\'InputFlow\',\'OutputFlow\',\'ColdboxConnection\',\'Tank\',\'Buffer\',\'Regular\'}";
				}
				ElementParameter epNodeTypeInputFlow {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"InputFlow");
				}
				ElementParameter epNodeTypeOutputFlow {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"OutputFlow");
				}
				ElementParameter epNodeTypeInOutputFlow {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"InOutputFlow");
				}
				ElementParameter epNodeTypeBoxConnection {
					Range: sNodeTypes;
					Definition: stringtoelement(gdm::sNodeTypes,"boxConnection");
				}
				ElementParameter epNodeTypeTank {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"Tank");
				}
				ElementParameter epNodeTypeBuffer {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"Buffer");
				}
				ElementParameter epNodeTypeRegular {
					Range: sNodeTypes;
					Definition: stringtoelement(sNodeTypes,"Regular");
				}
			}
			DeclarationSection Arc_Declaration {
				Set sArcs {
					SubsetOf: sArcsAndBoxes;
					Index: iArc, iArc2;
					OrderBy: iArc;
					Comment: "Type of arc folows from the subsets";
				}
				ElementParameter epArcType {
					IndexDomain: iArc;
					Range: sArcTypes;
				}
				ElementParameter epNodeFrom {
					IndexDomain: iArc;
					Range: sNodes;
				}
				ElementParameter epNodeTo {
					IndexDomain: iArc;
					Range: sNodes;
				}
				Parameter pArcMinFlow {
					IndexDomain: (iArc);
					Range: free;
				}
				Parameter pArcMaxFlow {
					IndexDomain: (iArc);
					Range: free;
				}
			}
			DeclarationSection Arc_type_Declaration {
				Set sArcTypes {
					Index: iArcType;
					OrderBy: iArcType;
					Comment: "data {\'Regular\',\'Compressor\',\'Liquefier\',\'Cycle\',\'Valve\',\'Pipe\',\'Backup\'}";
				}
				ElementParameter epArcTypeRegular {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Regular");
				}
				ElementParameter epArcTypeCompressor {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Compressor");
				}
				ElementParameter epArcTypeLiquefier {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Liquefier");
				}
				ElementParameter epArcTypeCycle {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Cycle");
				}
				ElementParameter epArcTypeValve {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Valve");
				}
				ElementParameter epArcTypePipe {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Pipe");
				}
				ElementParameter epArcTypeBackup {
					Range: sArcTypes;
					Definition: stringtoelement(sArcTypes,"Backup");
				}
			}
			DeclarationSection Site_Declaration {
				Set sSites {
					Index: iSite, iSite2;
					OrderBy: iSite;
				}
			}
			Section Control_Modes {
				DeclarationSection Control_mode_Elements_Declaration {
					Set sArcsAndBoxes {
						Index: iArcAndBox;
						Definition: sArcs + sBoxes;
					}
					Set sControlModeElements {
						SubsetOf: sArcsAndBoxes;
						Index: iControlModeElement;
						Definition: {
							
							! { iArcAndBox | epArcType( iArcAndBox ) = epArcTypeCompressor or epArcType( iArcAndBox ) = epArcTypeLiquefier or epArcType( iArcAndBox ) = epArcTypeBackup or iArcAndBox in sColdboxes }
						}
						Comment: {
							"EL : Il ne faut pas que la liste des ControlModeElement soit en dur sinon on ne pourra pas en ajouter dans la user library si besoin (exemple la userbox).
							     Par contre si on le charge d\'Excel risque d\'incoherence (tous et seulement les elements cité doivent y être) => Voir avec ThR"
						}
					}
					ElementParameter epControlModeElement {
						IndexDomain: (iControlModeElement);
						Range: sControlMode;
					}
				}
				DeclarationSection Control_Mode {
					Set sControlMode {
						Index: iControlMode;
						OrderBy: iControlMode;
					}
					ElementParameter epStatusMode {
						Range: sControlMode;
						Definition: stringtoelement(sControlMode,"StatusMode");
					}
					ElementParameter epOperatingMode {
						Range: sControlMode;
						Definition: stringtoelement(sControlMode,"OperatingMode");
					}
				}
			}
		}
		Section Energy_Contract {
			DeclarationSection Energy_Contract_Declaration {
				Set sEnergyContract {
					Index: iEnergyContract, iEnergyContract2;
					OrderBy: iEnergyContract;
				}
				Parameter pEnergyContractCost {
					IndexDomain: (iEnergyContract,iTime);
				}
			}
		}
		Section Auxiliary_Power {
			DeclarationSection Aux_Power_Declaration {
				Set sAuxPowerGroups {
					Index: iAuxPowerGroup, iAuxPowerGroup2;
					OrderBy: iAuxPowerGroup;
				}
				ElementParameter epAuxPowerGroupEnergyContract {
					IndexDomain: iAuxPowerGroup;
					Range: sEnergyContract;
				}
				Parameter pAuxPowerGroupParam1 {
					IndexDomain: iAuxPowerGroup;
				}
				Parameter pAuxPowerGroupParam2 {
					IndexDomain: iAuxPowerGroup;
				}
			}
		}
		Section Cooling_Tower {
			DeclarationSection Cooling_Tower_Declaration {
				Set sCoolingTowers {
					Index: iCoolingTower, iCoolingTower2;
					OrderBy: iCoolingTower;
				}
				Parameter pCoolingTowerTemperature {
					IndexDomain: (iCoolingTower, iTime);
					Range: nonnegative;
				}
			}
		}
		Section Pressure_map {
			DeclarationSection Pressure_map_Declaration {
				Set sPressureControlNodes {
					SubsetOf: sNodes;
					Index: iPressureControlNode, iPressureControlNode2;
					OrderBy: iPressureControlNode;
				}
				Parameter pPressureControlNodeSetpoint {
					IndexDomain: (iPressureControlNode,iTime);
					Default: 0;
				}
			}
		}
		Section Input_Flow_Node {
			DeclarationSection Input_Flow_Declaration {
				Set sInputFlowNodes {
					SubsetOf: sNodes;
					Index: iInputFlowNode, iInputFlowNode2;
					OrderBy: iInputFlowNode;
					Definition: {
						{ iNode | epNodeType( iNode ) = epNodeTypeInputFlow or epNodeType( iNode ) = epNodeTypeInOutputFlow }
					}
				}
				Parameter pInputFlowNodeMinFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMaxFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeFixed {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMinPositiveRateChangeFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMaxPositiveRateChangeFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMinNegativeRateChangeFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMaxNegativeRateChangeFlow {
					IndexDomain: (iInputFlowNode,iTime);
				}
				Parameter pInputFlowNodeMinStayTimeSteadyState {
					IndexDomain: (iInputFlowNode,iTime);
					Range: integer;
				}
				Parameter pInputFlowNodeCostPerUnit {
					IndexDomain: (iInputFlowNode,iTime);
				}
			}
		}
		Section Output_Flow_Node {
			DeclarationSection Output_Flow_Declaration {
				Set sOutputFlowNodes {
					SubsetOf: sNodes;
					Index: iOutputFlowNode, iOutputFlowNode2;
					OrderBy: iOutputFlowNode;
					Definition: {
						{ iNode | epNodeType( iNode ) = epNodeTypeOutputFlow or epNodeType( iNode ) = epNodeTypeInOutputFlow }
					}
				}
				Parameter pOutputFlowFixed {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMinFlow {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMaxFlow {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMinPositiveRateChangeFlow {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMaxPositiveRateChangeFlow {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMinNegativeRateChangeFlow {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMaxNegativeRateChangeFlow {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMinStayTimeSteadyState {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: integer;
				}
				Parameter pOutputFlowNodeValuePerUnit {
					IndexDomain: (iOutputFlowNode,iTime);
				}
			}
		}
		Section InOutput_Flow_Node {
			DeclarationSection InOutput_Flow_Declaration {
				Set sInOutputFlowNodes {
					SubsetOf: sNodes;
					Index: iInOutputFlowNode, iInOutputFlowNode2;
					OrderBy: iInOutputFlowNode;
					Definition: {
						{ iNode | epNodeType( iNode ) = epNodeTypeInOutputFlow }
					}
				}
			}
		}
		Section Box_ {
			DeclarationSection Box_declaration {
				Set sBoxes {
					SubsetOf: sArcsAndBoxes;
					Index: iBox, iBox2;
					OrderBy: iBox;
				}
				Set sBoxConnectionNodes {
					SubsetOf: sNodes;
					Index: iBoxConnectionNode;
					Definition: {
						{ gdm::iNode | gdm::epNodeType( gdm::iNode ) = epNodeTypeBoxConnection }
					}
				}
				ElementParameter epBoxNode {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: sNodes;
					Comment: "Change range to general nodes, assert that type is coldboxconnection";
				}
				Parameter pBoxMinFlow {
					IndexDomain: (iBox, iBoxNodeConnectionType, gdm::itime);
				}
				Parameter pBoxMaxFlow {
					IndexDomain: (iBox, iBoxNodeConnectionType, gdm::itime);
				}
				Parameter pBoxMinPositiveRateChangeFlow {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
				}
				Parameter pBoxMaxPositiveRateChangeFlow {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
				}
				Parameter pBoxMinNegativeRateChangeFlow {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
				}
				Parameter pBoxMaxNegativeRateChangeFlow {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
				}
				Parameter pBoxMinStayTimeSteadyStateFlow {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Range: integer;
				}
				Parameter pBoxParameter1Pres {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: free;
				}
				Parameter pBoxParameter2Pres {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: free;
				}
				Parameter pBoxParameter3Pres {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: free;
				}
				Parameter p01BoxPressureActive {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: binary;
					Definition: {
						
						(pBoxParameter1Pres(iBox,iBoxNodeConnectionType)+
						 pBoxParameter2Pres(iBox,iBoxNodeConnectionType)+
						 pBoxParameter3Pres(iBox,iBoxNodeConnectionType))
						 <>
						 0
					}
				}
				ElementParameter epBoxEnergyContract {
					IndexDomain: (iBox);
					Range: sEnergyContract;
				}
				ElementParameter epBoxAuxPowerGroup {
					IndexDomain: (iBox);
					Range: sAuxPowerGroups;
				}
				Parameter p01BoxFlowSpecificEquation {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: binary;
				}
				Parameter p01BoxLinearEquationData {
					IndexDomain: iBox;
					Range: binary;
				}
				Parameter p01BoxLinearEquationModel {
					IndexDomain: iBox;
					Range: binary;
				}
			}
			DeclarationSection Box_Type_declaration {
				Set sBoxTypes {
					Index: iBoxType;
					OrderBy: iBoxType;
				}
				ElementParameter epBoxType {
					IndexDomain: iBox;
					Range: sBoxTypes;
				}
			}
			DeclarationSection Box_Node_connection_type_Declaration {
				Set sBoxNodeConnectionTypes {
					Index: iBoxNodeConnectionType;
					Definition: {
						
						sBoxNodeConnectionTypeInputs + sBoxNodeConnectionTypeOutputs
					}
				}
				Set sBoxNodeConnectionTypeInputs {
					SubsetOf: sBoxNodeConnectionTypes;
					Index: iBoxNodeConnectionTypeInput;
					OrderBy: iBoxNodeConnectionTypeInput;
				}
				Set sBoxNodeConnectionTypeOutputs {
					SubsetOf: sBoxNodeConnectionTypes;
					Index: iBoxNodeConnectionTypeOutput;
					OrderBy: iBoxNodeConnectionTypeOutput;
				}
				ElementParameter epBoxNodeConnectionTypeInput1 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input1");
				}
				ElementParameter epBoxNodeConnectionTypeInput2 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input2");
				}
				ElementParameter epBoxNodeConnectionTypeInput3 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input3");
				}
				ElementParameter epBoxNodeConnectionTypeInput4 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input4");
				}
				ElementParameter epBoxNodeConnectionTypeInput5 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input5");
				}
				ElementParameter epBoxNodeConnectionTypeInput6 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input6");
				}
				ElementParameter epBoxNodeConnectionTypeInput7 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input7");
				}
				ElementParameter epBoxNodeConnectionTypeInput8 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input8");
				}
				ElementParameter epBoxNodeConnectionTypeInput9 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input9");
				}
				ElementParameter epBoxNodeConnectionTypeInput10 {
					Range: sBoxNodeConnectionTypeInputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeInputs,"Input10");
				}
				ElementParameter epBoxNodeConnectionTypeOutput1 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output1");
				}
				ElementParameter epBoxNodeConnectionTypeOutput2 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output2");
				}
				ElementParameter epBoxNodeConnectionTypeOutput3 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output3");
				}
				ElementParameter epBoxNodeConnectionTypeOutput4 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output4");
				}
				ElementParameter epBoxNodeConnectionTypeOutput5 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output5");
				}
				ElementParameter epBoxNodeConnectionTypeOutput6 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output6");
				}
				ElementParameter epBoxNodeConnectionTypeOutput7 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output7");
				}
				ElementParameter epBoxNodeConnectionTypeOutput8 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output8");
				}
				ElementParameter epBoxNodeConnectionTypeOutput9 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output9");
				}
				ElementParameter epBoxNodeConnectionTypeOutput10 {
					Range: sBoxNodeConnectionTypeOutputs;
					Definition: stringtoelement(sBoxNodeConnectionTypeOutputs,"Output10");
				}
			}
			DeclarationSection Box_parameters_Declaration {
				Set sBoxParameters {
					Index: iBoxParameter;
				}
				ElementParameter epBoxTypeParameter {
					IndexDomain: iBoxParameter;
					Range: sBoxTypes;
				}
				Parameter pBoxParameterValue {
					IndexDomain: (iBox,iBoxParameter);
				}
			}
			Section Coldbox {
				DeclarationSection Alias_Coldbox_connection_type_Declaration {
					Set sColdboxNodeConnectionTypes {
						SubsetOf: sBoxNodeConnectionTypes;
						Index: iColdboxNodeConnectionType;
						Definition: {
							{ epColdboxNodeConnectionTypeAirHp,
							epColdboxNodeConnectionTypeAirMp,
							epColdboxNodeConnectionTypeLiNAssist,
							epColdboxNodeConnectionTypeLOxAssist,
							epColdboxNodeConnectionTypeLOx,
							epColdboxNodeConnectionTypeHpGOx,
							epColdboxNodeConnectionTypeMpGOx,
							epColdboxNodeConnectionTypeLpGOx,
							epColdboxNodeConnectionTypeLiN,
							epColdboxNodeConnectionTypeHpGaN,
							epColdboxNodeConnectionTypeMpGaN,
							epColdboxNodeConnectionTypeLpGaN,
							epColdboxNodeConnectionTypeLAr
							 }
						}
					}
					StringParameter spColdboxNodeConnectionName {
						IndexDomain: iColdBoxNodeConnectionType;
						Definition: {
							if iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeAirHp then
								"AirHp"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeAirMp then
								"AirMp"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLinAssist then
								"Lin_Assist"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLoxAssist then
								"Lox Assist"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLox then
								"Lox"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeHpGox then
								"HpGox"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeMpGox then
								"MpGox"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLpGox then
								"LpGox"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLin then
								"Lin"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeHpGan then
								"HpGan"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeMpGan then
								"MpGan"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLpGan then
								"LpGan"
							elseif iColdBoxNodeConnectionType = epColdboxNodeConnectionTypeLar then
								"Lar"
							
							endif
						}
					}
					ElementParameter epColdboxNodeConnectionTypeAirHp {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeInput1;
					}
					ElementParameter epColdboxNodeConnectionTypeAirMp {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeInput2;
					}
					ElementParameter epColdboxNodeConnectionTypeLiNAssist {
						Range: sBoxNodeConnectionTypes;
						Definition: {
							
							epBoxNodeConnectionTypeInput3
						}
					}
					ElementParameter epColdboxNodeConnectionTypeLOxAssist {
						Range: sBoxNodeConnectionTypes;
						Definition: {
							
							epBoxNodeConnectionTypeInput4
						}
					}
					ElementParameter epColdboxNodeConnectionTypeLOx {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput1;
					}
					ElementParameter epColdboxNodeConnectionTypeHpGOx {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput2;
					}
					ElementParameter epColdboxNodeConnectionTypeMpGOx {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput3;
					}
					ElementParameter epColdboxNodeConnectionTypeLpGOx {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput4;
					}
					ElementParameter epColdboxNodeConnectionTypeLiN {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput5;
					}
					ElementParameter epColdboxNodeConnectionTypeHpGaN {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput6;
					}
					ElementParameter epColdboxNodeConnectionTypeMpGaN {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput7;
					}
					ElementParameter epColdboxNodeConnectionTypeLpGaN {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput8;
					}
					ElementParameter epColdboxNodeConnectionTypeLAr {
						Range: sBoxNodeConnectionTypes;
						Definition: epBoxNodeConnectionTypeOutput9;
					}
				}
				DeclarationSection Coldbox_type_Declaration {
					ElementParameter epBoxTypeColdbox {
						Range: sBoxTypes;
						Definition: stringtoelement(sBoxTypes,"Coldbox");
					}
				}
				DeclarationSection Coldbox_Declaration {
					Set sColdboxes {
						SubsetOf: sBoxes;
						Index: iColdbox, iColdbox2;
						OrderBy: iColdbox;
						Definition: {
							{ iBox | epBoxType( iBox ) = epBoxTypeColdBox }
						}
					}
					Parameter pColdboxMaxO2ContentInWaste {
						IndexDomain: iColdbox;
					}
					Parameter pColdboxMaxLpGanVent {
						IndexDomain: iColdbox;
						Definition: {
							! (0,78 * Max total air flow)
							 pN2Content 
							 * 
							 Max(iTime, pboxMaxFlow(iColdbox,epColdboxNodeConnectionTypeAirHp  , iTime) 
							 + 
							 pboxMaxFlow(iColdbox,epColdboxNodeConnectionTypeAirMp  , iTime))
						}
					}
					Parameter pColdboxLosses {
						IndexDomain: iColdbox;
						Range: nonnegative;
					}
					Parameter pColdboxWasteToAirRatio {
						IndexDomain: iColdbox;
						Range: nonnegative;
						Default: 0;
					}
					Parameter pColdboxMinRectifPower {
						IndexDomain: iColdbox;
					}
					Parameter pColdboxMaxRectifPower {
						IndexDomain: iColdbox;
					}
					Parameter pColdboxLinAssistColdStandby {
						IndexDomain: iColdbox;
					}
					ElementParameter epColdboxProcess {
						IndexDomain: iColdbox;
						Range: sColdboxProcess;
					}
					Parameter p01ColdboxTypeSpecificEquation {
						IndexDomain: (iColdboxProcess,iColdboxSpecificEquation);
						Range: binary;
					}
				}
				DeclarationSection Coldbox_Internal_flows_declaration {
					Set sColdboxInternalFlows {
						Index: iColdboxInternalFlow;
						OrderBy: iColdboxInternalFlow;
						Comment: "data{airmp,airhp,lpgox,hpgox,mpgox,hpgan,mpgan,lpgan,lox,lin,lar}";
					}
					ElementParameter epTotalAir {
						Range: sColdboxInternalFlows;
						Definition: stringtoelement(sColdboxInternalFlows,"total_air");
					}
					ElementParameter epInternalLiquid {
						Range: sColdboxInternalFlows;
						Definition: stringtoelement(sColdboxInternalFlows,"internal_liquid");
					}
					ElementParameter epAirTurbineLp {
						Range: sColdboxInternalFlows;
						Definition: stringtoelement(sColdboxInternalFlows,"air_turbine_lp");
					}
					ElementParameter epGoxToWaste {
						Range: sColdboxInternalFlows;
						Definition: stringtoelement(sColdboxInternalFlows,"gox_to_waste");
					}
					Parameter pColdboxMinInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMaxInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMinPositiveRateChangeInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMaxPositiveRateChangeInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMinNegativeRateChangeInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMaxNegativeRateChangeInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					}
					Parameter pColdboxMinStayTimeSteadyStateInternalFlow {
						IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
						Range: integer;
					}
					Parameter p01ColdboxInternalFlowSpecificEquation {
						IndexDomain: (iColdbox,iColdboxInternalFlow);
						Range: binary;
					}
				}
				DeclarationSection Coldbox_process_type_Declaration {
					Set sColdboxProcess {
						Index: iColdboxProcess;
						OrderBy: iColdboxProcess;
					}
					ElementParameter epColdboxProcessAokGok {
						Range: sColdboxProcess;
						Definition: stringtoelement(sColdboxProcess,"AokGok");
					}
					ElementParameter epColdboxProcessGas {
						Range: sColdboxProcess;
						Definition: stringtoelement(sColdboxProcess,"Gas");
					}
					Set sColdboxSpecificEquations {
						Index: iColdboxSpecificEquation;
						OrderBy: iColdboxSpecificEquation;
					}
					ElementParameter epColdboxSpecificEquationMaterialBalance {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"MaterialBalance");
					}
					ElementParameter epColdboxSpecificEquationPowerBalance {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"PowerBalance");
					}
					ElementParameter epColdboxSpecificEquationLiquidBalance {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"LiquidBalance");
					}
					ElementParameter epColdboxSpecificEquationRectifPower {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"RectifPower");
					}
					ElementParameter epColdboxSpecificEquationRecovery {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"Recovery");
					}
					ElementParameter epColdboxSpecificEquationPressure {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"Pressure");
					}
					ElementParameter epColdboxSpecificEquationNitrogenMode {
						Range: sColdboxSpecificEquations;
						Definition: stringtoelement(sColdboxSpecificEquations,"NitrogenMode");
					}
				}
				DeclarationSection Coldbox_parameter_Declaration {
					Set sColdboxParameters {
						SubsetOf: sBoxParameters;
						Index: iColdboxParameter;
						OrderBy: iColdboxParameter;
						Definition: {
							{iBoxParameter | epBoxTypeParameter(gdm::iBoxParameter)=epBoxTypeColdbox }
						}
						Comment: {
							"{\'Pumping process par1\', \'Pumping process par2\', \'Pumping process par3\',
							 \'Recovery O2 par1\', \'Recovery O2 par2\', \'Recovery O2 par3\', \'Recovery O2 par4\', \'Recovery O2 lambda\',
							 \'Recovery AR par1\', \'Recovery AR par2\', \'Recovery AR par3\', \'Recovery AR par4\', \'Recovery AR lambda\'
							}"
						}
					}
					ElementParameter epColdboxPumpingProcessParameter1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par1");
					}
					ElementParameter epColdboxPumpingProcessParameter2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par2");
					}
					ElementParameter epColdboxPumpingProcessParameter3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par3");
					}
					ElementParameter epColdboxPumpingProcessParameter4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par4");
					}
					ElementParameter epColdboxPumpingProcessParameter5 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par5");
					}
					ElementParameter epColdboxRecoveryO2Parameter1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par1");
					}
					ElementParameter epColdboxRecoveryO2Parameter2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par2");
					}
					ElementParameter epColdboxRecoveryO2Parameter3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par3");
					}
					ElementParameter epColdboxRecoveryO2Parameter4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par4");
					}
					ElementParameter epColdboxRecoveryO2ParameterLambda {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 lambda");
					}
					ElementParameter epColdboxRecoveryArParameter1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par1");
					}
					ElementParameter epColdboxRecoveryArParameter2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par2");
					}
					ElementParameter epColdboxRecoveryArParameter3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par3");
					}
					ElementParameter epColdboxRecoveryArParameter4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par4");
					}
					ElementParameter epColdboxRecoveryArParameterLambda {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR lambda");
					}
					ElementParameter epColdboxTurbInsufflationManualControl {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"TurbInsufflationManualControl");
					}
					ElementParameter epColdboxTurbInsufflationLPLevelControl {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"TurbInsufflationLPLevelControl");
					}
					ElementParameter epColdboxTurbInsufflationRemoteControl {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"TurbInsufflationRemoteControl");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 1");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 2");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 3");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 4");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear5 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 5");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear6 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 6");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear7 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 7");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear8 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 8");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear9 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 9");
					}
					ElementParameter epColdboxPumpingProcessParameterLinear10 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Pumping process par linear 10");
					}
					ElementParameter epColdboxRecoveryO2ParameterLinear1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par Linear 1");
					}
					ElementParameter epColdboxRecoveryO2ParameterLinear2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par Linear 2");
					}
					ElementParameter epColdboxRecoveryO2ParameterLinear3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par Linear 3");
					}
					ElementParameter epColdboxRecoveryO2ParameterLinear4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery O2 par Linear 4");
					}
					ElementParameter epColdboxRecoveryArParameterLinear1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par Linear 1");
					}
					ElementParameter epColdboxRecoveryArParameterLinear2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par Linear 2");
					}
					ElementParameter epColdboxRecoveryArParameterLinear3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par Linear 3");
					}
					ElementParameter epColdboxRecoveryArParameterLinear4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Recovery AR par Linear 4");
					}
					ElementParameter epColdboxNitrogenModeParameter1 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Nitrogen Mode par1");
					}
					ElementParameter epColdboxNitrogenModeParameter2 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Nitrogen Mode par2");
					}
					ElementParameter epColdboxNitrogenModeParameter3 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Nitrogen Mode par3");
					}
					ElementParameter epColdboxNitrogenModeParameter4 {
						Range: sColdboxParameters;
						Definition: stringtoelement(sColdboxParameters,"Nitrogen Mode par4");
					}
				}
			}
		}
		Section Backup_Arc {
			DeclarationSection Backup_Arc_Declaration {
				Set sBackupArcs {
					SubsetOf: sArcs;
					Index: iBackupArc, iBackupArc2;
					OrderBy: iBackupArc;
					Definition: {
						
						{ iArc | epArcType( iArc ) = epArcTypeBackup }
					}
				}
				ElementParameter epBackupEnergyContract {
					IndexDomain: (iBackupArc);
					Range: sEnergyContract;
				}
				Parameter pBackupMinFlow {
					IndexDomain: (iBackupArc,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBackupMaxFlow {
					IndexDomain: (iBackupArc,iTime);
					Range: nonnegative;
					Default: 100000;
				}
				Parameter pBackupMinPositiveRateChangeFlow {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMaxPositiveRateChangeFlow {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMinNegativeRateChangeFlow {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMaxNegativeRateChangeFlow {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMinStayTimeSteadyState {
					IndexDomain: (iBackupArc,iTime);
					Range: integer;
				}
				Parameter pBackupPcFlash {
					IndexDomain: (iBackupArc,iTime) | pBackupMaxFlow(iBackupArc,iTime) and not gdm::p01BackupFlashSpecificEquation(gdm::iBackupArc);
					Range: [0, 1];
					Definition: {
						
						pBackupPowerPump(iBackupArc) / ( pBackupMaxFlow(iBackupArc,iTime) * pdHvaporization(epTankLiquidProduct(epNodeFrom(iBackupArc))))
					}
				}
				Parameter pBackupPowerPump {
					IndexDomain: iBackupArc;
				}
				Parameter p01BackupFlashSpecificEquation {
					IndexDomain: (iBackupArc);
					Range: binary;
				}
			}
		}
		Section Buffer_Node {
			DeclarationSection Buffer_Declaration {
				Set sBufferNodes {
					SubsetOf: sNodes;
					Index: iBufferNode, iBufferNode2;
					OrderBy: iBufferNode;
					Definition: {
						{ iNode | epNodeType( iNode ) = epNodeTypeBuffer }
					}
				}
				Parameter pBufferMinPressure {
					IndexDomain: (iBufferNode,iTime);
				}
				Parameter pBufferMaxPressure {
					IndexDomain: (iBufferNode,iTime);
				}
				Parameter pBufferVolume {
					IndexDomain: (iBufferNode);
				}
				Parameter pBufferInitialPressure {
					IndexDomain: iBufferNode;
					Range: free;
					Default: 0;
				}
				Parameter pBufferGasValue {
					IndexDomain: iBufferNode;
				}
				Parameter pBufferInitialAccu {
					IndexDomain: iBufferNode;
					Range: free;
					Default: 0;
				}
			}
		}
		Section Tank {
			DeclarationSection Tank_Declaration {
				Set sTankNodes {
					SubsetOf: sNodes;
					Index: iTankNode, iTankNode2;
					OrderBy: iTankNode;
					Definition: {
						{ iNode | epNodeType( iNode ) = epNodeTypeTank }
					}
				}
				ElementParameter epTankLiquidProduct {
					IndexDomain: iTankNode;
					Range: sProducts;
				}
				Parameter pTankInitialLevel {
					IndexDomain: iTankNode;
				}
				Parameter pTankStorageCapacity {
					IndexDomain: iTankNode;
				}
				Parameter pTankMinLevel {
					IndexDomain: (iTankNode,iTime);
					Range: free;
					Comment: "Note: We could index this over tank if there is only one tank per product";
				}
				Parameter pTankMaxLevel {
					IndexDomain: (iTankNode,iTime);
					Range: nonnegative;
				}
				Parameter p01TankEnableLevelConstraints {
					IndexDomain: (iTankNode,iTime);
					Range: binary;
					Comment: "0";
				}
				Parameter pTankLiquidValue {
					IndexDomain: iTankNode;
				}
				Parameter p01TankFlashSpecificEquation {
					IndexDomain: (iTankNode);
					Range: binary;
					Comment: "0";
				}
			}
		}
		Section Compressor {
			DeclarationSection Compressor_Declaration {
				Set sCompressorArcs {
					SubsetOf: sArcs;
					Index: iCompressorArc, iCompressorArc2;
					OrderBy: iCompressorArc;
					Definition: {
						{ iArc | epArcType( iArc ) = epArcTypeCompressor }
					}
				}
				Set sCompressorDependencies {
					Index: iCompressorDependency, iCompressorDependency2;
					OrderBy: iCompressorDependency;
				}
				ElementParameter epCompressorEnergyContract {
					IndexDomain: (iCompressorArc);
					Range: sEnergyContract;
				}
				ElementParameter epCompressorMapSpecial_1 {
					IndexDomain: iCompressorDependency;
					Range: sCompressorArcs;
					Comment: "maps special compressors to compressors to define which compressors need to run simultaneously";
				}
				ElementParameter epCompressorMapSpecial_2 {
					IndexDomain: iCompressorDependency;
					Range: sCompressorArcs;
					Comment: "maps special compressors to compressors to define which compressors need to run simultaneously";
				}
				Parameter p01CompressorRunTogether {
					IndexDomain: (iCompressorDependency);
					Range: binary;
					Default: 0;
					Comment: {
						"1 must run together
						0 cannot run together"
					}
				}
				Parameter pCompressorMinFlow {
					IndexDomain: (iCompressorArc,iTime);
					Range: nonnegative;
				}
				Parameter pCompressorMaxFlow {
					IndexDomain: (iCompressorArc,iTime);
					Range: nonnegative;
				}
				Parameter pCompressorMinPositiveRateChangeFlow {
					IndexDomain: (iCompressorArc,iTime);
				}
				Parameter pCompressorMaxPositiveRateChangeFlow {
					IndexDomain: (iCompressorArc,iTime);
				}
				Parameter pCompressorMinNegativeRateChangeFlow {
					IndexDomain: (iCompressorArc,iTime);
				}
				Parameter pCompressorMaxNegativeRateChangeFlow {
					IndexDomain: (iCompressorArc,iTime);
				}
				Parameter pCompressorMinStayTimeSteadyState {
					IndexDomain: (iCompressorArc,iTime);
					Range: integer;
				}
				Parameter pCompressorMaxPower {
					IndexDomain: (iCompressorArc,iTime);
				}
				Parameter pCompressorMaxCompressionRatio {
					IndexDomain: iCompressorArc;
				}
				ElementParameter epCompressorAuxPowerGroup {
					IndexDomain: iCompressorArc;
					Range: sAuxPowerGroups;
				}
				ElementParameter epCompressorCoolingTower {
					IndexDomain: iCompressorArc;
					Range: sCoolingTowers;
				}
				Parameter pCompressorParameterValue {
					IndexDomain: (iCompressorArc,iCompressorParameter);
				}
				Parameter p01CompressorPowerSpecificEquation {
					IndexDomain: iCompressorArc;
					Range: binary;
				}
				Parameter p01CompressorLinearEquationData {
					IndexDomain: iCompressorArc;
					Range: binary;
				}
				Parameter p01CompressorLinearEquationModel {
					IndexDomain: iCompressorArc;
					Range: binary;
				}
			}
			DeclarationSection Compressor_parameter_Declaration {
				Set sCompressorParameters {
					Index: iCompressorParameter;
					OrderBy: iCompressorParameter;
					Comment: "{\'Eff par 1\',\'Eff par 2\',\'Eff par 3\',\'Eff par 4\',\'Eff par 5\'}";
				}
				ElementParameter epCompressorParameterEff1 {
					Range: sCompressorParameters;
					Definition: stringtoelement(sCompressorParameters,"Eff par 1");
				}
				ElementParameter epCompressorParameterEff2 {
					Range: sCompressorParameters;
					Definition: stringtoelement(sCompressorParameters,"Eff par 2");
				}
				ElementParameter epCompressorParameterEff3 {
					Range: sCompressorParameters;
					Definition: stringtoelement(sCompressorParameters,"Eff par 3");
				}
				ElementParameter epCompressorParameterEff4 {
					Range: sCompressorParameters;
					Definition: stringtoelement(sCompressorParameters,"Eff par 4");
				}
				ElementParameter epCompressorParameterEff5 {
					Range: sCompressorParameters;
					Definition: stringtoelement(sCompressorParameters,"Eff par 5");
				}
				ElementParameter epCompressorParameterLinear1 {
					Range: sCompressorParameters;
					Definition: {
						
						stringtoelement(sCompressorParameters,"Linear par 1")
					}
				}
				ElementParameter epCompressorParameterLinear2 {
					Range: sCompressorParameters;
					Definition: {
						
						stringtoelement(sCompressorParameters,"Linear par 2")
					}
				}
				ElementParameter epCompressorParameterLinear3 {
					Range: sCompressorParameters;
					Definition: {
						
						stringtoelement(sCompressorParameters,"Linear par 3")
					}
				}
				ElementParameter epCompressorParameterLinear4 {
					Range: sCompressorParameters;
					Definition: {
						
						stringtoelement(sCompressorParameters,"Linear par 4")
					}
				}
				ElementParameter epCompressorParameterLinear5 {
					Range: sCompressorParameters;
					Definition: {
						
						stringtoelement(sCompressorParameters,"Linear par 5")
					}
				}
			}
		}
		Section Liquefier {
			DeclarationSection Liquefier_Declaration {
				Set sLiquefierArcs {
					SubsetOf: sArcs;
					Index: iLiquefierArc, iLiquefierArc2;
					OrderBy: iLiquefierArc;
					Definition: {
						{ iArc | epArcType( iArc ) = epArcTypeLiquefier }
					}
				}
				Set sCycleArcs {
					SubsetOf: sArcs;
					Index: iCycleArc;
					OrderBy: iCycleArc;
					Definition: {
						{ iArc | epArcType(iArc) = epArcTypeCycle }
					}
					Comment: {
						"!flow(liquefier_cycle(liq))*log(Pres(node_to(liquefier_cycle(liq)))/pres(node_from(liquefier_cycle(liq))))=
						!liq_perf_param1(liq)*flow(liq)"
					}
				}
				ElementParameter epLiquefierCalculationMode {
					IndexDomain: (iLiquefierArc);
					Range: sLiquefierCalculationModes;
				}
				ElementParameter epLiquefierCycle {
					IndexDomain: iLiquefierArc|epLiquefierCalculationMode(iLiquefierArc) = epLiquefierCalculationModeAdvanced;
					Range: sCycleArcs;
				}
				ElementParameter epLiquefierCompressorFeed {
					IndexDomain: iLiquefierArc|epLiquefierCalculationMode(iLiquefierArc) = epLiquefierCalculationModeAdvanced;
					Range: sCompressorArcs;
					Comment: "Used to be called cycle";
				}
				ElementParameter epLiquefierCompressorCycle {
					IndexDomain: iLiquefierArc|epLiquefierCalculationMode(iLiquefierArc) = epLiquefierCalculationModeAdvanced;
					Range: sCompressorArcs;
					Comment: "Used to be called cycle";
				}
				ElementParameter epLiquefierEnergyContract {
					IndexDomain: (iLiquefierArc);
					Range: sEnergyContract;
				}
				Parameter pLiquefierParameterValue {
					IndexDomain: (iLiquefierArc,iLiquefierParameter);
				}
				Parameter pLiquefierMinFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMaxFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMinPositiveRateChangeFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMaxPositiveRateChangeFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMinNegativeRateChangeFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMaxNegativeRateChangeFlow {
					IndexDomain: (iLiquefierArc,iTime);
				}
				Parameter pLiquefierMinStayTimeSteadyState {
					IndexDomain: (iLiquefierArc,iTime);
					Range: integer;
				}
				Parameter pLiquefierMaxPower {
					IndexDomain: (iLiquefierArc,iTime);
				}
				ElementParameter epLiquefierCoolingTower {
					IndexDomain: iLiquefierArc;
					Range: sCoolingTowers;
				}
				ElementParameter epLiquefierAuxPowerGroup {
					IndexDomain: iLiquefierArc;
					Range: sAuxPowerGroups;
				}
				Parameter p01LiquefierPowerSpecificEquation {
					IndexDomain: iLiquefierArc;
					Range: binary;
					Default: 1;
				}
				Parameter p01LiquefierLinearEquationData {
					IndexDomain: iLiquefierArc;
					Range: binary;
				}
				Parameter p01LiquefierLinearEquationModel {
					IndexDomain: iLiquefierArc;
					Range: binary;
				}
			}
			DeclarationSection Liquefier_parameter_Declaration {
				Set sLiquefierParameters {
					Index: iLiquefierParameter;
					Comment: "{\'Perf par1\',\'Perf par2\',\'Perf par3\',\'Perf par4\'}";
				}
				ElementParameter epLiquefierParameterPerf1 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par1");
				}
				ElementParameter epLiquefierParameterPerf2 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par2");
				}
				ElementParameter epLiquefierParameterPerf3 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par3");
				}
				ElementParameter epLiquefierParameterPerf4 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par4");
				}
				ElementParameter epLiquefierParameterPerf5 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par5");
				}
				ElementParameter epLiquefierParameterPerfLinear1 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par Linear 1");
				}
				ElementParameter epLiquefierParameterPerfLinear2 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par Linear 2");
				}
				ElementParameter epLiquefierParameterPerfLinear3 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par Linear 3");
				}
				ElementParameter epLiquefierParameterPerfLinear4 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Perf par Linear 4");
				}
				ElementParameter epRatioCompressorCycle {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Ratio pres");
				}
				ElementParameter epPinCompressorCycleParam1 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Pres par1");
				}
				ElementParameter epPinCompressorCycleParam2 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Pres par2");
				}
				ElementParameter epPinCompressorCycleParam3 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Pres par3");
				}
				ElementParameter epPinCompressorCycleParam4 {
					Range: sLiquefierParameters;
					Definition: stringtoelement(sLiquefierParameters,"Pres par4");
				}
			}
			DeclarationSection Liquefier_calculation_mode_Declaration {
				Set sLiquefierCalculationModes {
					Index: iLiquefierCalculationMode;
					OrderBy: iLiquefierCalculationMode;
					Comment: "data{basic,advanced}";
				}
				ElementParameter epLiquefierCalculationModeBasic {
					Range: sLiquefierCalculationModes;
					Definition: stringtoelement(sLiquefierCalculationModes,"basic");
				}
				ElementParameter epLiquefierCalculationModeAdvanced {
					Range: sLiquefierCalculationModes;
					Definition: stringtoelement(sLiquefierCalculationModes,"advanced");
				}
			}
		}
		Section Pipe {
			DeclarationSection Pipe_Declaration {
				Set sPipeArcs {
					SubsetOf: sArcs;
					Index: iPipeArc, iPipeArc2;
					OrderBy: iPipeArc;
					Definition: {
						{ iArc | epArcType( iArc ) = epArcTypePipe }
					}
				}
				ElementParameter epPipeCalculationMode {
					IndexDomain: iPipeArc;
					Range: sPipeCalculationMode;
				}
				Parameter pPipeLinearPressureDropParam1 {
					IndexDomain: iPipeArc;
				}
				Parameter pPipePressureDropParam1 {
					IndexDomain: iPipeArc;
					InitialData: 0;
				}
				Parameter pPipeFrictionFactor {
					IndexDomain: iPipeArc;
				}
				Parameter pPipeLength {
					IndexDomain: iPipeArc;
				}
				Parameter pPipeDiameter {
					IndexDomain: iPipeArc;
				}
				ElementParameter epPipeGasType {
					IndexDomain: iPipeArc;
					Range: sProducts;
				}
				Parameter pPipeEfficiency {
					IndexDomain: iPipeArc;
				}
				Parameter pPipeRoughness {
					IndexDomain: iPipeArc;
				}
				Parameter p01PipePressureDropSpecificEquation {
					IndexDomain: iPipeArc;
					Range: binary;
				}
				Parameter p01PipeFrictionFactorSpecificCorrelation {
					IndexDomain: iPipeArc;
					Range: binary;
				}
				Parameter p01PipeLinearEquationModel {
					IndexDomain: iPipeArc;
					Range: binary;
				}
				Parameter pPipeCalculatedArea {
					IndexDomain: iPipeArc;
					Definition: {
						
						3.1416 * (pPipeDiameter(iPipeArc)/2)^2
					}
				}
			}
			DeclarationSection Pipe_calculation_mode_Declaration {
				Set sPipeCalculationMode {
					Index: iPipeCalculationMode;
				}
				ElementParameter epPipeCalculationModeNoPressureDrop {
					Range: sPipeCalculationMode;
					Definition: stringtoelement(sPipeCalculationMode,"no_pressure_drop");
				}
				ElementParameter epPipeCalculationModeSimplified {
					Range: sPipeCalculationMode;
					Definition: stringtoelement(sPipeCalculationMode,"simplified_linear");
				}
				ElementParameter epPipeCalculationModeAdvanceQuadratic {
					Range: sPipeCalculationMode;
					Definition: stringtoelement(sPipeCalculationMode,"advanced_quadratic");
				}
				ElementParameter epPipeCalculationModeAdvancedConstantFF {
					Range: sPipeCalculationMode;
					Definition: stringtoelement(sPipeCalculationMode,"advanced_constant_ff");
				}
				ElementParameter epPipeCalculationModeAdvancedCalculatedFF {
					Range: sPipeCalculationMode;
					Definition: stringtoelement(sPipeCalculationMode,"advanced_calculated_ff");
				}
			}
		}
		Section Products {
			Set sProducts {
				Index: iProduct;
				OrderBy: iProduct;
				Comment: "should be read from database";
			}
			ElementParameter epProductN2 {
				Range: sProducts;
				Definition: stringtoelement(sProducts,"n2");
			}
			ElementParameter epProductO2 {
				Range: sProducts;
				Definition: stringtoelement(sProducts,"o2");
			}
			ElementParameter epProductAr {
				Range: sProducts;
				Definition: stringtoelement(sProducts,"ar");
			}
			ElementParameter epProductAir {
				Range: sProducts;
				Definition: stringtoelement(sProducts,"air");
			}
			DeclarationSection Gas_product_declaration {
				Parameter pMolecularWeight {
					IndexDomain: iProduct;
				}
				Parameter pViscosity {
					IndexDomain: (iProduct);
				}
				Parameter pCompressibility {
					IndexDomain: (iProduct);
				}
			}
			DeclarationSection Liquid_product_Declaration {
				Parameter pLiquidEqCoef {
					IndexDomain: iProduct;
					Range: nonnegative;
				}
				Parameter pLiquidMassToVolumeUnits {
					IndexDomain: iProduct;
				}
				Parameter pdHvaporization {
					IndexDomain: iProduct;
				}
			}
		}
		Section Valve {
			DeclarationSection Valve_Declaration {
				Set sValveArcs {
					SubsetOf: sArcs;
					Index: iValveArc, iValveArc2;
					OrderBy: iValveArc;
					Definition: {
						{ iArc | epArcType( iArc ) = epArcTypeValve }
					}
				}
				ElementParameter epValveControlMode {
					IndexDomain: (iValveArc,iTime);
					Range: sValveControlModes;
					Default: '';
				}
				Parameter pValveSetPoint {
					IndexDomain: (iValveArc,iTime);
					Default: 0;
				}
				Parameter pValveDeltaPressureMax {
					IndexDomain: iValveArc;
					Definition: {
						! Max((Pmax Up - Pmn down),(Pmax Down- Pmin UP))
						max(
							( pNodeMaxPressure( epNodefrom( iValveArc ) ) - pNodeMinPressure( epNodeTo( gdm::iValveArc ) ) ), 
							( pNodeMaxPressure( epNodeTo( iValveArc ) ) - pNodeMinPressure( epNodeFrom( iVAlveArc ) ) )
						)
					}
				}
				Parameter p01ValveLinearEquationModel {
					IndexDomain: iValveArc;
					Range: binary;
				}
			}
			DeclarationSection Valve_control_mode_Declaration {
				Set sValveControlModes {
					Index: iValveControlMode;
					Comment: "data{pressure_control,flow_control,remote_control,check_valve}";
				}
				ElementParameter epValveControlModePressureControl {
					Range: sValveControlModes;
					Definition: stringtoelement(sValveControlModes,"pressure_control");
				}
				ElementParameter epValveControlModeFlowControl {
					Range: sValveControlModes;
					Definition: stringtoelement(sValveControlModes,"flow_control");
				}
				ElementParameter epValveControlModeRemoteControl {
					Range: sValveControlModes;
					Definition: stringtoelement(sValveControlModes,"remote_control");
				}
				ElementParameter epValveControlModeCheckValve {
					Range: sValveControlModes;
					Definition: stringtoelement(sValveControlModes,"check_valve");
				}
				ElementParameter epValveControlModeOpenValve {
					Range: sValveControlModes;
					Definition: stringtoelement(sValveControlModes,"open_valve");
				}
				ElementParameter epValveControlModeOnOff {
					Range: sValveControlModes;
					Definition: stringtoelement(gdm::sValveControlModes,"OnOff_valve");
				}
			}
		}
		Section Scalars {
			DeclarationSection Scalar_Declaration {
				Parameter pEps1;
				Parameter pEps2 {
					Comment: "Epsilon value used in definition of value of coldbox separation and pump";
				}
				Parameter pN2Content;
				Parameter pO2Content;
				Parameter pArContent;
				Parameter pRconstant {
					Comment: "used in cCalcKwCompressor";
				}
				Parameter pTambient;
				Parameter pTreference;
				Parameter pPreference;
				Parameter pO2RecoveryMin;
				Parameter pO2RecoveryMax;
				Parameter pArRecoveryMin;
				Parameter pArRecoveryMax;
				Parameter pScaleFactorCompressorParam1 {
					Range: free;
				}
				Parameter pScaleFactorCompressorParam2 {
					Range: free;
				}
				Parameter pScaleFactorCompressorParam3 {
					Range: free;
				}
				Parameter pScaleFactorCompressorParam4 {
					Range: free;
				}
				Parameter pSIunitsToPressureUnits;
				Parameter pSIunitsToPowerUnits;
			}
		}
		Section Time {
			DeclarationSection Calendar_Declaration {
				StringParameter spBeginCalendar {
					Definition: {
						!"2016-01-01 00:00:00"
					}
				}
				StringParameter spBeginCalendarExcel;
				StringParameter spGranularityCalendar {
					Default: "second";
				}
				Parameter pGranularityFrequency {
					Range: integer;
					Default: 1;
				}
				StringParameter spEndCalendar {
					Definition: {
						!"2016-12-31 23:59:59"
					}
				}
				StringParameter spEndCalendarExcel;
				StringParameter spFormatCalendar {
					Definition: {
						if ( gdm::spGranularityCalendar = "second" ) then
							"%c%y-%m-%d %H:%M:%S"
						elseif ( gdm::spGranularityCalendar = "minute" ) then
							"%c%y-%m-%d %H:%M"
						elseif ( gdm::spGranularityCalendar = "hour" ) then
							"%c%y-%m-%d %H:%M"
						elseif ( gdm::spGranularityCalendar = "day" ) then
							"%c%y-%m-%d"
						elseif ( gdm::spGranularityCalendar = "week" ) then
							"%c%y-%W"
						elseif ( gdm::spGranularityCalendar = "month" ) then
							"%c%y-%m"
						elseif ( gdm::spGranularityCalendar = "year" ) then
							"%c%y"
						else
							"%c%y-%m-%d"
						endif;
					}
				}
				Parameter pHorizonMultiplyingFactor {
					Range: integer;
					Default: 1;
					Definition: {
						if ( spGranularityCalendar = "minute" ) then
							60 * pGranularityFrequency
						elseif ( spGranularityCalendar = "hour" ) then
							3600 * pGranularityFrequency
						elseif ( spGranularityCalendar = "day" ) then
							86400 * pGranularityFrequency
						elseif ( spGranularityCalendar = "week" ) then
							604800 * pGranularityFrequency
						elseif ( spGranularityCalendar = "month" ) then
							2628000 * pGranularityFrequency
						elseif ( spGranularityCalendar = "year" ) then
							31536000 * pGranularityFrequency
						else
							1
						endif;
					}
					Comment: {
						"day   ->s : #-># * 86400,
						hour  ->s : #-># * 3600,
						minute->s : #-># * 60,
						month ->s : #-># * 2628000,
						week  ->s : #-># * 604800,
						year  ->s : #-># * 31536000"
					}
				}
				Parameter pPeriodInHours {
					Range: nonnegative;
					Definition: pHorizonMultiplyingFactor/3600;
				}
				ElementParameter epFirstTimeUnit {
					Range: calHorizon;
					Definition: first( calHorizon );
				}
				ElementParameter epLastTimeUnit {
					Range: calHorizon;
					Definition: last( calHorizon );
				}
				ElementParameter epSelectedTimeUnit {
					Range: calHorizon;
				}
				Calendar calHorizon {
					Index: iTime, iTime2;
					Unit: gdm::pHorizonMultiplyingFactor * s;
					BeginDate: spBeginCalendar;
					EndDate: spEndCalendar;
					TimeslotFormat: spFormatCalendar;
				}
				Quantity SI_Time_Duration {
					BaseUnit: s;
					Conversions: {
						day   ->s : #-># * 86400,
						hour  ->s : #-># * 3600,
						minute->s : #-># * 60,
						month ->s : #-># * 2628000,
						week  ->s : #-># * 604800,
						year  ->s : #-># * 31536000
					}
					Comment: "Expresses the value for the duration of periods.";
				}
				Parameter pHoursToSeconds {
					Definition: 3600;
				}
			}
		}
		Section Operating_Modes {
			DeclarationSection Operating_Modes_Declaration {
				Set sOperatingModeElements {
					SubsetOf: sArcsAndBoxes;
					Index: iOperatingModeElement, iOperatingModeElement1;
					OrderBy: iOperatingModeElement;
					Definition: {
						
						{ iControlModeElement | epControlModeElement(gdm::iControlModeElement) = epOperatingMode }
					}
				}
				Set sOperatingModesAllowed {
					IndexDomain: (iOperatingModeElement,iTime);
					SubsetOf: sOperatingModes;
					Definition: {
						
						{ iOperatingMode | p01OperatingModeAllowed(gdm::iOperatingModeElement, gdm::iOperatingMode, gdm::iTime) }
					}
				}
				ElementParameter epOperatingModeForced {
					IndexDomain: (iOperatingModeElement,iTime);
					Range: sOperatingModesAllowed(iOperatingModeElement, iTime);
					Default: '';
				}
				Parameter p01OperatingModeAllowed {
					IndexDomain: (iOperatingModeElement,iOperatingMode,iTime);
					Range: binary;
				}
				Parameter p01OperatingModeForced {
					IndexDomain: (iOperatingModeElement,iOperatingMode,iTime);
					Range: binary;
					Definition: {
						if iOperatingMode = epOperatingModeForced(iOperatingModeElement, gdm::iTime) then
							1
						else
							0
						endif
					}
				}
				ElementParameter epOperatingModeInitialMode {
					IndexDomain: (iOperatingModeElement);
					Range: sOperatingModes;
				}
				Parameter pOperatingModeInitialMinTimeRemain {
					IndexDomain: iOperatingModeElement;
				}
				Parameter pOperatingModeInitialMaxTimeRemain {
					IndexDomain: iOperatingModeElement;
				}
				Parameter p01OperatingModeTransitionAllowed {
					IndexDomain: (iOperatingModeElement,iOperatingMode1,iOperatingMode2);
					Range: binary;
				}
				Parameter pOperatingModeMinStayTime {
					IndexDomain: (iOperatingModeElement,iOperatingMode1,iOperatingMode2);
				}
				Parameter pOperatingModeMaxStayTime {
					IndexDomain: (iOperatingModeElement,iOperatingMode1,iOperatingMode2);
					Default: 0;
				}
				Parameter pOperatingModeExtraPower {
					IndexDomain: (iOperatingModeElement,iOperatingMode);
				}
				Parameter p01OperatingModeUseSpecificDescription {
					IndexDomain: iOperatingModeElement;
					Range: binary;
				}
			}
			DeclarationSection Operating_Modes_Type {
				Set sOperatingModes {
					Index: iOperatingMode, iOperatingMode1, iOperatingMode2;
					OrderBy: iOperatingMode;
				}
				ElementParameter epOperatingModeTypeOn {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"on")
					}
				}
				ElementParameter epOperatingModeTypeOff {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"off")
					}
				}
				ElementParameter epOperatingModeTypeStart {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"start")
					}
				}
				ElementParameter epOperatingModeTypeUnloaded {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"unloaded")
					}
				}
				ElementParameter epOperatingModeTypeColdStandBy {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"cold-standby")
					}
				}
				ElementParameter epOperatingModeTypeCoolDown {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"cool-down")
					}
				}
				ElementParameter epOperatingModeTypeArgonStart {
					Range: sOperatingModes;
					Definition: {
						
						stringtoelement(sOperatingModes,"argon-start")
					}
				}
			}
		}
		Section Status_Modes {
			DeclarationSection Status_Modes_Declaration {
				Set sStatusModeElements {
					SubsetOf: sArcsAndBoxes;
					Index: iStatusModeElement, iStatusModeElement1;
					OrderBy: iStatusModeElement;
					Definition: {
						
						{ iControlModeElement | epControlModeElement(gdm::iControlModeElement) = epStatusMode }
					}
				}
				ElementParameter epStatusElement {
					IndexDomain: (iStatusModeElement,iTime);
					Range: sStatusModes;
				}
			}
			DeclarationSection Status_Modes_Type {
				Set sStatusModes {
					Index: iStatusMode, iStatusMode1;
					OrderBy: iStatusMode;
				}
				ElementParameter epStatusModeRun {
					Range: sStatusModes;
					Definition: stringtoelement(sStatusModes,"RUN");
				}
				ElementParameter epStatusModeUAvl {
					Range: sStatusModes;
					Definition: stringtoelement(sStatusModes,"U/AVL");
				}
				ElementParameter epStatusModeAvl {
					Range: sStatusModes;
					Definition: stringtoelement(sStatusModes,"AVL");
				}
			}
		}
	}
	Section Allowed_slack_declaration {
		Parameter p01AllowMultiStart;
		Parameter p01AllowSlackPressure;
		Parameter p01AllowPressurePenalty;
		Parameter p01AllowSlackLiquid;
		Parameter p01AllowSlackCompressorFlow;
		Parameter p01AllowSlackPowerBalance;
		Parameter p01AllowSlackPressureDrop {
			Default: 0;
		}
		Parameter p01AllowSlackReliefValveBuffer {
			Range: binary;
			Default: 0;
		}
		Procedure procLogSlackAllowed {
			Arguments: (spModel);
			Body: {
				if ( p01AllowPressurePenalty ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Pressure penalty allowed", spModel));
				            endif;
				            if ( p01AllowSlackCompressorFlow ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Slack on compressor flow allowed", spModel));
				            endif;
				            if ( p01AllowSlackLiquid ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Slack on liquid production allowed", spModel));
				            endif;
				            if ( p01AllowSlackPowerBalance ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Slack on power balance allowed", spModel));
				            endif;
				            if ( p01AllowSlackPressure ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Slack on min/max pressure for pipe allowed", spModel));
				            endif;
				            if ( p01AllowSlackPressureDrop ) 
				            then
				            	log_message::procLogInfo("",formatstring("%s: Slack on pressure drop allowed", spModel));
				            endif;
			}
			StringParameter spModel {
				Property: Input;
			}
		}
	}
	Section Read_write_procedures {
		StringParameter spModelVersion;
		StringParameter spConnectionString {
			Comment: "Specification of the database connection";
		}
		StringParameter spSchemaName {
			Default: "";
		}
		ElementParameter epSelectedDatabaseType {
			Range: cdl::sDatabaseTypes;
			Definition: stringToElement( cdl::sDatabaseTypes, "ORACLE SQL" );
		}
		StringParameter spExcelFileDisplay {
			Text: "Excel File";
			Default: "FileName";
		}
		Set sCounterOfTableList {
			Index: iCounterOfTableList;
			OrderBy: iCounterOfTableList;
			Definition: {
				{ 100 .. 199}
			}
		}
		Parameter pCountTableList {
			Range: integer;
			InitialData: 1;
			Comment: "EL: Count the number of initialisation of the library. To know how many time the list of table is initialised.";
		}
		StringParameter spReadErrorMessage {
			IndexDomain: iCounterOfTableList;
		}
		ElementParameter epCountTableList {
			Range: sCounterOfTableList;
			Definition: element(sCounterOfTableList, pCountTableList);
		}
		Section Declaration_Time_Dependent_Parameters {
			DeclarationSection Pressure_map_Time_Declaration {
				Parameter pPressureControlNodeSetpointConstant {
					IndexDomain: iPressureControlNode;
					Default: 0;
				}
				Parameter pPressureControlNodeSetpointTimeDependent {
					IndexDomain: (iPressureControlNode,iTime);
					Default: 0;
				}
				Parameter p01PressureControlNodeSetPointActiveTimeDependent {
					IndexDomain: (iPressureControlNode,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Buffer_Time_declaration {
				Parameter pBufferMinPressureConstant {
					IndexDomain: iBufferNode;
					Range: nonnegative;
					Unit: 0;
				}
				Parameter pBufferMaxPressureConstant {
					IndexDomain: iBufferNode;
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBufferMinPressureTimeDependent {
					IndexDomain: (iBufferNode,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBufferMaxPressureTimeDependent {
					IndexDomain: (iBufferNode,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter p01BufferActiveTimeDependent {
					IndexDomain: (iBufferNode,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Backup_Time_Declaration {
				Parameter pBackupMinFlowConstant {
					IndexDomain: (iBackupArc);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBackupMaxFlowConstant {
					IndexDomain: (iBackupArc);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBackupMinPositiveRateChangeFlowConstant {
					IndexDomain: iBackupArc;
					Default: 0;
				}
				Parameter pBackupMaxPositiveRateChangeFlowConstant {
					IndexDomain: iBackupArc;
					Default: 0;
				}
				Parameter pBackupMinNegativeRateChangeFlowConstant {
					IndexDomain: iBackupArc;
					Default: 0;
				}
				Parameter pBackupMaxNegativeRateChangeFlowConstant {
					IndexDomain: iBackupArc;
					Default: 0;
				}
				Parameter pBackupMinStayTimeSteadyStateConstant {
					IndexDomain: (iBackupArc);
					Range: integer;
				}
				Parameter pBackupMinFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBackupMaxFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pBackupMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Default: 0;
				}
				Parameter pBackupMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Range: integer;
				}
				Parameter p01BackupActiveTimeDependent {
					IndexDomain: (iBackupArc,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Box_Time_Declaration {
				Parameter pBoxMinFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pBoxMaxFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pBoxMinPositiveRateChangeFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pBoxMaxPositiveRateChangeFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pBoxMinNegativeRateChangeFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pBoxMaxNegativeRateChangeFlowConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Default: 0;
				}
				Parameter pboxMinStayTimeSteadyStateConstant {
					IndexDomain: (iBox,iBoxNodeConnectionType);
					Range: integer;
				}
				Parameter pBoxMinFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pBoxMaxFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pBoxMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pBoxMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pBoxMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pBoxMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Default: 0;
				}
				Parameter pboxMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Range: integer;
				}
				Parameter p01BoxFlowActiveTimeDependent {
					IndexDomain: (iBox,iBoxNodeConnectionType,gdm::iTime);
					Range: binary;
					Default: 0;
				}
				Parameter p01TimeDependentBoxControlMode {
					IndexDomain: (iBox,gdm::iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Coldbox_Internal_Flow_Time_Declaration {
				Parameter pColdboxMinInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMaxInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMinPositiveRateChangeInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMaxPositiveRateChangeInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMinNegativeRateChangeInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMaxNegativeRateChangeInternalFlowConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Default: 0;
				}
				Parameter pColdboxMinStayTimeSteadyStateConstant {
					IndexDomain: (iColdbox,iColdboxInternalFlow);
					Range: integer;
				}
				Parameter pColdboxMinInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMaxInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMinPositiveRateChangeInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMaxPositiveRateChangeInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMinNegativeRateChangeInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMaxNegativeRateChangeInternalFlowTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Default: 0;
				}
				Parameter pColdboxMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Range: integer;
				}
				Parameter p01ColdboxFlowActiveTimeDependent {
					IndexDomain: (iColdbox,iColdboxInternalFlow,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Compressor_Time_Declaration {
				Parameter pCompressorMinFlowConstant {
					IndexDomain: (iCompressorArc);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pCompressorMaxFlowConstant {
					IndexDomain: (iCompressorArc);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pCompressorMinPositiveRateChangeFlowConstant {
					IndexDomain: iCompressorArc;
					Default: 0;
				}
				Parameter pCompressorMaxPositiveRateChangeFlowConstant {
					IndexDomain: iCompressorArc;
					Default: 0;
				}
				Parameter pCompressorMinNegativeRateChangeFlowConstant {
					IndexDomain: iCompressorArc;
					Default: 0;
				}
				Parameter pCompressorMaxNegativeRateChangeFlowConstant {
					IndexDomain: iCompressorArc;
					Default: 0;
				}
				Parameter pCompressorMinStayTimeSteadyStateConstant {
					IndexDomain: (iCompressorArc);
					Range: integer;
				}
				Parameter pCompressorMaxPowerConstant {
					IndexDomain: iCompressorArc;
					Default: 0;
				}
				Parameter pCompressorMinFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pCompressorMaxFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pCompressorMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Default: 0;
				}
				Parameter pCompressorMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Default: 0;
				}
				Parameter pCompressorMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Default: 0;
				}
				Parameter pCompressorMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Default: 0;
				}
				Parameter pCompressorMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Range: integer;
				}
				Parameter pCompressorMaxPowerTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Default: 0;
				}
				Parameter p01CompressorActiveTimeDependent {
					IndexDomain: (iCompressorArc,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Cooling_Tower_Time_Declaration {
				Parameter pCoolingTowerTemperatureConstant {
					IndexDomain: (iCoolingTower);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pCoolingTowerTemperatureTimeDependent {
					IndexDomain: (iCoolingTower,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter p01CoolingTowerTemperatureActiveTimeDependent {
					IndexDomain: (iCoolingTower, iTime);
					Range: nonnegative;
					Default: 0;
				}
			}
			DeclarationSection Output_Flow_Node_Time_Declaration {
				Parameter pOutputFlowNodeFixedConstant {
					IndexDomain: (iOutputFlowNode);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pOutputFlowNodeMinFlowConstant {
					IndexDomain: iOutputFlowNode;
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMaxFlowConstant {
					IndexDomain: iOutputFlowNode;
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMinPositiveRateChangeFlowConstant {
					IndexDomain: (iOutputFlowNode);
				}
				Parameter pOutputFlowNodeMaxPositiveRateChangeFlowConstant {
					IndexDomain: (iOutputFlowNode);
				}
				Parameter pOutputFlowNodeMinNegativeRateChangeFlowConstant {
					IndexDomain: (iOutputFlowNode);
				}
				Parameter pOutputFlowNodeMaxNegativeRateChangeFlowConstant {
					IndexDomain: (iOutputFlowNode);
				}
				Parameter pOutputFlowNodeMinStayTimeSteadyStateConstant {
					IndexDomain: (iOutputFlowNode);
					Range: integer;
				}
				Parameter pOutputFlowNodeValuePerUnitConstant {
					IndexDomain: iOutputFlowNode;
				}
				Parameter pOutputFlowNodeFixedTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
					Default: 0;
				}
				Parameter pOutputFlowNodeMinFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMaxFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: nonnegative;
				}
				Parameter pOutputFlowNodeMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter pOutputFlowNodeMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: integer;
				}
				Parameter pOutputFlowNodeValuePerUnitTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
				}
				Parameter p01OutputFlowNodeActiveTimeDependent {
					IndexDomain: (iOutputFlowNode,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Input_Flow_Node_Time_Declaration {
				Parameter pInputFlowNodeMinFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeMaxFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeFixedConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeCostPerUnitConstant {
					IndexDomain: (iInputFlowNode);
					Default: 0;
				}
				Parameter pInputFlowNodeMinPositiveRateChangeFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeMaxPositiveRateChangeFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeMinNegativeRateChangeFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeMaxNegativeRateChangeFlowConstant {
					IndexDomain: iInputFlowNode;
					Default: 0;
				}
				Parameter pInputFlowNodeMinStayTimeSteadyStateConstant {
					IndexDomain: (iInputFlowNode);
					Range: integer;
				}
				Parameter pInputFlowNodeMinFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMaxFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeFixedTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter pInputFlowNodeMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Range: integer;
				}
				Parameter pInputFlowNodeCostPerUnitTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Default: 0;
				}
				Parameter p01InputFlowNodeActiveTimeDependent {
					IndexDomain: (iInputFlowNode,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Liquefier_Time_Declaration {
				Parameter pLiquefierMinFlowConstant {
					IndexDomain: (iLiquefierArc);
					Default: 0;
				}
				Parameter pLiquefierMaxFlowConstant {
					IndexDomain: (iLiquefierArc);
					Default: 0;
				}
				Parameter pLiquefierMinFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMaxFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMinPositiveRateChangeFlowConstant {
					IndexDomain: iLiquefierArc;
					Default: 0;
				}
				Parameter pLiquefierMaxPositiveRateChangeFlowConstant {
					IndexDomain: iLiquefierArc;
					Default: 0;
				}
				Parameter pLiquefierMinNegativeRateChangeFlowConstant {
					IndexDomain: iLiquefierArc;
					Default: 0;
				}
				Parameter pLiquefierMaxNegativeRateChangeFlowConstant {
					IndexDomain: iLiquefierArc;
					Default: 0;
				}
				Parameter pLiquefierMinStayTimeSteadyStateConstant {
					IndexDomain: (iLiquefierArc);
					Range: integer;
				}
				Parameter pLiquefierMaxPowerConstant {
					IndexDomain: (iLiquefierArc);
					Default: 0;
				}
				Parameter pLiquefierMinPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMaxPositiveRateChangeFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMinNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMaxNegativeRateChangeFlowTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter pLiquefierMinStayTimeSteadyStateTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Range: integer;
				}
				Parameter pLiquefierMaxPowerTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Default: 0;
				}
				Parameter p01LiquifierActiveTimeDependent {
					IndexDomain: (iLiquefierArc,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Energy_Contract_Time_Declaration {
				Parameter pEnergyContractCostConstant {
					IndexDomain: (iEnergyContract);
					Default: 0;
					Comment: "50";
				}
				Parameter pEnergyContractCostTimeDependent {
					IndexDomain: (iEnergyContract,iTime);
					Default: 0;
					Comment: "50";
				}
				Parameter p01EnergyContractActiveTimeDependent {
					IndexDomain: (iEnergyContract,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Tank_Time_Declaration {
				Parameter pTankMinLevelConstant {
					IndexDomain: iTankNode;
					Default: 0;
				}
				Parameter pTankMaxLevelConstant {
					IndexDomain: iTankNode;
					Default: 0;
				}
				Parameter p01TankEnableLevelConstraintsConstant {
					IndexDomain: (iTankNode);
					Range: binary;
					Default: 0;
					Comment: "0";
				}
				Parameter pTankMinLevelTimeDependent {
					IndexDomain: (iTankNode,iTime);
					Default: 0;
				}
				Parameter pTankMaxLevelTimeDependent {
					IndexDomain: (iTankNode,iTime);
					Default: 0;
				}
				Parameter p01TankEnableLevelConstraintsTimeDependent {
					IndexDomain: (iTankNode,iTime);
					Range: binary;
					Default: 0;
					Comment: "0";
				}
				Parameter p01TankLevelActiveTimeDependent {
					IndexDomain: (iTankNode,iTime);
					Range: binary;
					Default: 0;
				}
			}
			DeclarationSection Valves_Time_Declaration {
				ElementParameter epValveControlModeConstant {
					IndexDomain: (iValveArc);
					Range: sValveControlModes;
					Default: '';
				}
				ElementParameter epValveControlModeTimeDependent {
					IndexDomain: (iValveArc,iTime);
					Range: sValveControlModes;
					Default: '';
				}
				Parameter pValveSetpointConstant {
					IndexDomain: (iValveArc);
					Default: 0;
				}
				Parameter pValveSetpointTimeDependent {
					IndexDomain: (iValveArc,iTime);
					Default: 0;
				}
				Parameter p01ValveActiveTimeDependent {
					IndexDomain: (iValveArc,iTime);
					Default: 0;
				}
			}
			DeclarationSection Operating_Modes_Time_Declaration {
				Parameter p01OperatingModeAllowedConstant {
					IndexDomain: (iOperatingModeElement,iOperatingMode);
					Default: 0;
				}
				Parameter p01OperatingModeAllowedTimeDependent {
					IndexDomain: (iOperatingModeElement,iOperatingMode,iTime);
					Default: 0;
				}
				Parameter p01OperatingModeActiveTimeDependent {
					IndexDomain: (iOperatingModeElement,iOperatingMode, iTime);
					Default: 0;
				}
			}
			DeclarationSection Switchable_Element_Time_Declaration {
				ElementParameter epOperatingModeForcedConstant {
					IndexDomain: iOperatingModeElement;
					Range: sOperatingModes;
					Default: '';
				}
				ElementParameter epOperatingModeForcedTimeDependent {
					IndexDomain: (iOperatingModeElement,iTime);
					Range: sOperatingModes;
					Default: '';
				}
				Parameter p01OperatingModeElementActiveTimeDependent {
					IndexDomain: (iOperatingModeElement,iTime);
					Default: 0;
				}
			}
			DeclarationSection Status_Modes_Time_Declaration {
				ElementParameter epStatusElementConstant {
					IndexDomain: iStatusModeElement;
					Range: sStatusModes;
				}
				ElementParameter epStatusElementTimeDependent {
					IndexDomain: (iStatusModeElement,iTime);
					Range: sStatusModes;
				}
				Parameter p01StatusElementActiveTimeDependent {
					IndexDomain: (iStatusModeElement,iTime);
					Default: 0;
				}
			}
			Procedure procInitializeTimeDependentData {
				Body: {
					!!!! This procedure is the link between the parameters read from excel and the parameters used in the model (gom) !!!!!
					
					! Pressure control
					pPressureControlNodeSetpoint(iPressureControlNode,iTime) := pPressureControlNodeSetpointConstant(iPressureControlNode)*(1 - p01PressureControlNodeSetPointActiveTimeDependent(iPressureControlNode,iTime)) +
									                 pPressureControlNodeSetpointTimeDependent(iPressureControlNode,iTime)*p01PressureControlNodeSetPointActiveTimeDependent(iPressureControlNode,iTime);
					
					! Buffer
					pBufferMinPressure(iBufferNode,iTime) := pBufferMinPressureConstant(iBufferNode) * (1 - p01BufferActiveTimeDependent(iBufferNode, iTime)) +
										 pBufferMinPressureTimeDependent(iBufferNode, iTime) * p01BufferActiveTimeDependent(iBufferNode, iTime);
					pBufferMaxPressure(iBufferNode,iTime) := pBufferMaxPressureConstant(iBufferNode) * (1 - p01BufferActiveTimeDependent(iBufferNode, iTime)) +
										 pBufferMaxPressureTimeDependent(iBufferNode, iTime) * p01BufferActiveTimeDependent(iBufferNode, iTime);
					
					! Backup
					pBackupMinFlow(iBackupArc,iTime) := pBackupMinFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									    pBackupMinFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);
					pBackupMaxFlow(iBackupArc,iTime) := pBackupMaxFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									    pBackupMaxFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);
					pBackupMinPositiveRateChangeFlow(iBackupArc,iTime) := pBackupMinPositiveRateChangeFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									                      pBackupMinPositiveRateChangeFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);
					pBackupMaxPositiveRateChangeFlow(iBackupArc,iTime) := pBackupMaxPositiveRateChangeFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									                      pBackupMaxPositiveRateChangeFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);				                      
					pBackupMinNegativeRateChangeFlow(iBackupArc,iTime) := pBackupMinNegativeRateChangeFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									                      pBackupMinNegativeRateChangeFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);		
					pBackupMaxNegativeRateChangeFlow(iBackupArc,iTime) := pBackupMaxNegativeRateChangeFlowConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									                      pBackupMaxNegativeRateChangeFlowTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);				                      		    		    
					pBackupMinStayTimeSteadyState(iBackupArc,iTime)    := pBackupMinStayTimeSteadyStateConstant(iBackupArc)*(1 - p01BackupActiveTimeDependent(iBackupArc,iTime)) +
									                      pBackupMinStayTimeSteadyStateTimeDependent(iBackupArc,iTime)*p01BackupActiveTimeDependent(iBackupArc,iTime);				                      		    		    
					
					! Coldbox
					pColdboxMinInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMinInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
												      pColdboxMinInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMaxInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMaxInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +	
												      pColdboxMaxInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMinPositiveRateChangeInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMinPositiveRateChangeInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
														        pColdboxMinPositiveRateChangeInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMaxPositiveRateChangeInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMaxPositiveRateChangeInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
														        pColdboxMaxPositiveRateChangeInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMinNegativeRateChangeInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMinNegativeRateChangeInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
														        pColdboxMinNegativeRateChangeInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMaxNegativeRateChangeInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMaxNegativeRateChangeInternalFlowConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
														        pColdboxMaxNegativeRateChangeInternalFlowTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					pColdboxMinStayTimeSteadyStateInternalFlow(iColdbox,iColdboxInternalFlow,iTime) := pColdboxMinStayTimeSteadyStateConstant(iColdbox,iColdboxInternalFlow)*( 1 - p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime)) +
														     pColdboxMinStayTimeSteadyStateTimeDependent(iColdbox,iColdboxInternalFlow,iTime)*p01ColdboxFlowActiveTimeDependent(iColdbox,iColdboxInternalFlow,iTime);
					
					! Compressor
					pCompressorMinFlow(iCompressorArc,iTime) := pCompressorMinFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
										    pCompressorMinFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMaxFlow(iCompressorArc,iTime) := pCompressorMaxFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
										    pCompressorMaxFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMinPositiveRateChangeFlow(iCompressorArc,iTime) := pCompressorMinPositiveRateChangeFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
												      pCompressorMinPositiveRateChangeFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMaxPositiveRateChangeFlow(iCompressorArc,iTime) := pCompressorMaxPositiveRateChangeFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
												      pCompressorMaxPositiveRateChangeFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);						      
					pCompressorMinNegativeRateChangeFlow(iCompressorArc,iTime) := pCompressorMinNegativeRateChangeFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
												      pCompressorMinNegativeRateChangeFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMaxNegativeRateChangeFlow(iCompressorArc,iTime) := pCompressorMaxNegativeRateChangeFlowConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
												      pCompressorMaxNegativeRateChangeFlowTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMinStayTimeSteadyState(iCompressorArc,iTime) := pCompressorMinStayTimeSteadyStateConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
												   pCompressorMinStayTimeSteadyStateTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					pCompressorMaxPower(iCompressorArc,iTime) := pCompressorMaxPowerConstant(iCompressorArc)*(1 - p01CompressorActiveTimeDependent(iCompressorArc,iTime)) +
										     pCompressorMaxPowerTimeDependent(iCompressorArc,iTime)*p01CompressorActiveTimeDependent(iCompressorArc,iTime);
					
					! Cooling Tower
					pCoolingTowerTemperature(iCoolingTower,iTime) := pCoolingTowerTemperatureConstant(iCoolingTower)*(1 - p01CoolingTowerTemperatureActiveTimeDependent(iCoolingTower,iTime)) +
										              pCoolingTowerTemperatureTimeDependent(iCoolingTower,iTime)*p01CoolingTowerTemperatureActiveTimeDependent(iCoolingTower,iTime);
					
					! Output Flow
					pOutputFlowFixed(iOutputFlowNode,iTime) := pOutputFlowNodeFixedConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
										   pOutputFlowNodeFixedTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);			
					pOutputFlowNodeMinFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMinFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
										         pOutputFlowNodeMinFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeMaxFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMaxFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
										         pOutputFlowNodeMaxFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeMinPositiveRateChangeFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMinPositiveRateChangeFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
								 					   pOutputFlowNodeMinPositiveRateChangeFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeMaxPositiveRateChangeFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMaxPositiveRateChangeFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
								                                           pOutputFlowNodeMaxPositiveRateChangeFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);			 
					pOutputFlowNodeMinNegativeRateChangeFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMinNegativeRateChangeFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
													   pOutputFlowNodeMinNegativeRateChangeFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeMaxNegativeRateChangeFlow(iOutputFlowNode,iTime) := pOutputFlowNodeMaxNegativeRateChangeFlowConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
								                                           pOutputFlowNodeMaxNegativeRateChangeFlowTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeMinStayTimeSteadyState(iOutputFlowNode,iTime) := pOutputFlowNodeMinStayTimeSteadyStateConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
													pOutputFlowNodeMinStayTimeSteadyStateTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					pOutputFlowNodeValuePerUnit(iOutputFlowNode,iTime) := pOutputFlowNodeValuePerUnitConstant(iOutputFlowNode) * (1 - p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime)) +
										       pOutputFlowNodeValuePerUnitTimeDependent(iOutputFlowNode,iTime)*p01OutputFlowNodeActiveTimeDependent(iOutputFlowNode,iTime);
					
					! External Source
					pInputFlowNodeFixed(iInputFlowNode,iTime) := pInputFlowNodeFixedConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
										     pInputFlowNodeFixedTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMinFlow(iInputFlowNode,iTime) := pInputFlowNodeMinFlowConstant(iInputFlowNode)*(1-p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) + 
										       pInputFlowNodeMinFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMaxFlow(iInputFlowNode,iTime) := pInputFlowNodeMaxFlowConstant(iInputFlowNode)*(1-p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
									               pInputFlowNodeMaxFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeCostPerUnit(iInputFlowNode,iTime) := pInputFlowNodeCostPerUnitConstant(iInputFlowNode)*(1-p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
											   pInputFlowNodeCostPerUnitTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMinPositiveRateChangeFlow(iInputFlowNode,iTime) := pInputFlowNodeMinPositiveRateChangeFlowConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
													 pInputFlowNodeMinPositiveRateChangeFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMaxPositiveRateChangeFlow(iInputFlowNode,iTime) := pInputFlowNodeMaxPositiveRateChangeFlowConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
													 pInputFlowNodeMaxPositiveRateChangeFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMinNegativeRateChangeFlow(iInputFlowNode,iTime) := pInputFlowNodeMinNegativeRateChangeFlowConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
													 pInputFlowNodeMinNegativeRateChangeFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMaxNegativeRateChangeFlow(iInputFlowNode,iTime) := pInputFlowNodeMaxNegativeRateChangeFlowConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
													 pInputFlowNodeMaxNegativeRateChangeFlowTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					pInputFlowNodeMinStayTimeSteadyState(iInputFlowNode,iTime) := pInputFlowNodeMinStayTimeSteadyStateConstant(iInputFlowNode)*(1 - p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime)) +
												      pInputFlowNodeMinStayTimeSteadyStateTimeDependent(iInputFlowNode,iTime)*p01InputFlowNodeActiveTimeDependent(iInputFlowNode,iTime);
					
					! Liquefiers
					pLiquefierMinFlow(iLiquefierArc,iTime) := pLiquefierMinFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime)) +
										  pLiquefierMinFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);
					pLiquefierMaxFlow(iLiquefierArc,iTime) := pLiquefierMaxFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime)) +
										  pLiquefierMaxFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);
					pLiquefierMinPositiveRateChangeFlow(iLiquefierArc,iTime) := pLiquefierMinPositiveRateChangeFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime)) +
												    pLiquefierMinPositiveRateChangeFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);
					pLiquefierMaxPositiveRateChangeFlow(iLiquefierArc,iTime) := pLiquefierMaxPositiveRateChangeFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime)) +
												    pLiquefierMaxPositiveRateChangeFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);							 						  
					pLiquefierMinNegativeRateChangeFlow(iLiquefierArc,iTime) := pLiquefierMinNegativeRateChangeFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime))+
												    pLiquefierMinNegativeRateChangeFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);
					pLiquefierMaxNegativeRateChangeFlow(iLiquefierArc,iTime) := pLiquefierMaxNegativeRateChangeFlowConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime))+
												    pLiquefierMaxNegativeRateChangeFlowTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);							    
					pLiquefierMinStayTimeSteadyState(iLiquefierArc,iTime) := pLiquefierMinStayTimeSteadyStateConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime))+
												 pLiquefierMinStayTimeSteadyStateTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);							    
					pLiquefierMaxPower(iLiquefierArc,iTime) := pLiquefierMaxPowerConstant(iLiquefierArc)*(1-p01LiquifierActiveTimeDependent(iLiquefierArc,iTime)) +
										   pLiquefierMaxPowerTimeDependent(iLiquefierArc,iTime)*p01LiquifierActiveTimeDependent(iLiquefierArc,iTime);
					
					! Plant
					pEnergyContractCost(iEnergyContract,iTime) := pEnergyContractCostConstant(iEnergyContract)*(1 - p01EnergyContractActiveTimeDependent(iEnergyContract,iTime))+
									  pEnergyContractCostTimeDependent(iEnergyContract,iTime)*p01EnergyContractActiveTimeDependent(iEnergyContract,iTime);
					
					! Tanks
					pTankMinLevel(iTankNode,iTime) := pTankMinLevelConstant(iTankNode)*(1-p01TankLevelActiveTimeDependent(iTankNode,iTime)) +
										 pTankMinLevelTimeDependent(iTankNode,iTime)*p01TankLevelActiveTimeDependent(iTankNode,iTime);
					pTankMaxLevel(iTankNode,iTime) := pTankMaxLevelConstant(iTankNode)*(1-p01TankLevelActiveTimeDependent(iTankNode,iTime)) + 
										 pTankMaxLevelTimeDependent(iTankNode,iTime)*p01TankLevelActiveTimeDependent(iTankNode,iTime);
					p01TankEnableLevelConstraints(iTankNode,iTime) := p01TankEnableLevelConstraintsConstant(iTankNode)*(1-p01TankLevelActiveTimeDependent(iTankNode,iTime)) +
										      p01TankEnableLevelConstraintsTimeDependent(iTankNode,iTime)*p01TankLevelActiveTimeDependent(iTankNode,iTime);
					
					! Valves
					pValveSetpoint(iValveArc,iTime) := pValveSetpointConstant(iValveArc)*(1 - p01ValveActiveTimeDependent(iValveArc,iTime)) +
									   pValveSetpointTimeDependent(iValveArc,iTime)*p01ValveActiveTimeDependent(iValveArc,iTime);
					epValveControlMode((iValveArc,iTime)|p01ValveActiveTimeDependent(iValveArc,iTime)) := epValveControlModeTimeDependent(iValveArc,iTime);
					epValveControlMode((iValveArc,iTime)|not p01ValveActiveTimeDependent(iValveArc,iTime)) := epValveControlModeConstant(iValveArc);
					
					! Operating Modes
					p01OperatingModeAllowed(iOperatingModeElement,iOperatingMode, iTime) := p01OperatingModeAllowedConstant(iOperatingModeElement,iOperatingMode) * (1 - p01OperatingModeActiveTimeDependent(iOperatingModeElement,iOperatingMode,iTime)) + 
													     p01OperatingModeAllowedTimeDependent(iOperatingModeElement,iOperatingMode,iTime) * p01OperatingModeActiveTimeDependent(iOperatingModeElement,iOperatingMode,iTime);
					!p01OperatingModeForced(iOperatingModeElement,iOperatingMode, iTime) := p01OperatingModeForcedConstant(iOperatingModeElement,iOperatingMode) * (1 - p01OperatingModeActiveTimeDependent(iOperatingModeElement,iOperatingMode,iTime)) + 
					!								    p01OperatingModeForcedTimeDependent(iOperatingModeElement,iOperatingMode,iTime) * p01OperatingModeActiveTimeDependent(iOperatingModeElement,iOperatingMode,iTime);
					
					! Switchable Element
					epOperatingModeForced((iOperatingModeElement, iTime) | p01OperatingModeElementActiveTimeDependent(iOperatingModeElement, iTime)) := epOperatingModeForcedTimeDependent(iOperatingModeElement, iTime);
					epOperatingModeForced((iOperatingModeElement, iTime) | not p01OperatingModeElementActiveTimeDependent(iOperatingModeElement, iTime)) := epOperatingModeForcedConstant(iOperatingModeElement);
					
					! Status Element
					epStatusElement((iStatusModeElement, iTime) | p01StatusElementActiveTimeDependent(iStatusModeElement, iTime)) := epStatusElementTimeDependent(iStatusModeElement, iTime);
					epStatusElement((iStatusModeElement, iTime) | not p01StatusElementActiveTimeDependent(iStatusModeElement, iTime)) := epStatusElementConstant(iStatusModeElement);
					
					! Box -------- NEW -------------- 
					
					pBoxMinFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMinFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
												      pBoxMinFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMaxFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMaxFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +	
												      pBoxMaxFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMinPositiveRateChangeFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMinPositiveRateChangeFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
														        pBoxMinPositiveRateChangeFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMaxPositiveRateChangeFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMaxPositiveRateChangeFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
														        pBoxMaxPositiveRateChangeFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMinNegativeRateChangeFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMinNegativeRateChangeFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
														        pBoxMinNegativeRateChangeFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMaxNegativeRateChangeFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pBoxMaxNegativeRateChangeFlowConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
														        pBoxMaxNegativeRateChangeFlowTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
					pBoxMinStayTimeSteadyStateFlow(iBox,iBoxNodeConnectionType,gdm::iTime) := pboxMinStayTimeSteadyStateConstant(iBox,iBoxNodeConnectionType)*( 1 - p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)) +
														     pboxMinStayTimeSteadyStateTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime)*p01BoxFlowActiveTimeDependent(iBox,iBoxNodeConnectionType,gdm::iTime);
				}
			}
		}
		Section Define_Tables {
			Procedure procDefineTablesTime1 {
				Body: {
					/*
					  This procedure is used when reading from database / excel files
					*/
					
					
					/*---Clear the CQM DATA LINK library---*/
					! EL: initialise the counter of list of table read
					pCountTableList := 0;
					
					cdl::procClear();
					
					! run 
					cdl::procAddCaseTable( "run", spSchemaName, "run" ); 
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunFriendlyName', "friendly_name" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunEntity', "entity" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunSite', "site" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunTimeStamp', "timestamp" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunModelVersion', "model_version" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunTimeStampCreation', "timestamp_creation" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunLastSavedBy', "last_saved_by" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunCreatedBy', "created_by" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spWizardPicture', "wizard_picture" );
					
					
					! time parameters
					cdl::procAddTable( "calendar", spSchemaName, 1 );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spBeginCalendarExcel', "begin_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spEndCalendarExcel', "end_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spGranularityCalendar', "granularity_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::pGranularityFrequency', "granularity_frequency" );
				}
				Comment: "Defines the table structure in the database / excel files";
			}
			Procedure procDefineTablesTime2 {
				Body: {
					/*
					  This procedure is used when reading from database / excel files
					*/
					
					/*---Clear the CQM DATA LINK library---*/
					cdl::procClear();
					
					! run 
					cdl::procAddCaseTable( "run", spSchemaName, "run" ); 
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunFriendlyName', "friendly_name" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunEntity', "entity" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunSite', "site" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunTimeStamp', "timestamp" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunModelVersion', "model_version" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunTimeStampCreation', "timestamp_creation" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunLastSavedBy', "last_saved_by" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spRunCreatedBy', "created_by" );
					cdl::procAddIdentifierToTable( "run", 'gdm::spWizardPicture', "wizard_picture" );
					
					! time parameters
					cdl::procAddTable( "calendar", spSchemaName, 1 );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spBeginCalendarExcel', "begin_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spEndCalendarExcel', "end_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::spGranularityCalendar', "granularity_calendar" );
					cdl::procAddIdentifierToTable( "calendar", 'gdm::pGranularityFrequency', "granularity_frequency" );
					
					! Scalars
					cdl::procAddTable("scalar" , spSchemaName, 1);
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pEps1', "epsilon_1");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pEps2', "epsilon_2");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pN2Content', "N2_content");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pO2Content', "O2_content");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pARContent', "Ar_content");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pRconstant', "R_constant");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pTambient', "T_ambient");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pTreference', "T_reference");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pPreference', "P_reference");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pO2RecoveryMin', "O2_recovery_min");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pO2RecoveryMax', "O2_recovery_max");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pArRecoveryMin', "Ar_recovery_min");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pArRecoveryMax', "Ar_recovery_max");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pScaleFactorCompressorParam1', "scale_factor_compressor_param1");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pScaleFactorCompressorParam2', "scale_factor_compressor_param2");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pScaleFactorCompressorParam3', "scale_factor_compressor_param3");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pScaleFactorCompressorParam4', "scale_factor_compressor_param4");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pSIunitsToPressureUnits', "SI_units_to_pressure");
					cdl::procAddIdentifierToTable( "scalar", 'gdm::pSIunitsToPowerUnits', "SI_units_to_power");
					
					! Node types table
					cdl::procAddTable("node_type", spSchemaName, 1);
					cdl::procAddIndexToTable( "node_type", 'gdm::iNodeType', "node_type");
					
					! Site table
					cdl::procAddTable("site", spSchemaName, 1);
					cdl::procAddIndexToTable( "site", 'gdm::iSite', "site");
					
					! Nodes table
					cdl::procAddTable("node", spSchemaName, 1);
					cdl::procAddIndexToTable( "node", 'gdm::iNode', "node");
					cdl::procAddIdentifierToTable("node",'gdm::epNodeType',"node_type");
					cdl::procAddIdentifierToTable("node",'gdm::pNodeMinPressure',"min_pressure");
					cdl::procAddIdentifierToTable("node",'gdm::pNodeMaxPressure',"max_pressure");
					cdl::procAddIdentifierToTable("node",'gdm::epNodeSite',"site");
					
					! Arc types table
					cdl::procAddTable("arc_type", spSchemaName, 1);
					cdl::procAddIndexToTable( "arc_type", 'gdm::iArcType', "arc_type");
					
					! Arcs table
					cdl::procAddTable("arc", spSchemaName, 1);
					cdl::procAddIndexToTable( "arc", 'gdm::iArc', "arc");
					cdl::procAddIdentifierToTable("arc",'gdm::epArcType',"arc_type");
					cdl::procAddIdentifierToTable("arc",'gdm::epNodeFrom',"from_node");
					cdl::procAddIdentifierToTable("arc",'gdm::epNodeTo',"to_node");
					cdl::procAddIdentifierToTable("arc",'gdm::pArcMinFlow',"min_flow");
					cdl::procAddIdentifierToTable("arc",'gdm::pArcMaxFlow',"max_flow");
					
					! Control mode status "Running, Unavailable and Available"
					cdl::procAddTable("status", spSchemaName, 1);
					cdl::procAddIndexToTable( "status", 'gdm::iStatusMode', "status");
					
					! Energy Contracts
					cdl::procAddTable("energy_contract", spSchemaName, 1);
					cdl::procAddIndexToTable( "energy_contract", 'gdm::iEnergyContract', "energy_contract");
					cdl::procAddIdentifierToTable("energy_contract",'gdm::pEnergyContractCostConstant',"energy_cost");
					
					! Auxiliary Power group
					cdl::procAddTable("auxiliary_power_group", spSchemaName, 1);
					cdl::procAddIndexToTable( "auxiliary_power_group", 'gdm::iAuxPowerGroup', "auxiliary_power_group");
					cdl::procAddIdentifierToTable( "auxiliary_power_group", 'gdm::epAuxPowerGroupEnergyContract', "energy_contract");
					cdl::procAddIdentifierToTable( "auxiliary_power_group", 'gdm::pAuxPowerGroupParam1', "param1");
					cdl::procAddIdentifierToTable( "auxiliary_power_group", 'gdm::pAuxPowerGroupParam2', "param2");
					
					
					!box     -------------- NEW --------------------
					! Box Types
					cdl::procAddTable("box_type", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_type", 'gdm::iBoxType', "box_type");
					
					! box table
					cdl::procAddTable("box", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box", 'gdm::iBox', "box");
					cdl::procAddIdentifierToTable("box",'gdm::epBoxEnergyContract',"energy_contract");
					cdl::procAddIdentifierToTable("box",'gdm::epBoxAuxPowerGroup',"auxiliary_power_group");
					cdl::procAddIdentifierToTable("box",'gdm::epBoxType',"box_type");
					cdl::procAddIdentifierToTable("box",'gdm::p01BoxLinearEquationData',"linear_equation");
					
					! box connection types in list
					cdl::procAddTable("box_connection_type_in", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_connection_type_in", 'gdm::iBoxNodeConnectionTypeInput', "box_connection_type_in");
					
					! box connection types in list
					cdl::procAddTable("box_connection_type_out", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_connection_type_out", 'gdm::iBoxNodeConnectionTypeOutput', "box_connection_type_out");
					
					! box connection types table
					cdl::procAddTable("box_flow", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_flow", 'gdm::iBox', "box");
					cdl::procAddIndexToTable( "box_flow", 'gdm::iBoxNodeConnectionType', "box_connection_type");
					cdl::procAddIdentifierToTable("box_flow",'gdm::epBoxNode',"node");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMinFlowConstant',"min_flow");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMaxFlowConstant',"max_flow");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMinPositiveRateChangeFlowConstant',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMaxPositiveRateChangeFlowConstant',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMinNegativeRateChangeFlowConstant',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxMaxNegativeRateChangeFlowConstant',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pboxMinStayTimeSteadyStateConstant',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("box_flow",'gdm::p01boxFlowSpecificEquation',"use_specific_flow");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxParameter1Pres',"pres1");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxParameter2Pres',"pres2");
					cdl::procAddIdentifierToTable("box_flow",'gdm::pBoxParameter3Pres',"pres3");
					
					! Time dependent box & box connection type parameters
					cdl::procAddTable("box_flow_time", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_flow_time", 'gdm::iBox', "box");
					cdl::procAddIndexToTable( "box_flow_time", 'gdm::iBoxNodeConnectionType', "box_connection_type");
					cdl::procAddIndexToTable( "box_flow_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMinFlowTimeDependent',"min_flow");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMaxFlowTimeDependent',"max_flow");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMinPositiveRateChangeFlowTimeDependent',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMaxPositiveRateChangeFlowTimeDependent',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMinNegativeRateChangeFlowTimeDependent',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pBoxMaxNegativeRateChangeFlowTimeDependent',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::pboxMinStayTimeSteadyStateTimeDependent',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("box_flow_time",'gdm::p01boxFlowActiveTimeDependent',"is_active");
					
					! box parameters table
					cdl::procAddTable("box_parameter", gdm::spSchemaName, 1);
					cdl::procAddIndexToTable( "box_parameter", 'gdm::iBoxParameter', "box_parameter");
					cdl::procAddIdentifierToTable( "box_parameter", 'gdm::epBoxTypeParameter', "box_type");
					
					! box parameter data
					cdl::procAddTable("box_parameter_data", gdm::spSchemaName, 0);
					cdl::procAddIndexToTable( "box_parameter_data", 'gdm::iBox', "box");
					cdl::procAddIndexToTable( "box_parameter_data", 'gdm::iBoxParameter', "box_parameter");
					cdl::procAddIdentifierToTable("box_parameter_data",'gdm::pBoxParameterValue',"value");
					
					!----------------------------------------------------------------------------------------------------
					
					! Coldbox process list
					cdl::procAddTable("coldbox_process_list", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_process_list", 'gdm::iColdboxProcess', "coldbox_process");
					
					! Coldbox Specific Equation (to manage the activation by type of cold box)
					cdl::procAddTable("coldbox_specific_equation", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_specific_equation", 'gdm::iColdboxSpecificEquation', "coldbox_specific_equation");
					
					! Activation or not the Coldbox Specific Equation by type of coldbox (to manage the activation by type of cold box)
					cdl::procAddTable("coldbox_specific_equation_data", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_specific_equation_data", 'gdm::iColdboxProcess', "coldbox_process");
					cdl::procAddIndexToTable( "coldbox_specific_equation_data", 'gdm::iColdboxSpecificEquation', "use_specific");
					cdl::procAddIdentifierToTable("coldbox_specific_equation_data",'gdm::p01ColdboxTypeSpecificEquation', "value");
					
					! Time dependent Energy Contract parameters
					cdl::procAddTable("energy_contract_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "energy_contract_time", 'gdm::iEnergyContract', "energy_contract");
					cdl::procAddIndexToTable( "energy_contract_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable("energy_contract_time",'gdm::pEnergyContractCostTimeDependent',"energy_cost");
					cdl::procAddIdentifierToTable("energy_contract_time",'gdm::p01EnergyContractActiveTimeDependent',"is_active");
					
					! Cooling Tower parameters
					cdl::procAddTable("cooling_tower", spSchemaName, 1);
					cdl::procAddIndexToTable( "cooling_tower", 'gdm::iCoolingTower', "cooling_tower");
					cdl::procAddIdentifierToTable( "cooling_tower", 'gdm::pCoolingTowerTemperatureConstant', "cooling_temperature");
					
					! Time dependent Cooling Tower parameters
					cdl::procAddTable("cooling_tower_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "cooling_tower_time", 'gdm::iCoolingTower', "cooling_tower");
					cdl::procAddIndexToTable( "cooling_tower_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "cooling_tower_time", 'gdm::pCoolingTowerTemperatureTimeDependent', "cooling_temperature");
					cdl::procAddIdentifierToTable( "cooling_tower_time", 'gdm::p01CoolingTowerTemperatureActiveTimeDependent', "is_active");
					
					! Products table
					cdl::procAddTable("products", spSchemaName, 1);
					cdl::procAddIndexToTable( "products", 'gdm::iProduct', "product");
					cdl::procAddIdentifierToTable("products",'gdm::pLiquidEqCoef',"internal_liquid_equation_coef");
					cdl::procAddIdentifierToTable("products",'gdm::pLiquidMassToVolumeUnits',"mass_to_volume_units");
					cdl::procAddIdentifierToTable("products",'gdm::pMolecularWeight',"molecular_weight");
					cdl::procAddIdentifierToTable("products",'gdm::pViscosity',"viscosity");
					cdl::procAddIdentifierToTable("products",'gdm::pCompressibility',"compressibility");
					cdl::procAddIdentifierToTable("products",'gdm::pdHvaporization',"dH_vaporization");
					
					! coldbox table
					cdl::procAddTable("coldbox", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox", 'gdm::iColdbox', "coldbox");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxMaxO2ContentInWaste',"max_o2_content_in_waste");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxLosses',"losses");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxWasteToAirRatio',"waste_to_air_ratio");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxMinRectifPower',"min_rectif_power");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxMaxRectifPower',"max_rectif_power");
					cdl::procAddIdentifierToTable("coldbox",'gdm::pColdboxLinAssistColdStandby',"lin_assist_cold_standby");
					cdl::procAddIdentifierToTable("coldbox",'gdm::epColdboxProcess',"coldbox_process");
					
					! Coldbox internal flows list
					cdl::procAddTable("coldbox_internal_flow_list", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_internal_flow_list", 'gdm::iColdboxinternalflow', "coldbox_internal_flow");
					
					! Coldbox internal flows table
					cdl::procAddTable("coldbox_internal_flow", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_internal_flow", 'gdm::iColdbox', "coldbox");
					cdl::procAddIndexToTable( "coldbox_internal_flow", 'gdm::iColdboxInternalFlow', "coldbox_internal_flow");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMinInternalFlowConstant',"min_flow");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMaxInternalFlowConstant',"max_flow");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMinPositiveRateChangeInternalFlowConstant',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMaxPositiveRateChangeInternalFlowConstant',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMinNegativeRateChangeInternalFlowConstant',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMaxNegativeRateChangeInternalFlowConstant',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::pColdboxMinStayTimeSteadyStateConstant',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("coldbox_internal_flow",'gdm::p01ColdboxInternalFlowSpecificEquation',"use_specific_internal_flow");
					
					! Time dependent coldbox internal flows table
					cdl::procAddTable("coldbox_internal_flow_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "coldbox_internal_flow_time", 'gdm::iColdbox', "coldbox");
					cdl::procAddIndexToTable( "coldbox_internal_flow_time", 'gdm::iColdboxInternalFlow', "coldbox_internal_flow");
					cdl::procAddIndexToTable( "coldbox_internal_flow_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMinInternalFlowTimeDependent',"min_flow");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMaxInternalFlowTimeDependent',"max_flow");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMinPositiveRateChangeInternalFlowTimeDependent',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMaxPositiveRateChangeInternalFlowTimeDependent',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMinNegativeRateChangeInternalFlowTimeDependent',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMaxNegativeRateChangeInternalFlowTimeDependent',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::pColdboxMinStayTimeSteadyStateTimeDependent',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("coldbox_internal_flow_time",'gdm::p01ColdboxFlowActiveTimeDependent',"is_active");
					
					! tanks
					cdl::procAddTable("tank", spSchemaName, 1);
					cdl::procAddIndexToTable( "tank", 'gdm::iTankNode', "tank");
					cdl::procAddIdentifierToTable("tank",'gdm::epTankLiquidProduct',"liquid_product");
					cdl::procAddIdentifierToTable("tank",'gdm::pTankInitialLevel',"initial_level");
					cdl::procAddIdentifierToTable("tank",'gdm::pTankStorageCapacity',"storage_capacity");
					cdl::procAddIdentifierToTable("tank",'gdm::pTankMinLevelConstant',"min_level");
					cdl::procAddIdentifierToTable("tank",'gdm::pTankMaxLevelConstant',"max_level");
					cdl::procAddIdentifierToTable("tank",'gdm::p01TankEnableLevelConstraintsConstant',"enable_level_constraints");
					cdl::procAddIdentifierToTable("tank",'gdm::pTankLiquidValue',"liquid_value");
					cdl::procAddIdentifierToTable("tank",'gdm::p01TankFlashSpecificEquation',"use_specific_flash");
					
					! tanks targets (time dependent)
					cdl::procAddTable("tank_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "tank_time", 'gdm::iTankNode', "tank");
					cdl::procAddIndexToTable( "tank_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable("tank_time",'gdm::pTankMinLevelTimeDependent',"min_level");
					cdl::procAddIdentifierToTable("tank_time",'gdm::pTankMaxLevelTimeDependent',"max_level");
					cdl::procAddIdentifierToTable("tank_time",'gdm::p01TankEnableLevelConstraintsTimeDependent',"enable_level_constraints");
					cdl::procAddIdentifierToTable("tank_time",'gdm::p01TankLevelActiveTimeDependent',"is_active");
					
					! Backups
					cdl::procAddTable("backup", spSchemaName, 1);
					cdl::procAddIndexToTable( "backup", 'gdm::iBackupArc', "backup");
					cdl::procAddIdentifierToTable("backup",'gdm::epBackupEnergyContract',"energy_contract");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMinFlowConstant',"min_flow");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMaxFlowConstant',"max_flow");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMinPositiveRateChangeFlowConstant',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMaxPositiveRateChangeFlowConstant',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMinNegativeRateChangeFlowConstant',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMaxNegativeRateChangeFlowConstant',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupMinStayTimeSteadyStateConstant',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("backup",'gdm::pBackupPowerPump',"power_pump");
					cdl::procAddIdentifierToTable("backup",'gdm::p01BackupFlashSpecificEquation',"use_specific_flash");
					
					
					! Time dependent Backup parameters
					cdl::procAddTable("backup_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "backup_time", 'gdm::iBackupArc', "backup");
					cdl::procAddIndexToTable( "backup_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMinFlowTimeDependent',"min_flow");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMaxFlowTimeDependent',"max_flow");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMinPositiveRateChangeFlowTimeDependent',"min_positive_rate_change");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMaxPositiveRateChangeFlowTimeDependent',"max_positive_rate_change");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMinNegativeRateChangeFlowTimeDependent',"min_negative_rate_change");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMaxNegativeRateChangeFlowTimeDependent',"max_negative_rate_change");
					cdl::procAddIdentifierToTable("backup_time",'gdm::pBackupMinStayTimeSteadyStateTimeDependent',"min_stay_time_steady_state");
					cdl::procAddIdentifierToTable("backup_time",'gdm::p01BackupActiveTimeDependent',"is_active");
					
					! Input Flow Nodes 
					cdl::procAddTable("input_flow_node", spSchemaName, 1);
					cdl::procAddIndexToTable( "input_flow_node", 'gdm::iInputFlowNode', "input_flow_node");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeFixedConstant', "fixed_flow");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMinFlowConstant', "min_flow");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMaxFlowConstant', "max_flow");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMinPositiveRateChangeFlowConstant', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMaxPositiveRateChangeFlowConstant', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMinNegativeRateChangeFlowConstant', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMaxNegativeRateChangeFlowConstant', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeMinStayTimeSteadyStateConstant', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "input_flow_node", 'gdm::pInputFlowNodeCostPerUnitConstant', "cost_per_unit");
					
					! Input Flow Nodes time (time dependent)
					cdl::procAddTable("input_flow_node_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "input_flow_node_time", 'gdm::iInputFlowNode', "input_flow_node");
					cdl::procAddIndexToTable( "input_flow_node_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeFixedTimeDependent', "fixed_flow");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMinFlowTimeDependent', "min_flow");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMaxFlowTimeDependent', "max_flow");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMinPositiveRateChangeFlowTimeDependent', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMaxPositiveRateChangeFlowTimeDependent', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMinNegativeRateChangeFlowTimeDependent', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMaxNegativeRateChangeFlowTimeDependent', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeMinStayTimeSteadyStateTimeDependent', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::pInputFlowNodeCostPerUnitTimeDependent', "cost_per_unit");
					cdl::procAddIdentifierToTable( "input_flow_node_time", 'gdm::p01InputFlowNodeActiveTimeDependent', "is_active");
					
					! Buffers
					cdl::procAddTable("buffer", spSchemaName, 1);
					cdl::procAddIndexToTable( "buffer", 'gdm::iBufferNode', "buffer");
					cdl::procAddIdentifierToTable( "buffer", 'gdm::pBufferMinPressureConstant', "min_pressure" );
					cdl::procAddIdentifierToTable( "buffer", 'gdm::pBufferMaxPressureConstant', "max_pressure" );
					cdl::procAddIdentifierToTable( "buffer", 'gdm::pBufferVolume', "volume" );
					cdl::procAddIdentifierToTable( "buffer", 'gdm::pBufferInitialPressure', "initial_pressure" );
					cdl::procAddIdentifierToTable( "buffer", 'gdm::pBufferGasValue', "gas_value" );
					
					! Buffers parameters time (time dependent)
					cdl::procAddTable("buffer_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "buffer_time", 'gdm::iBufferNode', "buffer");
					cdl::procAddIndexToTable( "buffer_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "buffer_time", 'gdm::pBufferMinPressureTimeDependent', "min_pressure" );
					cdl::procAddIdentifierToTable( "buffer_time", 'gdm::pBufferMaxPressureTimeDependent', "max_pressure" );
					cdl::procAddIdentifierToTable( "buffer_time", 'gdm::p01BufferActiveTimeDependent', "is_active");
					
					! Pressure control nodes
					cdl::procAddTable("pressure_control_node", spSchemaName, 1);
					cdl::procAddIndexToTable( "pressure_control_node", 'gdm::iPressureControlNode', "pressure_control_node");
					cdl::procAddIdentifierToTable( "pressure_control_node", 'gdm::pPressureControlNodeSetpointConstant', "pressure_set_point");
					
					! Pressure control nodes time
					cdl::procAddTable("pressure_control_node_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "pressure_control_node_time", 'gdm::iPressureControlNode', "pressure_control_node");
					cdl::procAddIndexToTable( "pressure_control_node_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "pressure_control_node_time", 'gdm::pPressureControlNodeSetpointTimeDependent', "pressure_set_point");
					cdl::procAddIdentifierToTable( "pressure_control_node_time", 'gdm::p01PressureControlNodeSetPointActiveTimeDependent', "is_active");
					
					! Output Flow Node
					cdl::procAddTable("output_flow_node", spSchemaName, 1);
					cdl::procAddIndexToTable( "output_flow_node", 'gdm::iOutputFlowNode', "output_flow_node");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeFixedConstant', "fixed_flow");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMinFlowConstant', "min_flow");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMaxFlowConstant', "max_flow");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMinPositiveRateChangeFlowConstant', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMaxPositiveRateChangeFlowConstant', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMinNegativeRateChangeFlowConstant', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMaxNegativeRateChangeFlowConstant', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeMinStayTimeSteadyStateConstant', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "output_flow_node", 'gdm::pOutputFlowNodeValuePerUnitConstant', "value_per_unit");
					
					! Output Flow Node Time
					cdl::procAddTable("output_flow_node_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "output_flow_node_time", 'gdm::iOutputFlowNode', "output_flow_node");
					cdl::procAddIndexToTable( "output_flow_node_time", 'gdm::iTime', "time" );
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeFixedTimeDependent', "fixed_flow");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMinFlowTimeDependent', "min_flow");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMaxFlowTimeDependent', "max_flow");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMinPositiveRateChangeFlowTimeDependent', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMaxPositiveRateChangeFlowTimeDependent', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMinNegativeRateChangeFlowTimeDependent', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMaxNegativeRateChangeFlowTimeDependent', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeMinStayTimeSteadyStateTimeDependent', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::pOutputFlowNodeValuePerUnitTimeDependent', "value_per_unit");
					cdl::procAddIdentifierToTable( "output_flow_node_time", 'gdm::p01OutputFlowNodeActiveTimeDependent', "is_active");
					
					! Compressors
					cdl::procAddTable("compressor", spSchemaName, 1);
					cdl::procAddIndexToTable( "compressor", 'gdm::iCompressorArc', "compressor");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::epCompressorEnergyContract', "energy_contract");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMinFlowConstant', "min_flow");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMaxFlowConstant', "max_flow");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMinPositiveRateChangeFlowConstant', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMaxPositiveRateChangeFlowConstant', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMinNegativeRateChangeFlowConstant', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMaxNegativeRateChangeFlowConstant', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMinStayTimeSteadyStateConstant', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMaxPowerConstant', "max_power");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::pCompressorMaxCompressionRatio', "max_compression_ratio");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::epCompressorCoolingTower', "cooling_tower");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::epCompressorAuxPowerGroup', "auxiliary_power_group");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::p01CompressorPowerSpecificEquation', "use_specific_power");
					cdl::procAddIdentifierToTable( "compressor", 'gdm::p01CompressorLinearEquationData', "linear_equation");
					
					
					! Time dependent Compressor parameters
					cdl::procAddTable("compressor_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "compressor_time", 'gdm::iCompressorArc', "compressor");
					cdl::procAddIndexToTable( "compressor_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMinFlowTimeDependent', "min_flow");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMaxFlowTimeDependent', "max_flow");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMinPositiveRateChangeFlowTimeDependent', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMaxPositiveRateChangeFlowTimeDependent', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMinNegativeRateChangeFlowTimeDependent', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMaxNegativeRateChangeFlowTimeDependent', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMinStayTimeSteadyStateTimeDependent', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::pCompressorMaxPowerTimeDependent', "max_power");
					cdl::procAddIdentifierToTable( "compressor_time", 'gdm::p01CompressorActiveTimeDependent', "is_active");
					
					! Compressor dependency
					cdl::procAddTable("compressor_dependency", spSchemaName, 1);
					cdl::procAddIndexToTable( "compressor_dependency", 'gdm::iCompressorDependency', "dependency");
					cdl::procAddIdentifierToTable( "compressor_dependency", 'gdm::epCompressorMapSpecial_1', "compressor1");
					cdl::procAddIdentifierToTable( "compressor_dependency", 'gdm::epCompressorMapSpecial_2', "compressor2");
					cdl::procAddIdentifierToTable( "compressor_dependency", 'gdm::p01CompressorRunTogether', "run_together");
					
					! Compressor parameter
					cdl::procAddTable("compressor_parameter", spSchemaName, 1);
					cdl::procAddIndexToTable( "compressor_parameter", 'gdm::iCompressorParameter', "compressor_parameter");
					
					! Compressor parameters data
					cdl::procAddTable("compressor_parameter_data", spSchemaName, 1);
					cdl::procAddIndexToTable( "compressor_parameter_data", 'gdm::iCompressorArc', "compressor");
					cdl::procAddIndexToTable( "compressor_parameter_data", 'gdm::iCompressorParameter', "compressor_parameter");
					cdl::procAddIdentifierToTable( "compressor_parameter_data", 'gdm::pCompressorParameterValue', "value");
					
					! Valve control modes
					cdl::procAddTable("valve_control_mode", spSchemaName, 1);
					cdl::procAddIndexToTable( "valve_control_mode", 'gdm::iValveControlMode', "valve_control_mode");
					
					! Valves
					cdl::procAddTable("valve", spSchemaName, 1);
					cdl::procAddIndexToTable( "valve", 'gdm::iValveArc', "valve");
					cdl::procAddIdentifierToTable( "valve", 'gdm::epValveControlModeConstant',"valve_control_mode");
					cdl::procAddIdentifierToTable( "valve", 'gdm::pValveSetpointConstant',"set_point");
					!cdl::procAddIdentifierToTable( "valve", 'gdm::pValveDeltaPressureMax',"delta_pressure_max");
					
					! Time dependent Valve parameters
					cdl::procAddTable("valve_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "valve_time", 'gdm::iValveArc', "valve");
					cdl::procAddIndexToTable( "valve_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "valve_time", 'gdm::epValveControlModeTimeDependent', "valve_control_mode");
					cdl::procAddIdentifierToTable( "valve_time", 'gdm::pValveSetpointTimeDependent',"set_point");
					cdl::procAddIdentifierToTable( "valve_time", 'gdm::p01ValveActiveTimeDependent',"is_active");
					
					! Pipe Calculation Mode
					cdl::procAddTable("pipe_calculation_mode", spSchemaName, 1);
					cdl::procAddIndexToTable( "pipe_calculation_mode", 'gdm::iPipeCalculationMode', "pressure_drop_calculation_mode");
					
					! Pipes
					cdl::procAddTable("pipe", spSchemaName, 1);
					cdl::procAddIndexToTable( "pipe", 'gdm::iPipeArc', "pipe");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::epPipeCalculationMode', "pressure_drop_calculation_mode");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeLinearPressureDropParam1', "simplified_param1");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipePressureDropParam1', "advanced_quadratic_param1");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeFrictionFactor', "friction_factor");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeLength', "length");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeDiameter', "diameter");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::epPipeGasType', "gas_type");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeEfficiency', "pipe_efficiency");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::pPipeRoughness', "pipe_roughness");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::p01PipePressureDropSpecificEquation', "use_specific_pressure_drop");
					cdl::procAddIdentifierToTable( "pipe", 'gdm::p01PipeFrictionFactorSpecificCorrelation', "use_specific_friction_factor");
					
					! Liquefier calculation modes
					cdl::procAddTable("liquefier_calculation_mode", spSchemaName, 1);
					cdl::procAddIndexToTable( "liquefier_calculation_mode", 'gdm::iLiquefierCalculationMode', "liquefier_calculation_mode");
					
					! Liquefiers
					cdl::procAddTable("liquefier", spSchemaName, 1);
					cdl::procAddIndexToTable( "liquefier", 'gdm::iLiquefierArc', "liquefier");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierCalculationMode', "liquefier_calculation_mode");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierEnergyContract', "energy_contract");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMinFlowConstant', "min_flow");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMaxFlowConstant', "max_flow");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMinPositiveRateChangeFlowConstant', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMaxPositiveRateChangeFlowConstant', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMinNegativeRateChangeFlowConstant', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMaxNegativeRateChangeFlowConstant', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMinStayTimeSteadyStateConstant', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::pLiquefierMaxPowerConstant', "max_power");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierCycle', "cycle_arc");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierCompressorFeed', "compressor_feed");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierCompressorCycle', "compressor_cycle");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierCoolingTower', "cooling_tower");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::epLiquefierAuxPowerGroup', "auxiliary_power_group");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::p01LiquefierPowerSpecificEquation', "use_specific_power");
					cdl::procAddIdentifierToTable( "liquefier", 'gdm::p01LiquefierLinearEquationData', "linear_equation");
					
					! Time dependent Liquefier parameters
					cdl::procAddTable("liquefier_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "liquefier_time", 'gdm::iLiquefierArc', "liquefier");
					cdl::procAddIndexToTable( "liquefier_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMinFlowTimeDependent', "min_flow");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMaxFlowTimeDependent', "max_flow");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMinPositiveRateChangeFlowTimeDependent', "min_positive_rate_change");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMaxPositiveRateChangeFlowTimeDependent', "max_positive_rate_change");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMinNegativeRateChangeFlowTimeDependent', "min_negative_rate_change");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMaxNegativeRateChangeFlowTimeDependent', "max_negative_rate_change");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMinStayTimeSteadyStateTimeDependent', "min_stay_time_steady_state");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::pLiquefierMaxPowerTimeDependent', "max_power");
					cdl::procAddIdentifierToTable( "liquefier_time", 'gdm::p01LiquifierActiveTimeDependent', "is_active");
					
					! Liquefier parameters
					cdl::procAddTable("liquefier_parameter", spSchemaName, 1);
					cdl::procAddIndexToTable( "liquefier_parameter", 'gdm::iLiquefierParameter', "liquefier_parameter");
					
					! Liquefier parameters data
					cdl::procAddTable("liquefier_parameter_data", spSchemaName, 1);
					cdl::procAddIndexToTable( "liquefier_parameter_data", 'gdm::iLiquefierArc', "liquefier");
					cdl::procAddIndexToTable( "liquefier_parameter_data", 'gdm::iLiquefierParameter', "liquefier_parameter");
					cdl::procAddIdentifierToTable( "liquefier_parameter_data", 'gdm::pLiquefierParameterValue', "value");
					
					! Control Mode Element       ------------ NEW -----------------
					cdl::procAddTable("control_mode_list", spSchemaName, 1);
					cdl::procAddIndexToTable( "control_mode_list", 'gdm::iControlMode', "control_mode");
					
					! Control Mode Element       ------------ NEW -----------------
					cdl::procAddTable("control_mode", spSchemaName, 1);
					cdl::procAddIndexToTable( "control_mode", 'gdm::iControlModeElement', "control_mode_element");
					cdl::procAddIdentifierToTable( "control_mode", 'gdm::epControlModeElement', "control_mode");
					
					! Status Element       ------------ NEW -----------------
					cdl::procAddTable("status_element", spSchemaName, 1);
					cdl::procAddIndexToTable( "status_element", 'gdm::iStatusModeElement', "status_element");
					cdl::procAddIdentifierToTable( "status_element", 'gdm::epStatusElementConstant', "status");
					
					! Status Element Time       ------------ NEW -----------------
					cdl::procAddTable("status_element_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "status_element_time", 'gdm::iStatusModeElement', "status_element");
					cdl::procAddIndexToTable( "status_element_time", 'gdm::itime', "time");
					cdl::procAddIdentifierToTable( "status_element_time", 'gdm::epStatusElementTimeDependent', "status");
					cdl::procAddIdentifierToTable( "status_element_time", 'gdm::p01StatusElementActiveTimeDependent', "is_active");
					
					! Operating modes
					cdl::procAddTable("operating_mode", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode", 'gdm::iOperatingMode', "operating_mode");
					
					! Operating Mode Entity
					cdl::procAddTable("operating_mode_element", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode_element", 'gdm::iOperatingModeElement', "element");
					cdl::procAddIdentifierToTable( "operating_mode_element", 'gdm::epOperatingModeInitialMode', "initial_mode");
					cdl::procAddIdentifierToTable( "operating_mode_element", 'gdm::pOperatingModeInitialMinTimeRemain', "min_time_remain");
					cdl::procAddIdentifierToTable( "operating_mode_element", 'gdm::pOperatingModeInitialMaxTimeRemain', "max_time_remain");
					cdl::procAddIdentifierToTable( "operating_mode_element", 'gdm::epOperatingModeForcedConstant', "op_mode_forced");
					cdl::procAddIdentifierToTable( "operating_mode_element", 'gdm::p01OperatingModeUseSpecificDescription', "use_specific_operating_mode");
					
					! Operating modes per entity
					cdl::procAddTable("operating_mode_allowed", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode_allowed", 'gdm::iOperatingModeElement', "element");
					cdl::procAddIndexToTable( "operating_mode_allowed", 'gdm::iOperatingMode', "operating_mode");
					cdl::procAddIdentifierToTable( "operating_mode_allowed", 'gdm::p01OperatingModeAllowedConstant', "allowed");
					cdl::procAddIdentifierToTable( "operating_mode_allowed", 'gdm::pOperatingModeExtraPower', "extra_power");
					
					! Time dependent Operating modes per entity 
					cdl::procAddTable("operating_mode_allowed_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode_allowed_time", 'gdm::iOperatingModeElement', "element");
					cdl::procAddIndexToTable( "operating_mode_allowed_time", 'gdm::iOperatingMode', "operating_mode");
					cdl::procAddIndexToTable( "operating_mode_allowed_time", 'gdm::iTime', "time");
					cdl::procAddIdentifierToTable( "operating_mode_allowed_time", 'gdm::p01OperatingModeAllowedTimeDependent', "allowed");
					cdl::procAddIdentifierToTable( "operating_mode_allowed_time", 'gdm::p01OperatingModeActiveTimeDependent', "is_active");
					
					! Operating Mode Entity Time     ------------ NEW -----------------
					cdl::procAddTable("operating_mode_element_time", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode_element_time", 'gdm::iOperatingModeElement', "element");
					cdl::procAddIndexToTable( "operating_mode_element_time", 'gdm::itime', "time");
					cdl::procAddIdentifierToTable( "operating_mode_element_time", 'gdm::epOperatingModeForcedTimeDependent', "op_mode_forced");
					cdl::procAddIdentifierToTable( "operating_mode_element_time", 'gdm::p01OperatingModeElementActiveTimeDependent', "is_active");
					
					
					! operating mode switch
					cdl::procAddTable("operating_mode_switch", spSchemaName, 1);
					cdl::procAddIndexToTable( "operating_mode_switch", 'gdm::iOperatingModeElement', "element");
					cdl::procAddIndexToTable( "operating_mode_switch", 'gdm::iOperatingMode1', "operating_mode1");
					cdl::procAddIndexToTable( "operating_mode_switch", 'gdm::iOperatingMode2', "operating_mode2");
					cdl::procAddIdentifierToTable( "operating_mode_switch", 'gdm::p01OperatingModeTransitionAllowed', "transition_allowed");
					cdl::procAddIdentifierToTable( "operating_mode_switch", 'gdm::pOperatingModeMinStayTime', "min_stay_time");
					cdl::procAddIdentifierToTable( "operating_mode_switch", 'gdm::pOperatingModeMaxStayTime', "max_stay_time");
				}
				Comment: "Defines the table structure in the database / excel files";
			}
		}
		Section Read_write_excel {
			Procedure procReadFromExcelButton {
				Body: {
					! Clear messages
					procClearMessages;
					
					if ( fileselect( spExcelFile , extension: "xlsx") = 0 ) then return; endif;
					
					! repair for special character string since the string is used in generated code
					spExcelFile := FindReplaceStrings( spExcelFile , "\\" , "\\\\" );
					
					! Define tables step 1
					procDefineTablesTime1();
					
					!Read from Excel step1 
					if ( cdl::procReadFromExcel( formatstring("%s",spExcelFile ) ) = 0 ) then
						return 0;
					endif;
					
					! change date format for excel
					procChangeDateFormatExcelRead();
					
					! Define tables step 2
					procDefineTablesTime2();
					
					!Read from Excel step2 
					if ( cdl::procReadFromExcel( formatstring("%s",spExcelFile ) ) ) then
						dialogmessage( "Excel succesfully read");
					endif;
					
					! Save the name of the loaded file
					spExcelFileDisplay := spExcelFile;
					
					! Call procedure to create the link between excel parameters and time dependent parameters in gom
					procInitializeTimeDependentData();
					
					! Call the procedure to define the set sControlModeElements
					procControlModeElementSetDefinition();
				}
				StringParameter spExcelFile;
			}
			Procedure procReadFromExcel {
				Arguments: (epAdditionalDefineTable1,epAdditionalDefineTable2,epAdditionalDefineTable3,epAdditionalDefineTable4,epAdditionalDefineTable5,epAdditionalDefineTable6,epAdditionalDefineTable7,epAdditionalDefineTable8,epAdditionalDefineTable9,epAdditionalDefineTable10,epAdditionalDefineTable11,epAdditionalDefineTable12);
				Body: {
					! Define the tables
					if( epAdditionalDefineTable1 <> '') then apply( epAdditionalDefineTable1 ); endif;
					if( epAdditionalDefineTable2 <> '') then apply( epAdditionalDefineTable2 ); endif;
					if( epAdditionalDefineTable3 <> '') then apply( epAdditionalDefineTable3 ); endif;
					if( epAdditionalDefineTable4 <> '') then apply( epAdditionalDefineTable4 ); endif;
					if( epAdditionalDefineTable5 <> '') then apply( epAdditionalDefineTable5 ); endif;
					if( epAdditionalDefineTable6 <> '') then apply( epAdditionalDefineTable6 ); endif;
					if( epAdditionalDefineTable7 <> '') then apply( epAdditionalDefineTable7 ); endif;
					if( epAdditionalDefineTable8 <> '') then apply( epAdditionalDefineTable8 ); endif;
					if( epAdditionalDefineTable9 <> '') then apply( epAdditionalDefineTable9 ); endif;
					if( epAdditionalDefineTable10 <> '') then apply( epAdditionalDefineTable10 ); endif;
					if( epAdditionalDefineTable11 <> '') then apply( epAdditionalDefineTable11 ); endif;
					if( epAdditionalDefineTable12 <> '') then apply( epAdditionalDefineTable12 ); endif;
					
					if ( fileselect( spExcelFile , extension: "xlsx") = 0 ) then return; endif;
					!if ( dialoggetstring( "Enter a name for the file.\n for example \"ASU_data\"", spExcelFile, title: "Enter a file name") = 0 ) then return; endif;
					
					! repair for special character string since the string is used in generated code
					spExcelFile := FindReplaceStrings( spExcelFile , "\\" , "\\\\" );
					
					!Read from Excel
					if ( cdl::procReadFromExcel( formatstring("%s",spExcelFile ) ) ) then
						dialogmessage( "Excel succesfully read");
					endif;
					
					! Save the name of the loaded file
					spExcelFileDisplay := spExcelFile;
				}
				ElementParameter epAdditionalDefineTable1 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable2 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable3 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable4 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable5 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable6 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable7 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable8 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable9 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable10 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable11 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable12 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				StringParameter spExcelFile;
			}
			Procedure procWriteToExcelButton {
				Body: {
					! Update timestamp
					gdm::spRunTimeStamp := CurrentToString( "%c%y-%m-%d %H:%M:%S");
					! Update model vesion
					gdm::spRunModelVersion := gdm::spModelVersion;
					
					! Ask for file to export data to
					if ( fileselectnew( spExcelFile , extension: "xlsx") = 0 ) then return; endif;
					
					! repair for special character string since the string is used in generated code
					spExcelFile := FindReplaceStrings( spExcelFile , "\\" , "\\\\" );
					
					! First update format for write to excel
					gdm::procChangeDateFormatExcelWrite();
					gdm::procDefineTablesTime2();
					
					! Export to Excel
					cdl::procWriteToExcel( spExcelFile );
					
					dialogmessage( "Excel succesfully exported");
				}
				StringParameter spExcelFile;
			}
			Procedure procWriteToExcel {
				Arguments: (epAdditionalDefineTable1,epAdditionalDefineTable2,epAdditionalDefineTable3,epAdditionalDefineTable4,epAdditionalDefineTable5,epAdditionalDefineTable6,epAdditionalDefineTable7,epAdditionalDefineTable8,epAdditionalDefineTable9,epAdditionalDefineTable10,epAdditionalDefineTable11,epAdditionalDefineTable12);
				Body: {
					! Update timestamp
					spRunTimeStamp := CurrentToString( "%c%y-%m-%d %H:%M:%S");
					
					! Update model vesion
					spRunModelVersion := spModelVersion;
					
					! Define the tables
					if( epAdditionalDefineTable1 <> '') then apply( epAdditionalDefineTable1 ); endif;
					if( epAdditionalDefineTable2 <> '') then apply( epAdditionalDefineTable2 ); endif;
					if( epAdditionalDefineTable3 <> '') then apply( epAdditionalDefineTable3 ); endif;
					if( epAdditionalDefineTable4 <> '') then apply( epAdditionalDefineTable4 ); endif;
					if( epAdditionalDefineTable5 <> '') then apply( epAdditionalDefineTable5 ); endif;
					if( epAdditionalDefineTable6 <> '') then apply( epAdditionalDefineTable6 ); endif;
					if( epAdditionalDefineTable7 <> '') then apply( epAdditionalDefineTable7 ); endif;
					if( epAdditionalDefineTable8 <> '') then apply( epAdditionalDefineTable8 ); endif;
					if( epAdditionalDefineTable9 <> '') then apply( epAdditionalDefineTable9 ); endif;
					if( epAdditionalDefineTable10 <> '') then apply( epAdditionalDefineTable10 ); endif;
					if( epAdditionalDefineTable11 <> '') then apply( epAdditionalDefineTable11 ); endif;
					if( epAdditionalDefineTable12 <> '') then apply( epAdditionalDefineTable12 ); endif;
					
					! Ask for file to export data to
					if ( fileselectnew( spExcelFile , extension: "xlsx") = 0 ) then return; endif;
					!if ( dialoggetstring( "Enter a name for the file.\n for example \"ASU_data\"", spExcelFile, title: "Enter a file name") = 0 ) then return; endif;
					
					! repair for special character string since the string is used in generated code
					spExcelFile := FindReplaceStrings( spExcelFile , "\\" , "\\\\" );
					
					! Export to Excel
					cdl::procWriteToExcel( spExcelFile );
					
					dialogmessage( "Excel succesfully exported");
				}
				Comment: "Write the generic data to Excel";
				ElementParameter epAdditionalDefineTable1 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable2 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable3 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable4 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable5 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable6 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable7 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable8 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable9 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable10 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable11 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable12 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				StringParameter spExcelFile;
			}
			Procedure procChangeDateFormatExcelRead {
				Body: {
					gdm::spBeginCalendar := gdm::spBeginCalendarExcel;
					gdm::spEndCalendar := gdm::spEndCalendarExcel;
				}
			}
			Procedure procChangeDateFormatExcelWrite {
				Body: {
					gdm::spBeginCalendarExcel := "'" + gdm::spBeginCalendar;
					gdm::spEndCalendarExcel := "'" + gdm::spEndCalendar;
				}
			}
		}
		Section Read_write_database {
			Procedure procReadFromDatabase {
				Arguments: (spSchema,spRun,epAdditionalDefineTable1,epAdditionalDefineTable2,epAdditionalDefineTable3,epAdditionalDefineTable4,epAdditionalDefineTable5,epAdditionalDefineTable6,epAdditionalDefineTable7,epAdditionalDefineTable8,epAdditionalDefineTable9,epAdditionalDefineTable10,epAdditionalDefineTable11,epAdditionalDefineTable12);
				Body: {
					! Clear old data
					procEmptyAllData();
					
					gdm::spRun := spRun;
					gdm::spSchemaName := spSchema;
					
					! Define the tables
					if( epAdditionalDefineTable1 <> '') then apply( epAdditionalDefineTable1 ); endif;
					if( epAdditionalDefineTable2 <> '') then apply( epAdditionalDefineTable2 ); endif;
					if( epAdditionalDefineTable3 <> '') then apply( epAdditionalDefineTable3 ); endif;
					if( epAdditionalDefineTable4 <> '') then apply( epAdditionalDefineTable4 ); endif;
					if( epAdditionalDefineTable5 <> '') then apply( epAdditionalDefineTable5 ); endif;
					if( epAdditionalDefineTable6 <> '') then apply( epAdditionalDefineTable6 ); endif;
					if( epAdditionalDefineTable7 <> '') then apply( epAdditionalDefineTable7 ); endif;
					if( epAdditionalDefineTable8 <> '') then apply( epAdditionalDefineTable8 ); endif;
					if( epAdditionalDefineTable9 <> '') then apply( epAdditionalDefineTable9 ); endif;
					if( epAdditionalDefineTable10 <> '') then apply( epAdditionalDefineTable10 ); endif;
					if( epAdditionalDefineTable11 <> '') then apply( epAdditionalDefineTable11 ); endif;
					if( epAdditionalDefineTable12 <> '') then apply( epAdditionalDefineTable12 ); endif;
					
					! Read from database
					cdl::procReadFromDatabase( epSelectedDatabaseType, spConnectionString, spRun );
				}
				ElementParameter epAdditionalDefineTable1 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable2 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable3 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable4 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable5 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable6 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable7 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable8 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable9 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable10 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable11 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable12 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				StringParameter spSchema {
					Property: Input;
				}
				StringParameter spRun {
					Property: Input;
				}
			}
			Procedure procReadFromDatabaseMerge {
				Arguments: (spSchema,spRun,epAdditionalDefineTable1,epAdditionalDefineTable2,epAdditionalDefineTable3,epAdditionalDefineTable4,epAdditionalDefineTable5,epAdditionalDefineTable6,epAdditionalDefineTable7,epAdditionalDefineTable8,epAdditionalDefineTable9,epAdditionalDefineTable10,epAdditionalDefineTable11,epAdditionalDefineTable12);
				Body: {
					gdm::spRun := spRun;
					gdm::spSchemaName := spSchema;
					
					! Define the tables
					if( epAdditionalDefineTable1 <> '') then apply( epAdditionalDefineTable1 ); endif;
					if( epAdditionalDefineTable2 <> '') then apply( epAdditionalDefineTable2 ); endif;
					if( epAdditionalDefineTable3 <> '') then apply( epAdditionalDefineTable3 ); endif;
					if( epAdditionalDefineTable4 <> '') then apply( epAdditionalDefineTable4 ); endif;
					if( epAdditionalDefineTable5 <> '') then apply( epAdditionalDefineTable5 ); endif;
					if( epAdditionalDefineTable6 <> '') then apply( epAdditionalDefineTable6 ); endif;
					if( epAdditionalDefineTable7 <> '') then apply( epAdditionalDefineTable7 ); endif;
					if( epAdditionalDefineTable8 <> '') then apply( epAdditionalDefineTable8 ); endif;
					if( epAdditionalDefineTable9 <> '') then apply( epAdditionalDefineTable9 ); endif;
					if( epAdditionalDefineTable10 <> '') then apply( epAdditionalDefineTable10 ); endif;
					if( epAdditionalDefineTable11 <> '') then apply( epAdditionalDefineTable11 ); endif;
					if( epAdditionalDefineTable12 <> '') then apply( epAdditionalDefineTable12 ); endif;
					
					! Read from database
					cdl::procReadFromDatabase( epSelectedDatabaseType, spConnectionString, spRun );
				}
				ElementParameter epAdditionalDefineTable1 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable2 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable3 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable4 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable5 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable6 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable7 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable8 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable9 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable10 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable11 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable12 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				StringParameter spSchema {
					Property: Input;
				}
				StringParameter spRun {
					Property: Input;
				}
			}
			Procedure procWriteToDatabase {
				Arguments: (epAdditionalDefineTable1,epAdditionalDefineTable2,epAdditionalDefineTable3,epAdditionalDefineTable4,epAdditionalDefineTable5,epAdditionalDefineTable6,epAdditionalDefineTable7,epAdditionalDefineTable8,epAdditionalDefineTable9,epAdditionalDefineTable10,epAdditionalDefineTable11,epAdditionalDefineTable12);
				Body: {
					! Update timestamp
					spRunTimeStamp := CurrentToString( "%c%y-%m-%d %H:%M:%S");
					
					! Update model vesion
					spRunModelVersion := spModelVersion;
					
					! Define the tables
					if( epAdditionalDefineTable1 <> '') then apply( epAdditionalDefineTable1 ); endif;
					if( epAdditionalDefineTable2 <> '') then apply( epAdditionalDefineTable2 ); endif;
					if( epAdditionalDefineTable3 <> '') then apply( epAdditionalDefineTable3 ); endif;
					if( epAdditionalDefineTable4 <> '') then apply( epAdditionalDefineTable4 ); endif;
					if( epAdditionalDefineTable5 <> '') then apply( epAdditionalDefineTable5 ); endif;
					if( epAdditionalDefineTable6 <> '') then apply( epAdditionalDefineTable6 ); endif;
					if( epAdditionalDefineTable7 <> '') then apply( epAdditionalDefineTable7 ); endif;
					if( epAdditionalDefineTable8 <> '') then apply( epAdditionalDefineTable8 ); endif;
					if( epAdditionalDefineTable9 <> '') then apply( epAdditionalDefineTable9 ); endif;
					if( epAdditionalDefineTable10 <> '') then apply( epAdditionalDefineTable10 ); endif;
					if( epAdditionalDefineTable11 <> '') then apply( epAdditionalDefineTable11 ); endif;
					if( epAdditionalDefineTable12 <> '') then apply( epAdditionalDefineTable12 ); endif;
					
					! Write to database
					cdl::procWriteToDatabase(epSelectedDatabaseType, spConnectionString, spRun );
					
					! Read cases from database
					cdl::procGetCasesFromDatabase( epSelectedDatabaseType, spConnectionString, 'gdm::iCase' );
				}
				ElementParameter epAdditionalDefineTable1 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable2 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable3 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable4 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable5 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable6 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable7 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable8 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable9 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable10 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable11 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				ElementParameter epAdditionalDefineTable12 {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
					Property: Optional;
				}
				Parameter pDialogAsk;
				Parameter pOk {
					Range: binary;
				}
			}
			Procedure procDeleteCaseFromDatabase {
				Body: {
					
					! Read cases from database
					cdl::procGetCasesFromDatabase( epSelectedDatabaseType, spConnectionString, 'gdm::iCase' );
					
					! Ask user which case he wants to delete from the database
					if( dialoggetElement( "Select case to delete" , epCaseToDelete ) = 0 ) then return; endif;
					spCaseToDelete := formatstring("%e",epCaseToDelete);
					
					! Are you sure?
					if ( DialogAsk( formatstring("Are you sure to delete dataset %s?", spCaseToDelete), "Yes", "No", title: "Delete from database") <> 1 ) then return; endif;
					
					! Delete from database
					cdl::procDeleteFromDatabase( epSelectedDatabaseType, spConnectionString, spCaseToDelete );
					
					! Read cases from database
					cdl::procGetCasesFromDatabase( epSelectedDatabaseType, spConnectionString, 'gdm::iCase' );
					
					dialogmessage( "Database succesfully deleted");
				}
				ElementParameter epCaseToDelete {
					Range: sCases;
				}
				StringParameter spCaseToDelete;
			}
		}
	}
	Section Data_validation_procedures {
		Procedure procControlModeElementSetDefinition {
			Body: {
				! Define the list of control elements following the type of the elements (ColdBoxes and Arcs with the types : Compressor, Liquefier or Backup)
				gdm::sControlModeElements := { gdm::iArcAndBox | gdm::epArcType( gdm::iArcAndBox ) = gdm::epArcTypeCompressor
								or gdm::epArcType( gdm::iArcAndBox ) = gdm::epArcTypeLiquefier 
								or gdm::epArcType( gdm::iArcAndBox ) = gdm::epArcTypeBackup 
								or gdm::iArcAndBox in gdm::sboxes
								};
			}
		}
		Procedure procCheckData {
			Body: {
				! 2017-07-20 Irene Lotero: I commented this line. I do not want to loose reading errors.
				!procClearMessages;
				
				! Automaticaly check that all defined scalar element parameters are filled
				sAllDataIdentifiers := {IndexIdentifiers|
								IndexIdentifiers in Data_declaration
								and 
								IdentifierType(IndexIdentifiers) = 'element parameter'
								and
								IdentifierDimension( IndexIdentifiers ) = 0
								};
				procCheckElementParameters(sAllDataIdentifiers);
				
				/********************
				! Architecture
				********************/
				procCheckNodes;
				procCheckArcs;
				
				! other entities
				
				
				! check that each auxiliary power group is assigned to a Energy Contract
				for( iAuxPowerGroup | epAuxPowerGroupEnergyContract( iAuxPowerGroup ) = '' ) do
					log_message::procLogError( 0, '', formatstring( "Auxiliary power group %e is not assigned to an energy contract", iAuxPowerGroup ) );
				endfor;
				!check that each tank has a liquid product assigned
				for( iTankNode | epTankLiquidProduct( iTankNode ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "There is no liquid product assigned to tank %e", iTankNode ) );
				endfor;
				
				/*******************
				Check the data values
				*******************/
				
				!for nodes
				for( iNode | pNodeMaxPressure( iNode ) <  pNodeMinPressure( iNode ) ) do
					log_message::procLogError( 2, '', formatstring( "Node %e has max pressure < min pressure", iNode ) );
				endfor;
				
				for( ( iOutputFlowNode, iTime ) | pOutputFlowNodeMaxFlow( iOutputFlowNode, iTime ) <  pOutputFlowNodeMinFlow( iOutputFlowNode, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Customer %e has max flow < min flow", ( iOutputFlowNode ) ) );
				endfor;
				
				for( ( iInputFlowNode, iTime ) | pInputFlowNodeMaxFlow( iInputFlowNode, iTime ) <  pInputFlowNodeMinFlow( iInputFlowNode, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Input flow node %e has max flow < min flow", ( iInputFlowNode ) ) );
				endfor;
				for( iTankNode | pTankStorageCapacity( iTankNode ) < 0 ) do
					log_message::procLogError( 1, '', formatstring( "Tank node %e has negative or zero storage capacity", iTankNode ) );
				endfor;
				
				!for arcs
				for( (iArc, iTime) | pArcMaxFlow( iArc ) < pArcMinFlow( iArc ) ) do
					log_message::procLogError( 2, '', formatstring( "Arc %e has max flow < min flow" , iArc ) );
				endfor;
				
				for( (iCompressorArc, iTime) | pCompressorMaxFlow( iCompressorArc, iTime ) < pCompressorMinFlow( iCompressorArc, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Compressor %e has max flow < min flow", ( iCompressorArc ) ) );
				endfor;
				for( (iLiquefierArc, iTime) | pLiquefierMaxFlow( iLiquefierArc, iTime ) <  pLiquefierMinFlow( iLiquefierArc, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Liquefier %e has max flow < min flow", iLiquefierArc ) );
				endfor;
				!the min and max flow for the compressor should be between the min and max flow for the corresponding arc
				for( (iCompressorArc, iTime) | pCompressorMinFlow( iCompressorArc, iTime ) < pArcMinFlow( iCompressorArc) ) do 
					log_message::procLogError( 2, '', formatstring( "Compressor %e has min flow < min flow on the corresponding arc", iCompressorArc ) );
				endfor;
				for( (iCompressorArc, iTime) | pCompressorMaxFlow( iCompressorArc, iTime ) > pArcMaxFlow( iCompressorArc) ) do 
					log_message::procLogError( 2, '', formatstring( "Compressor %e has max flow > max flow on the corresponding arc", iCompressorArc ) );
				endfor;
				!the min and max flow for the liquefier should be between the min and max flow for the corresponding arc
				for( (iLiquefierArc, iTime) | pLiquefierMinFlow( iLiquefierArc, iTime ) < pArcMinFlow( iLiquefierArc) ) do 
					log_message::procLogError( 2, '', formatstring( "Liquefier %e has min flow < min flow on the corresponding arc", iLiquefierArc) );
				endfor;
				for( (iLiquefierArc, iTime) | pLiquefierMaxFlow( iLiquefierArc, iTime ) > pArcMaxFlow( iLiquefierArc ) ) do 
					log_message::procLogError( 2, '', formatstring( "Liquefier %e has max flow > max flow on the corresponding arc", iLiquefierArc ) );
				endfor;
				
				!for other entities
				for( (iBackupArc, iTime) | pBackupMaxFlow( iBackupArc, iTime ) < pBackupMinFlow( iBackupArc, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Backup %e has max flow < min flow", iBackupArc ) );
				endfor;
				for( (iBackupArc) | not p01BackupFlashSpecificEquation(iBackupArc) and not(epNodeFrom(iBackupArc) in sTankNodes)  ) do
					log_message::procLogError( 1, '', formatstring( "Backup %e is not connected to a Tank", iBackupArc ) );
				endfor;
				
				for( ( iTankNode, iTime ) | pTankMaxLevel( iTankNode, iTime ) < pTankMinLevel( iTankNode, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Tank max level < tank min level for %e, %e", iTankNode, iTime ) );
				endfor;
				for( ( iColdbox, iColdboxInternalFlow, iTime ) | pColdboxMaxInternalFlow( iColdbox, iColdboxInternalFlow, iTime ) < pColdboxMinInternalFlow( iColdbox, iColdboxInternalFlow, iTime ) ) do
					log_message::procLogError( 2, '', formatstring( "Coldbox %e has max flow < min flow on %e", iColdbox, iColdboxInternalFlow ) );
				endfor;
				for( (iColdbox,iTime) | pColdboxMaxInternalFlow(iColdbox, epGoxToWaste, iTime) < pColdboxMinInternalFlow(iColdbox, epGoxToWaste, iTime) ) do
					log_message::procLogError( 2, '', formatstring("Coldbox %e has max Gox to waste flow < min Gox to waste flow", iColdbox ) );
				endfor;
				for( (iColdbox,iTime) | pColdboxMaxInternalFlow(iColdbox, epInternalLiquid, iTime) < pColdboxMinInternalFlow(iColdbox, epInternalLiquid, iTime) ) do
					log_message::procLogError( 2, '', formatstring( "Coldbox %e has max internal liquid < min internal liquid", iColdbox ) );
				endfor;
				for( (iColdbox,iTime) | pColdboxMaxInternalFlow(iColdbox, epTotalAir, iTime) < pColdboxMinInternalFlow(iColdbox, epTotalAir, iTime) ) do
					log_message::procLogError( 2, '', formatstring( "Coldbox %e has max total air < min total air", iColdbox ) );
				endfor;
				for ( (iColdbox,iTime) | pColdboxMaxInternalFlow(iColdbox, epAirTurbineLp, iTime) < pColdboxMinInternalFlow(iColdbox, epAirTurbineLp, iTime)) do
					log_message::procLogError( 2, '', formatstring( "Coldbox %e has max air turbine Lp < min air turbine Lp ", iColdbox ) );
				endfor;
				for( iProduct | pLiquidEqCoef( iProduct ) = 0 and iProduct<>epProductAir) do
					log_message::procLogError( 1, '', formatstring( "Liquid product %e has equation coefficient 0", iProduct ) );
				endfor;
				
				! Coldbox parameters
				for ( iColdbox | 
					gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationLPLevelControl) <> 0
					and 
					gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationLPLevelControl) <> 1 ) do
					log_message::procLogError( 2, '', formatstring( "Coldbox Parameter Value %e is not binary ", gdm::epColdboxTurbInsufflationLPLevelControl ) );
				endfor;
				for ( iColdbox | 
					gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationManualControl) > 0
					and 
					gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationLPLevelControl) > 0
					and 
					gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxTurbInsufflationRemoteControl) > 0 ) do
					log_message::procLogError( 2, '', formatstring( "Only one of the three parameters for the turbine insufflation can be nonzero for Coldbox %e ", iColdbox ) );
				endfor;
			}
			Comment: {
				"This function does some basic checks on the validity of data
				Severity 1 is used for general data error messages.
				Severity 2 is used if we already know that the model cannot be solved. Data needs to be repaired first."
			}
			Set sAllDataIdentifiers {
				SubsetOf: AllIdentifiers;
			}
		}
		Procedure procCheckNodes {
			Body: {
				! check if all nodes are connected to other nodes, except for connection nodes (node type ..connection)
				for( iNode | count( iArc, epNodeFrom( iArc ) = iNode or epNodeTo( iArc ) = iNode ) = 0 and not 
						( epNodeType( iNode ) = epNodeTypeBoxConnection ) ) do 
					log_message::procLogError( 1, '', formatstring( "Node %e not connected", iNode ) );
				endfor;
				
				! check if all nodes have a node type defined
				for( iNode | epNodeType( iNode ) = '' ) do
					log_message::procLogError( 1, '', formatstring( "Node %e does not have a node type defined", iNode ) );
				endfor;
				
				! check if node types correspond to node usage
				for( iNode | exists( ( iBox, iBoxNodeConnectionType ) | epBoxNode( iBox, iBoxNodeConnectionType ) = iNode ) and
					( epNodeType( iNode ) <> epNodeTypeBoxConnection ) ) do
					log_message::procLogError( 1, '', formatstring( "Node %e is used as a Box connection, but has type %e", iNode , epNodeType( iNode ) ) );
				endfor;
				
				! check if all nodes in the table nodes with a connection type, are connected to an entity
				for( iNode | epNodeType( iNode ) = epNodeTypeBoxConnection and
					not exists( (iBox, iBoxNodeConnectionType) | epBoxNode( iBox, iBoxNodeConnectionType ) = iNode ) ) do
					log_message::procLogError( 1, '', formatstring( "Node %e has type coldbox connection, but is not connected to a coldbox", iNode ) );
				endfor;
				
				/*
				! check if each pressure control node has setpoint
				for( (iPressureControlNode,iTime) | pPressureControlNodeSetpoint( iPressureControlNode , iTime ) = 0 ) do
					log_message::procLogError( 1, '', formatstring( "Pressure control node %e does not have a setpoint", iPressureControlNode ) );
				endfor;
				for( (iPressureControlNode,iTime) | pPressureControlNodeSetpoint( iPressureControlNode , iTime ) < pNodeMinPressure( iPressureControlNode ) ) do
				 	log_message::procLogError( 2, '', formatstring( "Pressure control node %e has a setpoint less than the minimum pressure for the node", iPressureControlNode ) );
				endfor;
				for( (iPressureControlNode,iTime) | pPressureControlNodeSetpoint( iPressureControlNode , iTime ) > pNodeMaxPressure( iPressureControlNode ) ) do
				 	log_message::procLogError( 2, '', formatstring( "Pressure control node %e has a setpoint greater than the maximum pressure for the node", iPressureControlNode ) );
				endfor;
				*/
				
				/* EL 13/01/2022 (v3) : Decide with TR to come back to the solution of the v222c about this modification "cooldown for liquefire" it was a bad idea.
				
				! Output Flow Node
				!make sure that an Output Flow Node is linked to the outlet of the liquefier if cool-down operating mode is allowed for the liquefier
				for( (iLiquefierArc, iTime) | 
					p01OperatingModeAllowed( iLiquefierArc, epOperatingModeTypeCoolDown, iTime) = 1
					and 
					not exists(iOutputFlowNode, iOutputFlowNode = epNodeTo(iLiquefierArc)) ) do
					log_message::procLogError( 2, '', formatstring( "Liquefier %e doesn't have an Output Flow Node", iLiquefierArc ) );
				endfor;
				!check that fixed_value of the OutputFlowNode is not defined and that Min Flow is 0 and Max Flow  >= Max Liquefier (capability to purge the entire production)
				for( ( iLiquefierArc, iOutputFlowNode, iTime ) | 
					(p01OperatingModeAllowed( iLiquefierArc, epOperatingModeTypeCoolDown, iTime) = 1
					and 
					iOutputFlowNode = epNodeTo(iLiquefierArc))
					and
					not ((pOutputFlowFixed( iOutputFlowNode, iTime ) = '') or (pOutputFlowFixed( iOutputFlowNode, iTime ) = 0))
					and
					pOutputFlowNodeMinFlow( iOutputFlowNode, iTime ) <> 0 
					and
					pOutputFlowNodeMaxFlow( iOutputFlowNode, iTime ) < pLiquefierMaxFlow(iLiquefierArc | iOutputFlowNode = epNodeTo(iLiquefierArc), iTime) ) do
					log_message::procLogError( 2, '', formatstring( "fixed_value of the %e is defined or that Min Flow is 0 and Max Flow  <= Max Liquefier (not possible to purge the entire production)", ( iOutputFlowNode ) ) );
				endfor;
				
				*/
			}
		}
		Procedure procCheckArcs {
			Body: {
				! check that all arcs have a node from and to
				for( iArc | epNodeFrom( iArc ) = '' or epNodeTo( iArc ) = '' ) do
					log_message::procLogError( 1, '', formatstring( "Arc %e is not completely connected in flow network", iArc ) );
				endfor;
				! check that the from and to node for an arc are different
				for( iArc | epNodeFrom( iArc ) = epNodeTo( iArc ) and epNodeFrom( iArc ) <> '' ) do
					log_message::procLogError( 2, '', formatstring( "Arc %e has the same from and to node", iArc ) );
				endfor;
				! check that each compressor is assigned to a energy contract
				for( iCompressorArc | epCompressorEnergyContract( iCompressorArc ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "Compressor %e is not assigned to a energy contract", iCompressorArc ) );
				endfor;
				! check that there is no problem with compressor dependencies (so not A should run together with B, and B cannot run together with A)
				for( ( iCompressorDependency, iCompressorDependency2 ) | 
					exists( (iCompressorArc, iCompressorArc2 ), 
					( epCompressorMapSpecial_1( iCompressorDependency ) = iCompressorArc and epCompressorMapSpecial_2( iCompressorDependency ) = iCompressorArc2 )  and 
					( ( epCompressorMapSpecial_1( iCompressorDependency2 ) = iCompressorArc and epCompressorMapSpecial_2( iCompressorDependency2 ) = iCompressorArc2 ) or
					( epCompressorMapSpecial_1( iCompressorDependency2 ) = iCompressorArc2 and epCompressorMapSpecial_2( iCompressorDependency2 ) = iCompressorArc ) ) ) and 
					p01CompressorRunTogether( iCompressorDependency ) <> p01CompressorRunTogether( iCompressorDependency2 ) ) do
					log_message::procLogError( 2, '', formatstring( "Compressor dependency %e and %e are conflicting", iCompressorDependency, iCompressorDependency2 ) );
				endfor;
				! check that each compressor is assigned to a cooling tower
				for( iCompressorArc | epCompressorCoolingTower( iCompressorArc ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "Compressor %e is not assigned to a cooling tower", iCompressorArc ) );
				endfor;
				!! check that each compressor is assigned to an auxiliary power group
				!for( iCompressorArc | epCompressorAuxPowerGroup( iCompressorArc ) = '' ) do
				!	log_message::procLogError( 1, '', formatstring( "Compressor %e is not assigned to an auxiliary power group", iCompressorArc ) );
				!endfor; 
				
				!if a Compressor is assigned to an auxiliary power group, then they should be assigned to the same energy contract
				for( (iCompressorArc, iAuxPowerGroup) | (epCompressorAuxPowerGroup( iCompressorArc ) = iAuxPowerGroup and
					epCompressorEnergyContract( iCompressorArc ) <> epAuxPowerGroupEnergyContract( iAuxPowerGroup )) ) do
					log_message::procLogError( 1, '', formatstring( "Compressor %e is assigned to auxiliary power group %e, but they are not assigned to the same energy contract", iCompressorArc, iAuxPowerGroup ) );
				endfor;
				! check that each liquefier is assigned to a cooling tower
				for( iLiquefierArc | epLiquefierCoolingTower( iLiquefierArc ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "Liquefier %e is not assigned to a cooling tower", iLiquefierArc ) );
				endfor;
				! check that each liquefier is assigned to a energy contract
				for( iLiquefierArc | epLiquefierEnergyContract( iLiquefierArc ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "Liquefier %e is not assigned to a energy contract", iLiquefierArc ) );
				endfor;
				!! check that each liquefier is assigned to an auxiliary power group
				!for( iLiquefierArc | epLiquefierAuxPowerGroup( iLiquefierArc ) = '' ) do
				!	log_message::procLogError( 1, '', formatstring( "Liquefier %e is not assigned to an auxiliary power group", iLiquefierArc ) );
				!endfor; 
				
				!if a liquefier is assigned to an auxiliary power group, then they should be assigned to the same energy contract
				for( (iLiquefierArc, iAuxPowerGroup) | (epLiquefierAuxPowerGroup( iLiquefierArc ) = iAuxPowerGroup and
					epLiquefierEnergyContract( iLiquefierArc ) <> epAuxPowerGroupEnergyContract( iAuxPowerGroup )) ) do
					log_message::procLogError( 1, '', formatstring( "Liquefier %e is assigned to auxiliary power group %e, but they are not assigned to the same energy contract", iLiquefierArc, iAuxPowerGroup ) );
				endfor;
				! check that if a liquefier has calculation mode special, it has both a compressor feed & cycle and a cycle
				for( iLiquefierArc | epLiquefierCalculationMode( iLiquefierArc ) = epLiquefierCalculationModeAdvanced and 
					epLiquefierCompressorFeed( iLiquefierArc ) = '' ) do
					log_message::procLogError( 1, '', formatstring( "Liquefier %e has calculation mode advanced, but does not have a compressor feed", iLiquefierArc ) );
				endfor;
				for( iLiquefierArc | epLiquefierCalculationMode( iLiquefierArc ) = epLiquefierCalculationModeAdvanced and 
					epLiquefierCompressorCycle( iLiquefierArc ) = '' ) do
					log_message::procLogError( 1, '', formatstring( "Liquefier %e has calculation mode advanced, but does not have a compressor cycle", iLiquefierArc ) );
				endfor;
				for( iLiquefierArc | epLiquefierCalculationMode( iLiquefierArc ) = epLiquefierCalculationModeAdvanced and 
					epLiquefierCycle( iLiquefierArc ) = '' ) do
					log_message::procLogError( 1, '', formatstring( "Liquefier %e has calculation mode advanced, but does not have a cycle", iLiquefierArc ) );
				endfor;
				! and check that the liquefier and compressor are assigned to the same aux power group (if this is true, then they are also linked to the same energy contract)
				for( (iLiquefierArc, iCompressorArc) | (epLiquefierCompressorCycle( iLiquefierArc ) = iCompressorArc and 
					epLiquefierAuxPowerGroup( iLiquefierArc ) <> epCompressorAuxPowerGroup ( iCompressorArc )) ) do
					log_message::procLogError( 1, '', formatstring( "Liquefier %e and compressor %e are linked, but not assigned to the same aux power group", iLiquefierArc, iCompressorArc ) );
				endfor;
				! check that each valve has a max pressure > 0
				for( iValveArc | pValveDeltaPressureMax( iValveArc ) <= 0 ) do
					log_message::procLogError( 1, '', formatstring( "Valve %e has delta pressure max equal to zero", iValveArc ) );
				endfor;
				! check that each valve has a control mode defined
				for( (iValveArc, gdm::iTime) | epValveControlMode( iValveArc, gdm::iTime ) = '' ) do
					log_message::procLogError( 2, '', formatstring( "There is no control mode defined for valve %e", iValveArc ) );
				endfor;
			}
		}
		StringParameter spSevereErrorForSolve;
		Section DVSubProcedures {
			Procedure procClearMessages {
				Body: {
					log_message::procCleanLogMessages(1);
					spReadErrorMessage(iCounterOfTableList):="";
					pCountTableList := 1;
				}
			}
			Procedure procCheckElementParameters {
				Arguments: (sIdentifiers);
				Body: {
					!Check if runtime library exists. If so, then delete
					if StringToElement(AllIdentifiers, "CQM_DATA_VALIDATION", 0)  <> '' then
						me::Delete( StringToElement(AllIdentifiers, "CQM_DATA_VALIDATION", 0) );
					endif;
					
					!Create the runtime library
					epLib := me::CreateLibrary(libraryName :  "CQM_DATA_VALIDATION", prefixName  :  "cdv");
					epProc := me::Create( "CheckElementParameters", 'procedure', epLib);
					
					!All parameters with a definition, check if they are non-zero
					empty psTxt;
					for(IndexDefinedParameters|
						IndexDefinedParameters in sIdentifiers
						) do
						psTxt += formatstring("if %e = '' then log_message::procLogError(1,\'\',\"%e is empty\"); endif;\n",
						IndexDefinedParameters,IndexDefinedParameters);
					endfor;
					
					me::SetAttribute(epProc, 'body', psTxt);
					me::Compile(epLib);
					apply(epProc);
					if StringToElement(AllIdentifiers, "CQM_DATA_VALIDATION", 0)  <> '' then
						me::Delete( StringToElement(AllIdentifiers, "CQM_DATA_VALIDATION", 0) );
					endif;
				}
				ElementParameter epLib {
					Range: AllIdentifiers;
				}
				ElementParameter epProc {
					Range: AllProcedures;
					Default: 'gdm::procDummy';
				}
				StringParameter psTxt;
				Set sIdentifiers {
					SubsetOf: AllIdentifiers;
					Index: iId;
					Property: InOut;
				}
			}
			Procedure procDummy;
		}
	}
	Procedure procEmptyAllData {
		Body: {
			
			empty Data_declaration;
			empty Declaration_Time_Dependent_Parameters;
		}
	}
}
