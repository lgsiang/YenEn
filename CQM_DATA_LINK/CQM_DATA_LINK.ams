## ams_version=1.0

LibraryModule CQM_DATA_LINK {
	Prefix: cdl;
	Interface: {
		data { procClear, procAddCaseTable, procAddTable, procAddIndexToTable, procAddIdentifierToTable, 
		       sDatabaseTypes, procWriteToExcel, procReadFromExcel, procDetermineConsecutiveRange, 
		       procReadFromDatabase, procWriteToDatabase, procDeleteFromDatabase, procGetCasesFromDatabase, 
		       procPrintDocumentation, sTables }
	}
	Comment: {
		"The CQM DATA LINK library is developed by CQM to facilitate communication between AIMMS and external
		data sources, like Excel and databases.
		
		/*---- Copyright statement ----*/
		(c) CQM b.v.
		All Rights Reserved. No part of this libary may be reproduced, distributed, or transmitted in
		any form or by any means, including photocopying, recording, or other electronic or mechanical
		methods, without the prior written permission of CQM b.v.
		(web: www.cqm.nl / tel: 0031407502300 / email: info@cqm.nl)
		
		/*---- How to use the CQM DATA LINK library ----*/
		Before using this libary make sure the library is empty:
		- Run procClear.
		
		Then define tables (for Excel files a table corresponds to a \'sheet\') as follows:
		0) Use the procedure procAddCaseTable to define the table of cases and the reference to case in other tables
			- No indices can be added to the case table, but scalar identifiers can be added.
		1) Use the procedure procAddTable to define the table
			- Communication of data to and from the tables will be done in order of defining the tables
		2) Add indices to a table via the procedure procAddIndexToTable
			- The order of adding the indices must be the same as the order of indices use in the parameters
		3) Add identifier (string paramter, parameter, element parameter, variable,..) to a table
			- All indices must be added first to the table
			- The order of indices used in the parameter must be equal to the order indices are added to the table
			- All parameters in one table must have the same indices in the same order
		
		The database link assumes there is a table for cases with a column called \'case\' and that
		all other tables contain a column called \'case\' that refers to this table and has foreign key
		relation that cascades on delete. The actual name of the case table and column reference can be supplied.
		
		When all tables are defined the data link can be used via:
		- Write to Excel via procWriteToExcel
		- Read from Excel via procReadFromExcel
		- Write a case to Database via procWriteToDatabase
		- Read a case from Database via procReadFromDatabase
		- Delete a case from Database via procDeleteFromDatabase
		- Get list of available cases from Database via procGetCasesFromDatabase
		- Create a report with the interface documentation via procPrintDocumentation"
	}
	Procedure procClear {
		Body: {
			Empty CQM_DATA_LINK;
			CLEANUP CQM_DATA_LINK;
			gdm::pCountTableList := gdm::pCountTableList + 1;
		}
		Comment: "Empty the library before usage";
	}
	Section Input_data {
		Procedure procAddCaseTable {
			Arguments: (spCaseTableName,spCaseTableSchema,spCaseName,spDescription);
			Body: {
				!check if this is the first table added
				if( card( sTables ) > 0 )
				then
					procRaiseError( "Input", "Unable to define Case Table, it is not the first table defined" );
					return 0;
				endif;
				
				!Store the Case table schema
				cdl::spCaseTableSchema := spCaseTableSchema;
				
				!Store the Case table name
				cdl::spCaseTableName := spCaseTableName;
				
				!Store the case name
				cdl::spCaseName := spCaseName;
				
				!Add case table to set of tables
				return procAddTable( spCaseTableName,spCaseTableSchema, 1, spDescription );
			}
			StringParameter spCaseTableSchema {
				Property: Input;
			}
			StringParameter spCaseTableName {
				Property: Input;
			}
			StringParameter spCaseName {
				Property: Input;
			}
			StringParameter spDescription {
				Property: Optional;
			}
		}
		Procedure procAddTable {
			Arguments: (spTable,spSchema,p01WriteDense,spDescription,p01PushToFront);
			Body: {
				!First check if the table is not already there
				epTable := StringToElement( sTables, spTable, Create : 0 );
				if( epTable <> '' )
				then
					!Error: table is already defined
					procRaiseError( "Input", formatstring( "Table %s is already defined", spTable) );
					return 0;
				endif;
				
				epTable := StringToElement( sTables, spTable, Create : 1 );
				if( epTable = '' )
				then
					!Error: table can not be defined. Perhaps the name is not valid.
					procRaiseError( "Input", formatstring( "Unable to define Table %s", spTable) );
					return 0;
				endif;
				
				!Order of defining table is relevant for foreign key relations
				!Tables are writen and read in order of defining them, unless push to front is used
				if( p01PushToFront )
				then
					pOrderTables( iTable | pOrderTables(iTable) > 1) += 1;
					pOrderTables( epTable ) := 2;
				else
					pOrderTables( epTable ) := card( sTables );
				endif;
				
				!Store the schema
				spTableSchema( epTable ) := spSchema;
				
				!Store the dense write property
				p01TableWriteDense( epTable ) := p01WriteDense;
				
				!Store the description
				procAddLineEndsToDescription( spDescription, 75 );
				spTableDescription( epTable ) := spDescription;
				
				!Succesfull creation of the table
				return 1;
			}
			Comment: {
				"Defines a new table.
				The schema is needed if and only if communcation with a database takes place.
				Returns 1 on succes, 0 on failure"
			}
			StringParameter spTable {
				Property: Input;
				Comment: "Name of the table in the database or Excel";
			}
			StringParameter spSchema {
				Property: Optional;
				Comment: "Only needed if communication is done with a database";
			}
			Parameter p01WriteDense {
				Range: binary;
				Property: Optional;
				Comment: "1 if the table needs to writen in dense mode.";
			}
			StringParameter spDescription {
				Property: Optional;
			}
			Parameter p01PushToFront {
				Range: binary;
				Default: 0;
				Property: Optional;
				Comment: {
					"1 if table is to be added as first in the list of tables.
					
					To do, the ordering of tables should be derived dynamically."
				}
			}
		}
		Procedure procAddIndexToTable {
			Arguments: (spTable,epIndex,spName,spDescription);
			Body: {
				!Check all input arguments
				epTable := StringToElement( sTables, spTable, Create : 0 );
				if( epTable = '' )
				then
					!Error: table is not defined
					procRaiseError( "Input", formatstring( "Table %s is not defined", spTable) );
					return 0;
				endif;
				if( epIndex = '' )
				then
					procRaiseError( "Input", "Index is not defined" );
					return 0;
				endif;
				if( spName = "" )
				then
					procRaiseError( "Input", "Column name is not defined" );
					return 0;
				endif;
				
				
				!Note that it is possible that the index is added before
				sIndices += epIndex;
				
				!If the index is new, the default order equals 1
				pOrderIndicesPerTable(epTable,epIndex) := max( iIndex, pOrderIndicesPerTable(epTable,iIndex) ) + 1;
				
				!Store the link between the table and the index
				p01IndexInTable(stringToElement(sTables,spTable), epIndex) := 1;
				
				!Store the index in the index list of the table
				if( spTableIndexList(epTable) <> "") then 
					spTableIndexList(epTable) += ","; 
				endif; !Add a 'comma' if it is not the first index
				spTableIndexList(epTable) += formatstring( "%e", epIndex );
				
				!Store the name of the column in which the index is stored in the extrenal data source
				spIndexColumnName(epTable,epIndex) := spName;
				
				!Store the description of the column
				procAddLineEndsToDescription( spDescription, 50 );
				spIndexColumnDescription(epTable, epIndex) := spDescription;
				
				return 1;
			}
			Comment: {
				"Adds an index to a table
				Returns 1 on succes, 0 on failure"
			}
			StringParameter spTable {
				Property: Input;
			}
			ElementParameter epIndex {
				Range: AllIndices;
				Property: Input;
			}
			StringParameter spName {
				Property: Input;
			}
			StringParameter spDescription {
				Property: Optional;
			}
		}
		Procedure procAddIdentifierToTable {
			Arguments: (spTable,epIdentifier,spName,spDescription);
			Body: {
				!Check all input arguments
				epTable := StringToElement( sTables, spTable, Create : 0 );
				if( epTable = '' )
				then
					!Error: table is not defined
					procRaiseError( "Input", formatstring( "Table %s is not defined", spTable) );
					return 0;
				endif;
				if( epIdentifier = '' )
				then
					procRaiseError( "Input", "Identifier is not defined" );
					return 0;
				endif;
				if( spName = "" )
				then
					procRaiseError( "Input", "Column name is not defined" );
					return 0;
				endif;
				
				!Check if the identifier is not added before
				if( epIdentifier in sIdentifiers )
				then
					!Error: Identifier is already added
					procRaiseError( "Input", formatstring( "Identifier %e is already added", epIdentifier) );
					return 0;
				endif;
				!Add the identifier
				sIdentifiers += epIdentifier;
				
				!If the identifier is new, the default order equals zero, so we update it to the correct order
				if( pOrderIdentifier(epIdentifier) = 0 )
				then
					pOrderIdentifier(epIdentifier) := card( sIdentifiers );
				endif;
				
				!Link the identifier to the table
				epIdentifierTable(epIdentifier) := epTable;
				
				!Store the name of the column in which the identifier is stored in the extrenal data source
				spIdentifierColumnName(epIdentifier) := spName;
				
				!Store the description
				procAddLineEndsToDescription( spDescription, 50 );
				spIdentifierColumnDescription(epIdentifier) := spDescription;
				
				/* perform some preprocessing */
				
				!Determine a list of all indices in this identifier
				spIdentifierIndexList(epIdentifier) := "";
				while loopcount <= IdentifierDimension( epIdentifier )
				do
					spIdentifierIndexList(epIdentifier) += formatstring( "%e", DomainIndex( epIdentifier, loopcount ) );
					!Add ',' if it is not the last index
					if loopCount < (IdentifierDimension( epIdentifier )) then
						spIdentifierIndexList(epIdentifier) += "," ;
					endif;
				endwhile;
				
				!Check if the list of indices of the identifier is equal to the list of indices of the table
				if( spTableIndexList(epTable) <> spIdentifierIndexList(epIdentifier) )
				then
					!Error: Identifier and table have mismatch in indices
					procRaiseError( "Input", formatstring( "Index mismatch for %e in table %s", epIdentifier, spTable ) );
					return 0;
				endif;
				
				return 1;
			}
			Comment: {
				"Adds an parameter to a table
				Returns 1 on succes, 0 on failure"
			}
			StringParameter spTable {
				Property: Input;
			}
			ElementParameter epIdentifier {
				Range: AllIdentifiers;
				Property: Input;
			}
			StringParameter spName {
				Property: Input;
			}
			StringParameter spDescription {
				Property: Optional;
			}
		}
		DeclarationSection Declaration_Case {
			StringParameter spCaseTableSchema;
			StringParameter spCaseTableName {
				Comment: "Name of the table in the database which contains the cases";
			}
			StringParameter spCaseName {
				Comment: "Name of the column in the tables in the database which contains the reference to a cases";
			}
		}
		DeclarationSection Declaration_Tables {
			Set sTables {
				Index: iTable;
				Parameter: epTable;
				OrderBy: pOrderTables(iTable);
				Comment: "Names of the tables the identifiers are mapped to the external data source";
			}
			Parameter pOrderTables {
				IndexDomain: iTable;
				Comment: {
					"Sorting of the tables
					Imported if foreign key relations exist"
				}
			}
			StringParameter spTableSchema {
				IndexDomain: iTable;
				Comment: {
					"Database schema (=owner) of the table
					(Not needed if interface is with excel)"
				}
			}
			StringParameter spTableDescription {
				IndexDomain: iTable;
				Comment: {
					"Database table description
					For documentation purpose only"
				}
			}
			Parameter p01TableWriteDense {
				IndexDomain: iTable;
				Range: binary;
				Comment: {
					"1 if the table needs to writen in dense mode.
					
					For example if the index needs to be writen even if all columns corresponding are at their default.
					In particular if these indices are used in foreign keys of other tables."
				}
			}
			Parameter p01IndexInTable {
				IndexDomain: (iTable,iIndex);
				Range: binary;
				Comment: {
					"1 if the index appears in the table
					0 otherwise"
				}
			}
			StringParameter spTableIndexList {
				IndexDomain: iTable;
				Comment: "String list of all indices of the table";
			}
		}
		DeclarationSection Declaration_Indices {
			Set sIndices {
				SubsetOf: AllIndices;
				Index: iIndex, iIndexOther;
				Parameter: epIndex;
				OrderBy: pOrderIndices(iIndex);
				Comment: "Set of all indices used in the tables to link to the externa data source";
			}
			Parameter pOrderIndices {
				IndexDomain: (iIndex);
				Comment: {
					"Ordering of the indices
					- All indices need the same ordering in the parameters that have them in the index domain"
				}
			}
			Parameter pOrderIndicesPerTable {
				IndexDomain: (iTable,iIndex);
				Comment: {
					"Ordering of the indices
					- All indices need the same ordering in the parameters that have them in the index domain"
				}
			}
			Parameter pCardIndices {
				IndexDomain: iIndex;
				Comment: "To do: Remove? aks vis";
			}
			StringParameter spIndexColumnName {
				IndexDomain: (iTable,iIndex);
				Comment: {
					"Name of the column in which the index is stored in the external data source,
					This name can be different per table"
				}
			}
			StringParameter spIndexColumnDescription {
				IndexDomain: (iTable,iIndex);
				Comment: {
					"Description of the column
					For documentation purpose only"
				}
			}
		}
		DeclarationSection Declaration_Identifier {
			Set sIdentifiers {
				SubsetOf: AllIdentifiers;
				Index: iIdentifier, iIdentifierOther;
				OrderBy: pOrderIdentifier(iIdentifier);
				Comment: "Set of all identifiers that linked to the external data source";
			}
			Parameter pOrderIdentifier {
				IndexDomain: iIdentifier;
				Comment: "Ordering of the identifiers";
			}
			ElementParameter epIdentifierTable {
				IndexDomain: iIdentifier;
				Range: sTables;
				Comment: "The table in which the identifier is stored";
			}
			StringParameter spIdentifierColumnName {
				IndexDomain: iIdentifier;
				Comment: "Name of the column in which the identifier is stored in the extrenal data source";
			}
			StringParameter spIdentifierColumnName2 {
				IndexDomain: {
					(iTable,iIdentifier) |
					epIdentifierTable(iIdentifier) = iTable
				}
				Definition: spIdentifierColumnName(iIdentifier);
				Comment: {
					"Name of the column in which the identifier is stored in the external data source
					Per table
					Note that an identifier can be stored in only one table"
				}
			}
			StringParameter spIdentifierColumnDescription {
				IndexDomain: iIdentifier;
				Comment: {
					"Description of the column
					For documentation purpose only"
				}
			}
			StringParameter spIdentifierColumnDescription2 {
				IndexDomain: {
					(iTable,iIdentifier) |
					epIdentifierTable(iIdentifier) = iTable
				}
				Definition: spIdentifierColumnDescription(iIdentifier);
				Comment: {
					"Description of the column
					Per table
					Note that an identifier can be stored in only one table"
				}
			}
			StringParameter spIdentifierIndexList {
				IndexDomain: iIdentifier;
				Comment: "String list of all indices of the identifier";
			}
		}
		DeclarationSection Declaration_For_Database {
			Set sDatabaseTypes {
				Definition: data { 'MS SQL', 'ORACLE SQL' };
				Comment: "Databases types for which the CQM DATA LINK Library is available";
			}
			ElementParameter epMSSQL {
				Range: sDatabaseTypes;
				Definition: 'MS SQL';
			}
			ElementParameter epORACLE {
				Range: sDatabaseTypes;
				Definition: 'ORACLE SQL';
			}
		}
	}
	Section Shared_Procedures {
		Section Input_Validation {
			Procedure procValidateInput {
				Arguments: (p01ForDatabase);
				Body: {
					!init illegal characters: TO DO - What other characters are illegal in the database column names?
					sIllegalCharacters := { 1..14 };
					spIllegaCharacter(iIllegalCharacter) :=
						data { 	'1' : " ", '2' : "[", '3' : "]",
							'4' : ".", '5' : "{", '6' : "}",
							'7' : ",", '8' : "(", '9' : ")",
							'10' : "'", '11' : "\"", '12' : "\\",
							'13' : ":", '14' : ";"
						};
					
					/* ---- Check tables ----*/
					
					!Proper definition of case and case table schema name
					if( p01ForDatabase and spCaseTableSchema = "" )
					then
						procRaiseError( "Validation", "Case table schema undefined");
						return 0;
					endif;
					if( p01ForDatabase and spCaseTableName = "" )
					then
						procRaiseError( "Validation", "Case table undefined");
						return 0;
					endif;
					if( p01ForDatabase and spCaseName = "" )
					then
						procRaiseError( "Validation", "Case naming undefined");
						return 0;
					endif;
					
					
					!Check if the tables have an ordering
					for( iTable | pOrderTables(iTable) = 0 )
					do
						procRaiseError( "Validation", formatstring( "Table %e has no value in pOrderTables", iTable ) );
						return 0;
					endfor;
					!Check for database also the schema
					for( iTable | p01ForDatabase and spTableSchema(iTable) = "" )
					do
						procRaiseError( "Validation", formatstring("Table %e has no schema", iTable ) );
						return 0;
					endfor;
					
					/* ---- Check indices ----*/
					!Check if the indices have an ordering
					for( (iTable, iIndex) |
							p01IndexInTable(iTable, iIndex) = 1 and
							pOrderIndicesPerTable(iTable, iIndex) = 0
							)
					do
						procRaiseError( "Validation", formatstring("Index %e has no value in pOrderIndicesPerTable for table %e", iIndex, iTable ) );
						return 0;
					endfor;
					!Check if the identifiers have an ordering
					for( iIdentifier | pOrderIdentifier(iIdentifier) = 0 )
					do
						procRaiseError( "Validation", formatstring("Index %e has no value in pOrderIdentifier", iIdentifier )	);
						return 0;
					endfor;
					!Check if each index is linked to a table
					for ( iIndex | sum( iTable, p01IndexInTable(iTable, iIndex) ) = 0 )
					do
						procRaiseError( "Validation", formatstring("Index %e has no link to table in p01IndexInTable", iIndex ) );
						return 0;
					endfor;
					!Check if column name is valid
					for ( (iTable,iIndex, iIllegalCharacter) |
						p01IndexInTable(iTable, iIndex)
						and
						findstring( spIndexColumnName(iTable, iIndex), spIllegaCharacter(iIllegalCharacter) ) > 0)
					do
						procRaiseError( "Validation", formatstring("Index %e has illegal character \'%s\' in column name ", iIndex , spIllegaCharacter(iIllegalCharacter) ) );
						return 0;
					endfor;
					
					/* ---- Check identifiers ----*/
					!Check if each identifier is linked to a table
					for ( iIdentifier | epIdentifierTable(iIdentifier) = '' )
					do
						procRaiseError( "Validation", formatstring("Identifier %e has no value in epIdentifierTable", iIdentifier ) );
						return 0;
					endfor;
					!Check if each identifier is linked to a column name
					for ( iIdentifier | spIdentifierColumnName(iIdentifier) = "" )
					do
						procRaiseError(	"Validation", formatstring("Identifier %e has no value in spIdentifierColumnName", iIdentifier ) );
						return 0;
					endfor;
					!Check if column name is valid
					for ( (iIdentifier, iIllegalCharacter) | findstring( spIdentifierColumnName(iIdentifier), spIllegaCharacter(iIllegalCharacter) ) > 0)
					do
						procRaiseError( "Validation", formatstring("Identifier %e has illegal character \'%s\' in column name ", iIdentifier, spIllegaCharacter(iIllegalCharacter) ) );
						return 0;
					endfor;
					
					/* ---- Check uniqueness of column naming ---- */
					for ( (iTable, iIndex, iIndexOther) | iIndex <> iIndexOther and
						!Two indices in the same table
						p01IndexInTable(iTable, iIndex) and
						p01IndexInTable(iTable, iIndexOther) and
						!With the same name
						spIndexColumnName(iTable, iIndex) = spIndexColumnName(iTable,iIndexOther)
						)
					do
						procRaiseError(	"Validation", formatstring("Table %e has two indices (%e, %e) with the same column name", iTable, iIndex, iIndexOther ) );
						return 0;
					endfor;
					for ( (iTable, iIdentifier, iIdentifierOther) | iIdentifier <> iIdentifierOther and
						!Two identifiers in the same table
						epIdentifierTable(iIdentifier) = iTable and  epIdentifierTable(iIdentifierOther)= iTable and
						!With the same name
						spIdentifierColumnName(iIdentifier) = spIdentifierColumnName(iIdentifierOther)
						)
					do
						procRaiseError(	"Validation", formatstring("Table %e has two identifiers (%e, %e) with the same column name", iTable, iIdentifier, iIdentifierOther ) );
						return 0;
					endfor;
					for ( (iTable,iIndex, iIdentifier) |
						!Index and identifier in the same table
						p01IndexInTable(iTable, iIndex) and
						epIdentifierTable(iIdentifier) = iTable and
						!With the same name
						spIndexColumnName(iTable, iIndex) = spIdentifierColumnName(iIdentifier)
						)
					do
						procRaiseError(	"Validation", formatstring("Table %e has index and identifiers (%e, %e) with the same column name", iTable, iIndex, iIdentifier) );
						return 0;
					endfor;
					
					!Input is valid
					return 1;
				}
				Comment: {
					"Checks if all required input is given for table definitions and is correct
					Returns 1 on succes, 0 if a check fails"
				}
				Parameter p01ForDatabase {
					Range: binary;
					Property: Input;
					Comment: "For databases there is additional validation needed";
				}
				Set sIllegalCharacters {
					SubsetOf: Integers;
					Index: iIllegalCharacter;
				}
				StringParameter spIllegaCharacter {
					IndexDomain: iIllegalCharacter;
				}
			}
		}
		Section Error_Handler {
			Procedure procRaiseError {
				Arguments: (spType,spMessage);
				Body: {
					!Rais error via a dialog message
					dialogmessage(
						formatstring( "[%s] %s",
							spType,
							spMessage),
						title: "CQM DATA LINK ERROR"
						);
				}
				Comment: {
					"If something goes wrong, for example with the input provided this procedure is called.
						[Reimplement this if the error message should be raised differently.]"
				}
				StringParameter spType {
					Property: Input;
				}
				StringParameter spMessage {
					Property: Input;
				}
			}
		}
		Section For_Model_Edit {
			Procedure procDefault {
				Comment: {
					"Default procedure needed in the definition of new procedures
					This is supposed to be empty"
				}
			}
			Procedure procCreateRuntimeLibrary {
				Arguments: (spLibraryName,spLibraryPrefix,epLibrary);
				Body: {
					/*
					Create runtime library:
					- Check input arguments
					- Check if it already exists
					- If exists then delete it.
					- Create the library
					*/
					
					!Check input
					if( spLibraryName = "" or spLibraryPrefix = "")
					then
						procRaiseError( "Syntax", "invalid input");
						epLibrary := '';
						return;
					endif;
					
					!Find the library with the given name
					epLibrary := StringToElement(AllIdentifiers, spLibraryName , Create: 0) ;
					
					!If the library exists, delete it.
					if epLibrary <> '' then me::Delete( epLibrary ); endif;
					
					!Create the library
					epLibrary := me::CreateLibrary( spLibraryName, spLibraryPrefix);
				}
				Comment: {
					"This procedure creates a run time library
					Fills the epLibrary as an element parameter to the new run time library. On failure the element parameter is empty"
				}
				DeclarationSection Input_Arguments {
					StringParameter spLibraryName {
						Property: Input;
					}
					StringParameter spLibraryPrefix {
						Property: Input;
					}
				}
				DeclarationSection Output_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Output;
						Comment: "OUPUT ARGUMENT: Reference to a run time library";
					}
				}
			}
			Procedure procCreateErrorParameter {
				Arguments: epLibrary;
				Body: {
					!Create declaration
					epIdentifier := me::Create( "Error_Declaration", 'declaration', epLibrary);
					
					!Create element parameter 'epError'
					epIdentifier := me::Create( "epError", 'element parameter', epIdentifier);
					me::SetAttribute( epIdentifier, 'range', "errh::PendingErrors");
				}
				Comment: {
					"Creates an AIMMS element parameter of the set Pending Errors.
					Used in the BLOCK statements"
				}
				DeclarationSection Input_arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
				}
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
					Comment: "Run time identiefier";
				}
			}
		}
	}
	Module Excel_functions {
		Prefix: ef;
		Public: data { procWriteToExcel, procReadFromExcel, procDetermineConsecutiveRange };
		Section Write_to_Excel {
			Procedure procWriteToExcel {
				Arguments: (spFile);
				Body: {
					/*
					This procedure creates a run time library with the code required to write to the excel file. And performs the write action.
					Each table in sTables will be writen on a seperate Excel sheet with all the indices and columns related to that table.
					*/
					
					!Validate the input
					if( spFile = "" )
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					if( procValidateInput(p01ForDatabase :  0) = 0 ) then return 0; endif;
					
					!(Re-)create the excelfile
					if( procCreateExcelFile(spFile) = 0 ) then return 0; endif;
					
					!Replace \ in filename by \\ to prevent reading errors
					spFile := FindReplaceStrings( spFile, "\\", "\\\\" );
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_WRITE_TO_EXCEL", "cqm_wte", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					
					!Create the required identifier set
					procCreateIdentifierSet( epLibrary );
					
					!Create the overall write procedure and the seperate table procedures
					epWriteProcedure := me::Create( "procWriteToExcel", 'procedure', epLibrary);
					
					!Create the body for the overall write procedure
					spWriteProcedureBody := "";
					!Loop over all table to include them
					for( iTable )
					do
						!Create the sub-procedure per sheet
						procWriteToSheet( spFile, epLibrary, iTable );
						!Call this sub-procedure from the overall write procedure
						spWriteProcedureBody += formatstring( "if ( procWrite%e() = 0 )\nthen\n\tdialogmessage(CurrentErrorMessage);\n\treturn 0;\nendif;\n",iTable);
					endfor;
					
					spWriteProcedureBody += "\nreturn 1;";
					
					!Set the body of the overall write procedure
					me::SetAttribute( epWriteProcedure, 'body', spWriteProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					
					!Run the created procedure
					apply( epWriteProcedure );
					
					!Save and close the excel file
					if( Spreadsheet::CloseWorkbook(spFile, 1 ) = 0 ) then return 0; endif;
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				Comment: {
					"Writes all tables to the excel file.
					Returns 1 on succes, 0 if a check fails"
				}
				DeclarationSection Input_Arguments {
					StringParameter spFile {
						Property: Input;
					}
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Reference to a run time library";
				}
				ElementParameter epWriteProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
				}
				StringParameter spWriteProcedureBody;
			}
			Procedure procCreateExcelFile {
				Arguments: (spFile);
				Body: {
					/*
					Make sure the file exists as an empty Excel file,
					by deleting it and creating a new
					*/
					
					if( fileExists( spFile ) = 1 and fileDelete( spFile ) = 0 )
					then
						DialogMessage(
							formatstring( "File %s can not be cleared.", spFile ),
							title : "Error");
						return 0;
					endif;
					
					if( spreadsheet::CreateWorkbook( spFile ) = 0 )
					then
						DialogMessage(
							formatstring( "File %s can not be created. Error: %s", spFile, CurrentErrorMessage ),
							title : "Error");
						return 0;
					endif;
					
					return 1;
				}
				StringParameter spFile {
					Property: Input;
				}
			}
			Procedure procCreateIdentifierSet {
				Arguments: (epLibrary);
				Body: {
					!Create a new declaration section
					epIdentifierDeclaration := me::Create( "Identifiers_Declaration", 'declaration', epLibrary);
					!Create a set of Identifiers
					epIdentifierSet := me::Create( "sIdentifiers", 'set', epIdentifierDeclaration );
					me::SetAttribute( epIdentifierSet, 'index', "iIdentifier");
					me::Compile( epLibrary );
					!Create a order parameter
					epIdentifierParam := me::Create ( "pOrderIdentifier", 'parameter', epIdentifierDeclaration );
					me::SetAttribute( epIdentifierParam, 'index domain', "iIdentifier");
					me::Compile( epLibrary );
					me::SetAttribute( epIdentifierSet, 'order by', "pOrderIdentifier(iIdentifier)");
					
					!Set values in the set:
					spDefinition := "";
					for ( iIdentifier )
					do
						if (spDefinition <> "") then 
							spDefinition += ",";
						endif;
						spDefinition += formatstring( " '%e' \n", iIdentifier);
					endfor;
					spDefinition := "{" + spDefinition + "}";
					me::SetAttribute( epIdentifierSet, 'definition', spDefinition );
					me::Compile( epIdentifierSet );
					
					!Set values in the order parameter
					spDefinition := "";
					for ( iIdentifier )
					do
						if (spDefinition <> "") then 
							spDefinition += ",";
						endif;
						spDefinition += formatstring( " '%e' : %n\n", iIdentifier, pOrderIdentifier(iIdentifier));
					endfor;
					spDefinition := "{" + spDefinition + "}";
					me::SetAttribute( epIdentifierParam, 'definition', spDefinition );
					
					me::Compile( epIdentifierParam );
					me::Compile(epIdentifierSet);
				}
				Comment: "Creates a set of identifiers equal to all identifiers that are in the data link";
				DeclarationSection Input_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
				}
				ElementParameter epIdentifierDeclaration {
					Range: AllIdentifiers;
				}
				ElementParameter epIdentifierSet {
					Range: AllIdentifiers;
				}
				StringParameter spDefinition;
				ElementParameter epIdentifierParam {
					Range: AllIdentifiers;
				}
			}
			Procedure procWriteToSheet {
				Arguments: (spFile,epLibrary,epTable);
				Body: {
					!If the table has no identifiers, we write only the index (set)
					p01HasNoIdentifiers := not exists( iIdentifier | epIdentifierTable(iIdentifier) = epTable );
					if (p01HasNoIdentifiers = 1)
					then
					
						pNumberOfIndices := 1;
						epDeclaration := me::Create( Formatstring( "%e_Declaration",epTable), 'declaration', epLibrary);
					
					else
					
						pNumberOfIndices := IdentifierDimension( first( iIdentifier | epIdentifierTable(iIdentifier) = epTable ) );
						pNumberOfIdentifiers := count( iIdentifier | epIdentifierTable(iIdentifier) = epTable );
					
						/*
						Create one string parameter containing all data for the table epTable
						with the indentifiers for a subset of allidentifiers
						*/
					
						!Create declaration section
						epDeclaration := me::Create( Formatstring( "%e_Declaration",epTable), 'declaration', epLibrary);
						me::Compile( epDeclaration );
					
						!Create subset of all identifiers relevant for this table
						epIdentifierSet := me::Create( Formatstring( "s%eIdentifiers",epTable), 'set', epDeclaration);
						me::SetAttribute( epIdentifierSet, 'subset of', "sIdentifiers");
						me::SetAttribute( epIdentifierSet, 'index', Formatstring( "i%eIdentifier",epTable) );
						spBody := "";
						for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
						do
							if( spBody = "" ) then
								spBody += "{";
							else
								spBody +=",\n";
							endif;
					
							spBody += Formatstring( "\'%s\'",iIdentifier );
					
						endfor;
						spBody += "}";
						me::SetAttribute( epIdentifierSet, 'definition' , spBody );
						me::Compile( epIdentifierSet );
					
						!Create string parameter to capture data
						epIdentifier := me::Create( Formatstring( "sp%e",epTable), 'string parameter', epDeclaration);
						if( pNumberOfIndices = 0 )
						then
							spIndexDomain :=  Formatstring( "(i%eIdentifier)",epTable);
						else
							spIndexDomain :=  "(" + spIdentifierIndexList( first( iIdentifier | epIdentifierTable(iIdentifier) = epTable )) + Formatstring( ",i%eIdentifier)",epTable);
						endif;
						me::SetAttribute( epIdentifier, 'index domain', spIndexDomain);
						me::Compile( epIdentifier );
					
						!Assign the values to this new string parameter
						spBody := "";
						for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
						do
							spBody += Formatstring( "sp%e(%s%s'%e') := %e%s%s%s;\n",
								epTable,
								spIdentifierIndexList( iIdentifier  ),
								if( pNumberOfIndices = 0 ) then "" else "," endif,
								iIdentifier,
								iIdentifier,
								if( pNumberOfIndices = 0 ) then "" else "(" endif,
								spIdentifierIndexList( iIdentifier  ),
								if( pNumberOfIndices = 0 ) then "" else ")" endif
								);
						endfor;
					endif;
					
					/*
					Create the sub procedure to write one sheet to the excel file
					*/
					epWriteToSheetProcedure := me::Create(
						formatstring( "procWrite%e",epTable),
						'procedure', epLibrary);
					!Create the body of the sub procedure
					!Add a new excel sheet with the same name as the table name
					spBody += formatstring( "\nif( Spreadsheet::AddNewSheet(\"%s\",\"%e\") = 0 ) then return 0; endif;\n\n", spFile,epTable );
					
					!Export the single parameter containing all data of the table to the excel file
					spBody += "\n";
					
					!case 1: only set, no identifiers -> assignset
					if (p01HasNoIdentifiers = 1 )
					then
						spRowCounter := Formatstring( "card( %s ) + 2",first( iIndex | p01IndexInTable(epTable, iIndex) ) );
						spBody += FormatString( "\nif ( Spreadsheet::AssignSet( \"%s\", Set: %s,\n\tRange: formatstring( \"A2:A%%i\",%s),\n\tSheet: \"%e\" ) = 0 ) then return 0; endif;\n\n",
							spFile,
							spTableIndexList( epTable ),
							spRowCounter,
							epTable
							);
					elseif ( pNumberOfIndices > 0 ) !case 2: parameter with indices
					then
						!Create a parameter to bound the number of rows to read.
						spRowCounter := Formatstring( "pRowCounter%e",epTable);
						epIdentifier := me::Create( spRowCounter, 'parameter', epDeclaration);
						me::SetAttribute( epIdentifier, 'range', "integer");
						me::Compile( epIdentifier );
						spBody +=  spRowCounter + " := max( 2, ";
						pIndexCounter := 0;
						for( iIndex | p01IndexInTable(epTable, iIndex) )
						do
							pIndexCounter += 1;
							if( pIndexCounter > 1 )
							then
								spBody += " * ";
							endif;
					
							spBody += formatstring( "card( %e )", iIndex );
						endfor;
						spBody +=" + 1 );\n";
					
						!Create the assign statement
						spBody += FormatString( "\nif ( Spreadsheet::AssignTable( \"%s\", Parameter: sp%e,\n\tDataRange: formatstring( \"%s2:%s%%i\",%s),\n\tRowsRange: formatstring( \"A2:%s%%i\",%s),\n\tColumnsRange: \"%s1:%s1\",\n\tRowMode: 0,\n\tColumnMode: 1 ) = 0 ) then return 0; endif;\n\n",
							spFile,
							epTable,
							Spreadsheet::ColumnName(pNumberOfIndices + 1 ),
							Spreadsheet::ColumnName(pNumberOfIndices + pNumberOfIdentifiers),
							spRowCounter,
							Spreadsheet::ColumnName(pNumberOfIndices  ),
							spRowCounter,
							Spreadsheet::ColumnName(pNumberOfIndices + 1),
							Spreadsheet::ColumnName(pNumberOfIndices + pNumberOfIdentifiers)
							);
					
					else
						!Scalars
						!Write the headers in the first column
						pRowCounter := 0;
						for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
						do
							pRowCounter += 1;
							spBody += FormatString( "if( Spreadsheet::AssignValue( \"%s\", sp%e('%e'), \"B%n:B%n\" ) = 0 ) then return 0; endif;\n",
								spFile,
								epTable,
								iIdentifier,
								pRowCounter,
								pRowCounter
								);
						endfor;
					endif;
					
					!Set header of the table
					if( pNumberOfIndices > 0 )
					then
						!Write the headers in the top row
						pColumnCounter := 0;
						!Set the correct index order
						pOrderIndices( iIndex ) := pOrderIndicesPerTable(epTable, iIndex);
						for( iIndex | p01IndexInTable(epTable, iIndex) )
						do
							pColumnCounter += 1;
							spBody += FormatString( "if( Spreadsheet::AssignValue( \"%s\", \"%s\", \"%s1:%s1\" ) = 0 ) then return 0; endif;\n",
								spFile,
								spIndexColumnName(epTable,iIndex),
								spreadsheet::ColumnName(pColumnCounter),
								spreadsheet::ColumnName(pColumnCounter)
								);
						endfor;
						for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
						do
							pColumnCounter += 1;
							spBody += FormatString( "if( Spreadsheet::AssignValue( \"%s\", \"%s\", \"%s1:%s1\" ) = 0 ) then return 0; endif;\n",
								spFile,
								spIdentifierColumnName(iIdentifier),
								spreadsheet::ColumnName(pColumnCounter),
								spreadsheet::ColumnName(pColumnCounter)
								);
						endfor;
					else
						!No indices
						!Write the headers in the first column
						pRowCounter := 0;
						for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
						do
							pRowCounter += 1;
							spBody += FormatString( "if( Spreadsheet::AssignValue( \"%s\", \"%s\", \"A%n:A%n\" ) = 0 ) then return 0; endif;\n",
								spFile,
								spIdentifierColumnName(iIdentifier),
								pRowCounter,
								pRowCounter
								);
						endfor;
					endif;
					
					spBody += "\nreturn 1;";
					me::SetAttribute( epWriteToSheetProcedure , 'body', spBody );
					
					!Procedure is complete, so compile
					me::Compile( epWriteToSheetProcedure );
				}
				DeclarationSection Input_Arguments {
					StringParameter spFile {
						Property: Input;
					}
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
					ElementParameter epTable {
						Range: sTables;
						Property: Input;
					}
				}
				ElementParameter epWriteToSheetProcedure {
					Range: AllIdentifiers;
					Comment: {
						"!Creates the first part of the body of the Read Procedure in the runtime library"
					}
				}
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
				}
				ElementParameter epIdentifierSet {
					Range: AllIdentifiers;
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
				}
				StringParameter spBody;
				StringParameter spIndexDomain;
				StringParameter spRowCounter;
				Parameter pIndexCounter {
					Range: integer;
				}
				Parameter pColumnCounter {
					Range: integer;
				}
				Parameter pRowCounter {
					Range: integer;
				}
				Parameter pNumberOfIndices {
					Range: integer;
				}
				Parameter pNumberOfIdentifiers {
					Range: integer;
				}
				Parameter p01HasNoIdentifiers;
			}
		}
		Section Read_from_Excel {
			Procedure procReadFromExcel {
				Arguments: spFile;
				Body: {
					/*
					This procedure creates a run time library with the code required to read from the excel file. And performs the read action.
					Each table in sTables will be retrieved from a seperate Excel sheet with all the indices and columns related to that table.
					*/
					
					!Validate the input
					if( spFile = "" )
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					if( procValidateInput(p01ForDatabase :  0) = 0 ) then return 0; endif;
					
					!Check if the file exists
					if( FileExists( spFile ) = 0 )
					then
						procRaiseError( "Read error", "File does not exist" );
						return 0;
					endif;
					
					!Check if the file is valid
					if( procCheckExcelInputFile( spFile ) = 0 )
					then
						spreadsheet::CloseWorkbook( spFile, 0 );
						return 0;
					endif;
					
					!Replace \ in filename by \\ to prevent reading errors
					spFile := FindReplaceStrings( spFile, "\\", "\\\\" );
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_READ_FROM_EXCEL", "cqm_rfe", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					
					!Replace \ in filename by \\ to prevent reading errors
					spFile := FindReplaceStrings( spFile, "\\", "\\\\" );
					
					!Create the overall read procedure and the seperate table procedures
					epReadProcedure := me::Create( "procReadFromExcel", 'procedure', epLibrary);
					
					!Create the body for the overall read procedure
					spReadProcedureBody := "";
					!Loop over all table to include them
					for( iTable )
					do
						!Create the sub-procedure per sheet
						procReadFromSheet( spFile, epLibrary, iTable );
						!Call this sub-procedure from the overall read procedure
						spReadProcedureBody += formatstring( "if ( procRead%e() = 0 )\nthen\n\tgdm::spReadErrorMessage(gdm::epCountTableList):=\"%e\" + \" - \" + CurrentErrorMessage;\n\tdialogmessage(CurrentErrorMessage);\n\treturn 0;\nendif;\n",iTable,iTable);
					endfor;
					
					spReadProcedureBody += "\nreturn 1;";
					
					!Set the body of the overall read procedure
					me::SetAttribute( epReadProcedure, 'body', spReadProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					!Run the created procedure
					apply( epReadProcedure );
					
					!Save and close the excel file
					if( Spreadsheet::CloseWorkbook(spFile, 0 ) = 0 ) then return 0; endif;
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				Comment: {
					"Reads all tables from the excel file.
					Returns 1 on succes, 0 if a check fails"
				}
				DeclarationSection Input_Arguments {
					StringParameter spFile {
						Property: Input;
					}
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Reference to a run time library";
				}
				ElementParameter epReadProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
				}
				StringParameter spReadProcedureBody;
			}
			Procedure procReadFromSheet {
				Arguments: (spFile,epLibrary,epTable);
				Body: {
					/*
					Create the sub procedure to read one sheet to the excel file
					*/
					epReadFromSheetProcedure := me::Create(
						formatstring( "procRead%e",epTable),
						'procedure', epLibrary);
					
					/* Create the body of the sub procedure */
					
					!Open the corresponding sheet with the same name as the table name
					spBody := formatstring( "\nif( Spreadsheet::SetActiveSheet(\"%s\",\"%e\") = 0 ) then return 0; endif;\n\n", spFile,epTable );
					
					
					!Create a parameter pRowCounter_tableName to bound the number of rows to read.
					epDeclaration := me::Create( Formatstring( "%e_Declaration",epTable), 'declaration', epLibrary);
					spRowCounter := Formatstring( "pRowCounter%e",epTable);
					epIdentifier := me::Create( spRowCounter, 'parameter', epDeclaration);
					me::SetAttribute( epIdentifier, 'range', "integer");
					me::Compile( epIdentifier );
					
					spBody += formatstring("cdl::procDetermineConsecutiveRange( \n\t\"%s\",\n", spFile);
					spBody += "\tspStartCell: \"A2\",\t\t\t! start cell from which we are going to determine the range\n";
					spBody += "\tpCellDirection: 2,\t\t\t! 2 indicates we want to look down-wards. ( pCellDirection = {1..2} -> up or down )\n";
					spBody += formatstring("\tpRowNumber: %s);\t! output example : if the last value is found in cell A100, then pRowNumber = 100\n\n", spRowCounter );
					
					spBody += formatstring( "if (%s < 2 ) then %s := 2; endif;\t! pRowCounter must be at least 3, otherwise your range is empty\n",spRowCounter,spRowCounter);
					
					!Check if table has identifiers -> sometimes only a set but no identifiers
					p01HasNoIdentifiers := not exists( iIdentifier | epIdentifierTable(iIdentifier) = epTable );
					if (p01HasNoIdentifiers)
					then
						spBody += "\n";
					
						/* Retrieve the value */
						spBody += FormatString( "if ( Spreadsheet::RetrieveSet( \n\t\"%s\",\n\tSet: %s,\n\tRange: formatstring( \"A2:A%%i\",%s),\n\tSheet: \"%e\",\n\tMode: \'merge\' ) = 0 ) then return 0; endif;\n\n",
								spFile,
								spTableIndexList( epTable ),
								spRowCounter,
								epTable
								);
					else
					
						!Read each identifier from this table one by one
						pNumberOfIndices := IdentifierDimension( first( iIdentifier | epIdentifierTable(iIdentifier) = epTable ) );
						pColumnCounter := pNumberOfIndices;
						if( pNumberOfIndices > 0 )
						then
					
							for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
							do
								pColumnCounter += 1;
					
								! 2017-07-20 Irene Lotero: Modify the procedure to keep reading even if there are columns missing
								/* Check the identifiers per column */
								spLetter := formatstring("%e", Element(sAllLetters,pColumnCounter));
								spRange := formatstring( "%s1:%s1", spLetter, spLetter);
								spreadsheet::RetrieveValue( spFile, spIdentifierNameFound, spRange , sheet: formatstring( "%e", epTable ) );
								if( spIdentifierNameFound = spIdentifierColumnName2(epTable, iIdentifier) )
								then
								spBody += "\n";
								/* Retrieve the value */
								spBody += FormatString( "if ( Spreadsheet::RetrieveTable( \n\t\"%s\",\n\tParameter: %e(%s),\n\tDataRange: formatstring( \"%s2:%s%%i\",%s),\n\tRowsRange: formatstring( \"A2:%s%%i\",%s),\n\tColumnsRange: \"\",\n\tSheet: \"%e\",\n\tAutomaticallyExtendSets : 1 ) = 0 ) then return 0; endif;\n\n",
										spFile,
										iIdentifier,
										spIdentifierIndexList(iIdentifier),
										Spreadsheet::ColumnName( pColumnCounter ),
										Spreadsheet::ColumnName( pColumnCounter ),
										spRowCounter,
										Spreadsheet::ColumnName( pNumberOfIndices ),
										spRowCounter,
										epTable
										);
								endif;
							endfor;
						else
							!No indices
					
							/* Check the header and retrieve the value
							Read the scalars one by one( Header in the first column, Value in the second)
							*/
							pRowCounter := 0;
							for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
							do
								pRowCounter += 1;
					
								!RetrieveValue
								spBody += FormatString( "if( Spreadsheet::RetrieveValue( \"%s\", %e, \"B%n:B%n\" ) = 0 ) then return 0; endif;\n",
									spFile,
									iIdentifier,
									pRowCounter,
									pRowCounter
									);
							endfor;
						endif;
					endif;
					spBody += "\nreturn 1;";
					me::SetAttribute( epReadFromSheetProcedure , 'body', spBody );
					
					!Procedure is complet, so compile
					me::Compile( epReadFromSheetProcedure );
				}
				DeclarationSection Input_Arguments {
					StringParameter spFile {
						Property: Input;
					}
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
					ElementParameter epTable {
						Range: sTables;
						Property: Input;
					}
				}
				ElementParameter epReadFromSheetProcedure {
					Range: AllIdentifiers;
					Comment: {
						"!Creates the first part of the body of the Read Procedure in the runtime library"
					}
				}
				StringParameter spBody;
				Parameter pColumnCounter {
					Range: integer;
				}
				Parameter pRowCounter {
					Range: integer;
				}
				Parameter pNumberOfIndices {
					Range: integer;
				}
				Parameter p01HasNoIdentifiers;
				Parameter pLastRowNr;
				StringParameter spRowCounter;
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
				}
				DeclarationSection Declaration_Irene_Lotero {
					StringParameter spIdentifierNameFound;
					StringParameter spRange;
					StringParameter spLetter;
					Set sAllLetters {
						Index: iLetters;
						InitialData: {
							
							data{
							'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
							'AA','AB','AC','AD','AE','AF','AG','AH','AI','AJ','AK','AL','AM','AN','AO','AP','AQ','AR','AS','AT','AU','AV','AW','AX','AY','AZ',
							'BA','BB','BC','BD','BE','BF','BG','BH','BI','BJ','BK','BL','BM','BN','BO','BP','BQ','BR','BS','BT','BU','BV','BW','BX','BY','BZ'
							}
						}
					}
				}
			}
			Procedure procDetermineConsecutiveRange {
				Arguments: (spWorkbook,spStartCell,pCellDirection,pRowNumber);
				Body: {
					/*This function assumes that the activeSheet has been set for the workbook already
					It is possible to modify it to use an optional Sheet stringparameter that is given as an argument
					
					Use the cellDirection to denote how to look for first non-empty cell:
					1: Search up-wards
					2: search down-wards
					*/
					
					!First separate the startCell into column number and row number
					!For this, we need to do some looking into the string and determine where
					!the numbers start in the cell cell representation
					counter := 0 ;
					while (counter < StringLength( spStartCell ))
					do
					
					      !If the character at the current position is a number, then we can stop and have
					      !found the start of where the row part of the cell starts
					      if characterNumber( substring(spStartCell, counter, counter + 1) ) >= characterNumber( "0" )  and characterNumber( substring(spStartCell, counter, counter + 1) ) <= characterNumber( "9" ) then
					              break ;
					      endif ;
					
					      counter += 1 ;
					endwhile  ;
					
					!Based on the value of iterator, we can now separate the startCell into the row and column component.
					pCellCurrentRow := val( substring( spStartCell, counter, stringlength(spStartCell) ) );
					pCellCurrentCol := ExcelColumnNumber( substring( spStartCell, 0 , counter - 1));
					
					!Now determine the contents of the currentCell (this is startCell now)
					ExcelRetrieveParameter(spWorkbook, spCellContents, formatstring( "%s%i", ExcelColumnName( pCellCurrentCol), pCellCurrentRow) ) ;
					
					!Keep on searching for next cell, until we found an empty cell
					while spCellContents <> ""
					do
					      !Determine the new current cell, based on the direction provided by the user
					      switch pCellDirection
					      do
					              1:
					                      pCellCurrentRow -= 1 ;
					              2:
					                      pCellCurrentRow += 100 ; !Pls- speedup steps of 100 cells
					      endswitch ;
					
					      !Get the contents of the new current cell
					      ExcelRetrieveParameter(spWorkbook, spCellContents, formatstring( "%s%i", ExcelColumnName( pCellCurrentCol), pCellCurrentRow) ) ;
					endwhile ;
					
					!Because of the above loop, we went one step to far (i.e. current cell is empty). Must undo the last step
					!to get the actual range
					switch pCellDirection
					do
					      1:
					              pCellCurrentRow += 1 ;
					      2:
					              pCellCurrentRow -= 1 ;
					endswitch ;
					
					!and set the outputparameter to endCell that we found
					pRowNumber := pCellCurrentRow;
				}
				Comment: "This function can be used if you want to read from an excel and you do not know how many columns/rows there are -> this function determines the range";
				DeclarationSection Input_parameters {
					StringParameter spStartCell {
						Property: Input;
					}
					StringParameter spWorkbook {
						Property: Input;
					}
					Parameter pCellDirection {
						Range: {
							{1..2}
						}
						Property: Input;
					}
				}
				DeclarationSection Output_parameters {
					Parameter pRowNumber {
						Property: Output;
					}
				}
				DeclarationSection Help_parameters {
					StringParameter spCellContents;
					Parameter pCellCurrentRow;
					Parameter pCellCurrentCol;
					Parameter counter;
				}
			}
			Section Check_Excel_file {
				Procedure procCheckExcelInputFile {
					Arguments: (spFile);
					Body: {
						!Read all the sheets in Excel
						if( spreadsheet::GetAllSheets( spFile,spSheetNames ) = 0 ) 
						then
							dialogmessage( CurrentErrorMessage, title: "Error reading Excel file" );
							return 0;
						endif;
						!Check if all the requide sheets exist
						spMissingSheets := "";
						for( iTable | Not( Exists( iSheetFoundInExcel | spSheetNames(iSheetFoundInExcel) = formatstring( "%e", iTable ) ) ) )
						do
							if( spMissingSheets <> "" ) then spMissingSheets += "\n"; endif;
							spMissingSheets += iTable;
						endfor;
						if( spMissingSheets <> "" ) 
						then 
							dialogmessage( "Missing sheets:\n" + spMissingSheets, title: "Error reading Excel file");
							return 0;
						endif;
						
						!Check all sheets one by one on the column requirements
						for( iTable )
						do
							if( sum( iIndex, p01IndexInTable(iTable, iIndex) ) = 0 ) 
							then!Tables with scalars
								!Only check the indentifiers per row
								pRow := 0;
								for ( iIdentifier | spIdentifierColumnName2(iTable, iIdentifier) <> "" )
								do
									spIdentifierNameFound := "";
						
									pRow += 1;
									spRange := formatstring( "A%i:A%i",pRow,pRow);
						
									spreadsheet::RetrieveValue( spFile, spIdentifierNameFound, spRange , sheet: formatstring( "%e", iTable ) );
						
									if( spIdentifierNameFound <> spIdentifierColumnName2(iTable, iIdentifier) )
									then
										dialogmessage( 
											formatstring( "Expected name \"%s\" not found on sheet \"%e\" cell \"%s\".", 
												spIdentifierColumnName2(iTable, iIdentifier), iTable, spRange ) );
										return 0;
									endif;
								endfor;
						
							else!Tables with proper columns
						
								!First check the indices per column
								pColumn := 0;
								!Put indices in right order
								pOrderIndices(iIndex) := pOrderIndicesPerTable(iTable, iIndex);
								for ( iIndex | spIndexColumnName(iTable, iIndex) <> "" )
								do
									spIdentifierNameFound := "";
						
									pColumn += 1;
									spRange := formatstring( "%s1:%s1",spreadsheet::ColumnName(pColumn),spreadsheet::ColumnName(pColumn));
						
									spreadsheet::RetrieveValue( spFile, spIdentifierNameFound, spRange , sheet: formatstring( "%e", iTable ) );
						
									if( spIdentifierNameFound <> spIndexColumnName(iTable, iIndex) )
									then
										dialogmessage( 
											formatstring( "Expected name \"%s\" not found on sheet \"%e\" cell \"%s\".", 
												spIndexColumnName(iTable, iIndex), iTable, spRange ) );
										return 0;
									endif;
								endfor;
								!Second check the identifiers per column
								for ( iIdentifier | spIdentifierColumnName2(iTable, iIdentifier) <> "" )
								do
									spIdentifierNameFound := "";
						
									pColumn += 1;
									spRange := formatstring( "%s1:%s1",spreadsheet::ColumnName(pColumn),spreadsheet::ColumnName(pColumn));
						
									spreadsheet::RetrieveValue( spFile, spIdentifierNameFound, spRange , sheet: formatstring( "%e", iTable ) );
						
									if( spIdentifierNameFound <> spIdentifierColumnName2(iTable, iIdentifier) )
									then
										! 2017-07-20 Irene Lotero: This error stopped the reading procedure.
										!                          I modified it to be a warning instead. 
										spTest := formatstring( "%s", iTable );
										log_message::procLogError( 1, '', formatstring( "Column %s from sheet %s is missing", spIdentifierColumnName2(iTable, iIdentifier), spTest  ) );
										pColumn -= 1;
										!dialogmessage( 
										!	formatstring( "Expected name \"%s\" not found on sheet \"%e\" cell \"%s\".", 
										!		spIdentifierColumnName2(iTable, iIdentifier), iTable, spRange ) );
										!return 0;
									endif;
								endfor;
							endif;
						
						endfor;
						
						
						return 1;
					}
					Comment: {
						"1 - Check all the sheet requirements
						2 - Check the column name requirements"
					}
					DeclarationSection Input_Arguments {
						StringParameter spFile {
							Property: Input;
						}
					}
					Set sSheetsFoundInExcel {
						SubsetOf: Integers;
						Index: iSheetFoundInExcel;
						Comment: "Collection of all sheets found in the Excel file that is to be read";
					}
					StringParameter spSheetNames {
						IndexDomain: iSheetFoundInExcel;
					}
					StringParameter spMissingSheets;
					StringParameter spIdentifierNameFound;
					StringParameter spRange;
					Parameter pRow {
						Range: integer;
					}
					Parameter pColumn {
						Range: integer;
					}
					StringParameter spTest;
				}
			}
		}
	}
	Module Database_functions {
		Prefix: df;
		Public: data { procReadFromDatabase, procWriteToDatabase, procDeleteFromDatabase, procGetCasesFromDatabase };
		Section Read_case {
			Procedure procReadFromDatabase {
				Arguments: (epDatabaseType,spConnection,spCase);
				Body: {
					/*
					This procedure creates a run time library with the code required to read the tables
					in sTables with all its related identifiers (in sIdentifiers) from the database
					*/
					
					!Validate the input
					if( epDatabaseType = '' or spConnection = "" or spCase = "" )
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					
					!Validate table definitions
					if( procValidateInput(p01ForDatabase :  1) = 0 ) then return 0; endif;
					
					!Test the database connection
					if( procTestDatabaseConnection( spConnection ) = 0 ) then return 0; endif;
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_READ_FROM_DATABASE", "cqm_rfdb", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					
					!Create an error parameter
					procCreateErrorParameter( epLibrary );
					
					!Create set of cases
					procCreateCaseSet( epLibrary );
					
					!Create the overall read procedure and the seperate table procedures
					epReadProcedure := me::Create( "procReadFromDatabase", 'procedure', epLibrary);
					
					!Create the body for the read procedure
					spReadProcedureBody := "!Read a case from the database\n";
					!Add element case to the new Case Set
					spReadProcedureBody += formatstring( "sCases += {'%s'};\n\n", spCase );
					
					!Start of database procedure
					procCreateStartOfDBProcedure(spReadProcedureBody);
					
					!Create for each table the read procedure
					for( iTable )
					do
						!Create the database table
						procCreateDatabaseTable( epLibrary, epDatabaseType, iTable, spConnection, spCase );
					
						spReadProcedureBody += formatstring( "\tread from table dbt%e( \'%s\' ) in merge mode;\n", iTable, spCase);
					
					endfor;
					
					!End of database procedure
					procCreateEndOfDBProcedure(spReadProcedureBody);
					me::SetAttribute( epReadProcedure, 'body', spReadProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					
					!Run the created procedure
					apply( epReadProcedure );
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				Comment: "Returns 1 on succes, 0 if a check fails";
				DeclarationSection Input_Arguments {
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					StringParameter spCase {
						Property: Input;
						Comment: "INPUT ARGUMENT: Name of the case";
					}
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Reference to a run time library";
				}
				ElementParameter epReadProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
					Comment: "Run time procedure for the overall read";
				}
				StringParameter spReadProcedureBody {
					Comment: "Body of the run time procedure for the overall read";
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
					Comment: "Run time declaration";
				}
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
					Comment: "Run time identifier";
				}
				StringParameter spIdentifierName {
					Comment: "Name of identifier to map to when read from database";
				}
			}
		}
		Section Write_case {
			Procedure procWriteToDatabase {
				Arguments: (epDatabaseType,spConnection,spCase);
				Body: {
					/*
					This procedure creates a run time library with the code required to write the tables
					in sTables with all its related identifiers (in sIdentifiers) to the database
					*/
					
					!Validate the input arguments
					if( epDatabaseType = '' or spConnection = "" or spCase = "" )
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					
					!Validate table definitions
					if( procValidateInput(p01ForDatabase :  1) = 0 ) then return 0; endif;
					
					!Test the database connection
					if( procTestDatabaseConnection( spConnection ) = 0 ) then return 0; endif;
					
					!Remove old version of case from database -- TO DO should be integral part of this procedure, because if now something goes wrong, there is no rollback
					procDeleteFromDatabase( epDatabaseType, spConnection,  spCase);
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_WRITE_TO_DATABASE", "cqm_wtdb", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					
					!Create an error parameter in the run time library
					procCreateErrorParameter( epLibrary );
					
					!Create set of cases
					procCreateCaseSet( epLibrary );
					
					!Create the overall write procedure and the seperate table procedures
					epWriteProcedure := me::Create( "procWriteToDatabase", 'procedure', epLibrary);
					
					!Create a paramater that will be used to determine whether or not to write a specific table to the database
					epDeclaration := me::Create( "Help parameter", 'declaration', epLibrary);
					epIdentifier := me::Create( "pCardTable", 'parameter', epDeclaration);
					me::SetAttribute( epIdentifier, 'range', "integer");
					me::Compile( epIdentifier );
					
					!Create the body for the write procedure
					spWriteProcedureBody := "!Write a case to the database\n";
					!Add element case to the new Case Set
					spWriteProcedureBody += formatstring( "sCases += {'%s'};\n\n", spCase );
					
					!Start of database procedure
					procCreateStartOfDBProcedure( spWriteProcedureBody );
					
					!Create for each table the write procedure
					for( iTable )
					do
							!Create the database table
							procCreateDatabaseTable( epLibrary, epDatabaseType, iTable, spConnection, spCase );
					
							!Determine whether or not to write dense
							spInDenseMode := "";
							if( p01TableWriteDense(iTable) ) then spInDenseMode := " in dense mode"; endif;
					
							! Write table to database if (at least) one of the following holds:
							! Option 1: you write sparse
							! Option 2: it is a scalar parameter
							! Option 3: your parameter has indices but they are not empty (the sets are not empty) -> o.w. you would get an error that you cannot write "NULL"
							spWriteProcedureBody += formatstring("\t!%e\n",iTable);
							if ( p01TableWriteDense(iTable) = 0   					! Option 1
								or not exists( iIndex | p01IndexInTable(iTable, iIndex) ) ) 	! Option 2
							then
								spWriteProcedureBody += formatstring( "\twrite to table dbt%e( \'%s\' ) %s;\n\n", iTable, spCase, spInDenseMode);
							else
								spMultiply := "";						!Option 3: we first multiply the cardinalities of all indices of the parameter
								spWriteProcedureBody +=  "\tpCardTable :=";
								for( iIndex | p01IndexInTable(iTable, iIndex) )
								do
									spWriteProcedureBody += formatstring( " %s card( %e )", spMultiply, iIndex );
									spMultiply := "*";
								endfor;
								spWriteProcedureBody += " ;\n";
								spWriteProcedureBody += formatstring("\tif ( pCardTable > 0 ) then \n\t\twrite to table dbt%e( \'%s\' ) %s;\n\tendif;\n\n", iTable, spCase, spInDenseMode);
							endif;
					endfor;
					
					!End of database procedure
					procCreateEndOfDBProcedure(spWriteProcedureBody);
					me::SetAttribute( epWriteProcedure, 'body', spWriteProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					
					!Run the created procedure
					apply( epWriteProcedure );
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				DeclarationSection Input_Arguments {
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					StringParameter spCase {
						Property: Input;
						Comment: "INPUT ARGUMENT: Name of the case";
					}
				}
				StringParameter spRowCounter;
				StringParameter spMultiply;
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Reference to a run time library";
				}
				StringParameter spInDenseMode;
				ElementParameter epWriteProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
				}
				StringParameter spWriteProcedureBody;
			}
		}
		Section Delete_case {
			Procedure procDeleteFromDatabase {
				Arguments: (epDatabaseType,spConnection,spCase);
				Body: {
					/*
					This procedure creates a run time library with the code required to detele
					a case from the database. It deletes the case from the cases tables and assumes
					in all other tables the content is deleted via a 'cascade on delete' in the
					foreign key.
					*/
					
					!Validate the input
					if( epDatabaseType = '' or spConnection = "" or spCase = "" )
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					
					!Validate table definitions
					if( procValidateInput(p01ForDatabase :  1) = 0 ) then return 0; endif;
					
					!Test the connection
					if( procTestDatabaseConnection( spConnection ) = 0 ) then return 0; endif;
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_DELETE_FROM_DATABASE", "cqm_dfdb", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					!Create an error parameter
					procCreateErrorParameter( epLibrary );
					
					!Create the overall delete procedure
					epDeleteProcedure := me::Create( "procDeleteFromDatabase", 'procedure', epLibrary);
					
					/*--- Create the body for the delete procedure ---*/
					spDeleteProcedureBody := "!Delete a case from the database\n";
					procCreateStartOfDBProcedure(spDeleteProcedureBody);
					
					!Create the dbproc for the delete
					procCreateDBDeleteProcedure(epLibrary,epDatabaseType,spConnection,spCase);
					
					!Call the dbproc for the delete
					spDeleteProcedureBody += "\tdbprocDeleteCase();\n";
					
					procCreateEndOfDBProcedure(spDeleteProcedureBody);
					me::SetAttribute( epDeleteProcedure, 'body', spDeleteProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					
					!Run the created procedure
					apply( epDeleteProcedure );
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				Comment: {
					"Deletes a case from the database
					Returns 1 on succes, 0 if a check fails"
				}
				DeclarationSection Input_Arguments {
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					StringParameter spCase {
						Property: Input;
						Comment: "INPUT ARGUMENT: Name of the case";
					}
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Reference to a run time library";
				}
				ElementParameter epDeleteProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
					Comment: "Run time procedure for the delete";
				}
				StringParameter spDeleteProcedureBody {
					Comment: "Body of the run time procedure for the delete";
				}
			}
			Procedure procCreateDBDeleteProcedure {
				Arguments: (epLibrary,epDatabaseType,spConnection,spCase);
				Body: {
					!Create the run time database procedure
					epDBProcedure := me::Create("dbprocDeleteCase",	'database procedure', epLibrary);
					!Connection properties
					me::SetAttribute( epDBProcedure, 'data source', formatstring( "\"%s\"", spConnection ) );
					me::SetAttribute( epDBProcedure, 'owner', formatstring( "\"%s\"", spTableSchema(epTable) ) );
					
					!Sql query
					spSQLQuery := formatstring( "\"DELETE FROM %s.%s \" +\n\"WHERE ",
								spCaseTableSchema,
								spCaseTableName);
					!Distinction between databse types
					spSQLQuery +=
						if( epDatabaseType = epORACLE )
						then
							spCaseName
						elseif( epDatabaseType = epMSSQL )
						then
							"[" + spCasename + "]"
						endif;
					spSQLQuery += formatstring( " = \'%s\';\"",
								spCase );
					
					!Set the query
					me::SetAttribute( epDBProcedure, 'sql query', spSQLQuery );
					
					!Compile the procedure
					me::Compile( epDBProcedure );
				}
				Comment: "Creates the database procedure for the delete case";
				DeclarationSection Input_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					StringParameter spCase {
						Property: Input;
						Comment: "INPUT ARGUMENT: Name of the case";
					}
				}
				ElementParameter epDBProcedure {
					Range: AllIdentifiers;
					Comment: "Run time database procedure";
				}
				StringParameter spSQLQuery {
					Comment: "SQL query for delete case";
				}
			}
		}
		Section Get_cases {
			Procedure procGetCasesFromDatabase {
				Arguments: (epDatabaseType,spConnection,iCaseIndex);
				Body: {
					/*
					This procedure creates a run time library with the code required to obtain all cases from the database.
					Fills the set associated with the 'iCaseIndex' with all the cases that are available in the database.
					*/
					
					!Validate the input
					if( epDatabaseType = '' or spConnection = "")
					then
						procRaiseError( "Syntax", "Invalid arguments"  );
						return 0;
					endif;
					
					!Validate table definitions
					if( procValidateInput(p01ForDatabase :  1) = 0 ) then return 0; endif;
					
					!Test the connection
					if( procTestDatabaseConnection( spConnection ) = 0 ) then return 0; endif;
					
					!Create the run time library
					procCreateRuntimeLibrary( "CQM_GET_CASES_FROM_DATABASE", "cqm_gcfdb", epLibrary);
					if( epLibrary = '' ) then return 0; endif;
					
					!Create an error parameter
					procCreateErrorParameter( epLibrary );
					
					!Create the overall read procedure
					epGetCasesProcedure := me::Create( "procGetCasesFromDatabase", 'procedure', epLibrary);
					
					/*--- Create the body for the read procedure ---*/
					spGetCasesProcedureBody := "!Get cases from the database\n";
					procCreateStartOfDBProcedure(spGetCasesProcedureBody);
					
					!Create the dbproc for the case select
					procCreateDBReadCasesProcedure(epLibrary,epDatabaseType,spConnection,iCaseIndex);
					
					!Call the dbproc for the case select
					spGetCasesProcedureBody += "\tread from table dbprocReadCases();\n";
					
					procCreateEndOfDBProcedure(spGetCasesProcedureBody);
					me::SetAttribute( epGetCasesProcedure, 'body', spGetCasesProcedureBody);
					
					!Before using the new procedures we need to compile
					me::Compile( epLibrary );
					
					!Run the created procedure
					apply( epGetCasesProcedure );
					
					!Succes
					me::Delete( epLibrary );
					return 1;
				}
				Comment: {
					"Fills the set associated with the \'iCaseIndex\' with all the cases that are available in the database.
					Returns 1 on succes, 0 if a check fails"
				}
				DeclarationSection Input_Arguments {
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					ElementParameter iCaseIndex {
						Range: AllIndices;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to the set that needs to be filled with all the cases available";
					}
				}
				ElementParameter epLibrary {
					Range: AllIdentifiers;
					Comment: "Run time created library";
				}
				ElementParameter epGetCasesProcedure {
					Range: AllIdentifiers;
					Default: 'cdl::procDefault';
					Comment: "Run time create procedure";
				}
				StringParameter spGetCasesProcedureBody {
					Comment: "Body of the run time created procedure";
				}
			}
			Procedure procCreateDBReadCasesProcedure {
				Arguments: (epLibrary,epDatabaseType,spConnection,iCaseIndex);
				Body: {
					!Create new database procedure
					epDBProcedure := me::Create("dbprocReadCases",	'database procedure', epLibrary);
					
					!Connection properties
					me::SetAttribute( epDBProcedure, 'data source', formatstring( "\"%s\"", spConnection ) );
					me::SetAttribute( epDBProcedure, 'owner', formatstring( "\"%s\"", spCaseTableSchema ) );
					me::SetAttribute( epDBProcedure, 'property', "UseResultSet" );
					
					!Sql query
					spSQLQuery := "\"SELECT ";
					!Distinction between databse types
					spSQLQuery +=
						if( epDatabaseType = epORACLE )
						then
							spCaseName
						elseif( epDatabaseType = epMSSQL )
						then
							"[" + spCaseName + "]"
						endif;
					spSQLQuery +=
						if( epDatabaseType = epORACLE )
						then
							formatstring( " FROM %s.%s;\"",
								spCaseTableSchema,
								spCaseTableName )
						elseif( epDatabaseType = epMSSQL )
						then
							formatstring( " FROM [%s].[%s];\"",
								spCaseTableSchema,
								spCaseTableName )
						endif;
					!Mapping
					spMapping := formatstring( "\"%s\"\t--> %e", spCaseName, iCaseIndex );
					
					me::SetAttribute( epDBProcedure, 'sql query', spSQLQuery );
					me::SetAttribute( epDBProcedure, 'mapping', spMapping );
					
					!Compile the new procedure
					me::Compile( epDBProcedure );
				}
				Comment: "Creates a single read from database procedure that selectes all cases";
				DeclarationSection Input_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					ElementParameter iCaseIndex {
						Range: AllIndices;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to the set that needs to be filled with all the cases available";
					}
				}
				ElementParameter epDBProcedure {
					Range: AllIdentifiers;
					Comment: "Database procedure in the runtime library";
				}
				StringParameter spSQLQuery {
					Comment: "Text for the sql query";
				}
				StringParameter spMapping {
					Comment: "Text for the mapping of columns to identifiers";
				}
			}
		}
		Section Shared {
			Procedure procTestDatabaseConnection {
				Arguments: (spConnection);
				Body: {
					!Test connection to the data source
					if( TestDataSource( spConnection, Interactive: 0 ) = 0 )
					then
						procRaiseError( "Connection", formatstring( "Unable to connect to: %s", spConnection ) );
						return 0;
					endif;
					
					!Success
					return 1;
				}
				Comment: {
					"Checks if database connection can be made.
					Returns 1 on succes, 0 on failure"
				}
				DeclarationSection Input_Arguments {
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
				}
			}
			Procedure procCreateCaseSet {
				Arguments: epLibrary;
				Body: {
					/*Creates a set with name sCases*/
					
					epDeclaration := me::Create( "Case_Set",'declaration',epLibrary);
					epIdentifier := me::Create( "sCases",'set', epDeclaration);
					me::SetAttribute( epIdentifier, 'index', "iCase");
					
					me::Compile( epIdentifier );
				}
				DeclarationSection Input_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
				}
				ElementParameter epIdentifier {
					Range: AllIdentifiers;
				}
			}
			Procedure procCreateStartOfDBProcedure {
				Arguments: spBody;
				Body: {
					!Create the body text for the start of the procedure
					spBody +=
					"\nBLOCK\n" +
					"\t!Start transaction\n" +
					"\tStartTransaction();\n";
				}
				Comment: "Appends to spBody the default start of a database procedure";
				DeclarationSection Input_arguments {
					StringParameter spBody {
						Property: InOut;
						Comment: "INPUT ARGUMENT: String that is appended on";
					}
				}
			}
			Procedure procCreateEndOfDBProcedure {
				Arguments: spBody;
				Body: {
					!create the body text for the start of the procedure
					spBody +=
					"\n\t!Communication is done, so commit the transaction\n"+
					"\tCommitTransaction();\n\n"+
					"ONERROR epError\n"+
					"DO\n"+
					"\t!An error has occured, so roll back the transaction\n"+
					"\tRollbackTransaction();\n\n"+
					"ENDBLOCK;";
				}
				Comment: "Appends to spBody the default end of a database procedure";
				DeclarationSection Input_arguments {
					StringParameter spBody {
						Property: InOut;
						Comment: "INPUT ARGUMENT: String that is appended on";
					}
				}
			}
			Procedure procCreateDatabaseTable {
				Arguments: (epLibrary,epDatabaseType,epTable,spConnection,spCase);
				Body: {
					!Create declaration
					epDeclaration := me::Create( formatstring( "Declaration_%e", epTable ), 'declaration' ,epLibrary );
					!Create database table
					epDBTable := me::Create( formatstring("dbt%e", epTable), 'database table', epDeclaration);
					
					!Set the connection properties
					me::SetAttribute( epDBTable, 'data source', formatstring( "\"%s\"", spConnection ) );
					me::SetAttribute( epDBTable, 'index domain', "iCase" );
					me::SetAttribute( epDBTable, 'table name', stringToUpper( formatstring( "\"%e\"", epTable ) ) );
					me::SetAttribute( epDBTable, 'owner', stringToUpper( formatstring( "\"%s\"", spTableSchema(epTable) ) ) );
					
					!Sql query + Mapping
					spMapping := "";
					
					!Add to mapping => The case index
					if (spMapping <> "" ) then spMapping += ",\n"; endif;
					spMapping += "\"" + spCaseName + "\" \t--> iCase";
					
					!Process all indices from the table to add to the select and mapping
					for( iIndex | p01IndexInTable(epTable, iIndex) )
					do
						!Add to mapping
						if (spMapping <> "" ) then spMapping += ",\n"; endif;
						spMapping += formatstring( "\"%s\" \t--> %e",
								spIndexColumnName(epTable,iIndex),
								iIndex );
					endfor;
					
					!Create a list of identifiers from the table
					spIdentifiersInTable := "";
					for( iIdentifier | epIdentifierTable(iIdentifier) = epTable )
					do
						!Add to mapping
						if (spMapping <> "" ) then spMapping += ",\n"; endif;
						spMapping += formatstring( "\"%s\" \t--> %e%s",
								spIdentifierColumnName(iIdentifier),
								iIdentifier,
								if( spIdentifierIndexList(iIdentifier) <> "")
								then
									"(" + spIdentifierIndexList(iIdentifier) + ")"
								else
									""
								endif
								);
					endfor;
					
					!Mapping
					me::SetAttribute( epDBTable, 'mapping', spMapping );
					
					!Compile
					me::Compile( epDBTable );
				}
				DeclarationSection Input_Arguments {
					ElementParameter epLibrary {
						Range: AllIdentifiers;
						Property: Input;
						Comment: "INPUT ARGUMENT: Reference to a run time library";
					}
					ElementParameter epDatabaseType {
						Range: sDatabaseTypes;
						Property: Input;
						Comment: "INPUT ARGUMENT: Type of database";
					}
					StringParameter spConnection {
						Property: Input;
						Comment: "INPUT ARGUMENT: connection string to the database";
					}
					ElementParameter epTable {
						Range: sTables;
						Property: Input;
					}
					StringParameter spCase {
						Property: Input;
						Comment: "INPUT ARGUMENT: Name of the case";
					}
				}
				ElementParameter epDeclaration {
					Range: AllIdentifiers;
					Comment: {
						"!Creates the first part of the body of the Read Procedure in the runtime library"
					}
				}
				ElementParameter epDBTable {
					Range: AllIdentifiers;
					Comment: {
						"!Creates the first part of the body of the Read Procedure in the runtime library"
					}
				}
				StringParameter spIdentifiersInTable;
				StringParameter spMapping;
			}
		}
	}
	Section Documentation {
		Procedure procPrintDocumentation {
			Body: {
				if( dialogAsk( "Is the default printer a pdf printer?", "Yes - Continue", "No - Cancel") <> 1 ) then return; endif;
				
				!Start the report
				if( PrintStartReport("Interface documentation") = 0 ) then return; endif;
				
				!Print the front page
				PrintPage("Front page");
				!Print a page for each table
				for( iTable )
				do
					epTable := iTable;
					PrintPage("Table page");
				endfor;
				
				!Finalize the report
				PrintEndReport;
			}
			StringParameter spFile;
		}
		Procedure procAddLineEndsToDescription {
			Arguments: (spText,pLength);
			Body: {
				!Adds line end "\n" at every x (length) characters
				!To do make more advance by looking at spaces and existing "\n"
				
				!Check if text is too long
				if( pLength >= stringLength(spText) )
				then
					return;
				endif;
				
				!Take first part from the text
				spTextNew	:= substring( spText, 1, pLength );
				spText 		:= substring( spText, pLength + 1, stringLength(spText) );
				
				!iteratively take length from the text
				while( 1 )
				do
					if( pLength > stringLength(spText ) )
					then
						spText := spTextNew + "\n" + spText;
						return;
					endif;
				
					spTextNew	:= spTextNew + "\n" + substring( spText, 1, pLength );
					spText 		:= substring( spText, pLength + 1, stringLength(spText) );
				
				endwhile;
			}
			StringParameter spText {
				Property: InOut;
			}
			Parameter pLength {
				Range: integer;
				Property: Input;
			}
			StringParameter spTextNew;
		}
	}
}
