## ams_version=1.0

LibraryModule LinearOptimizationModel {
	Prefix: lom;
	Interface: {
		data { v01DirectionPlus, v01DirectionMinus, cFlowDirection, cFlowDirectionPlus, cFlowDirectionMinus, 
		       sRecoveredProducts, sPieceWiseLinearRecovery, epPWR1, epPWR2, p01PWRecoveryActive, 
		       p01PWR, sBreakPoints, epBreakPoint1, epBreakPoint2, epBreakPoint3, pRectificationPowerBeakPoint, 
		       pRecoveryBreakPoint, v01Recovery, vTotalAirPWL, cRecovery1, cRecovery2, cRecovery3, 
		       cRecovery4, cMaterialBalanceO2, cMaterialBalanceAr, pRectificationPowerLinear, 
		       pO2RecoveryLinear, pArRecoveryLinear, cPowerBalance_GOK_AOK, cPowerBalance_GOK_AOK_2, 
		       cWasteGOxToWaste, cLpGanVentClosedDef1, cLpGanVentClosedDef2, v01LpGanVentClosed, 
		       cCalcKwCompressorLinear, cCalcKwCompressorLinear2, cCalcLinearPressureDrop, 
		       v01ControlPressureOn, cSetValveSetPointLinear1, cSetValveSetPointLinear2, 
		       cSetValveSetPointLinear3, cSetValveSetPointLinear4, cSetValveSetPointLinear5, 
		       cSetValveSetPointLinear6, cValveFlowDeltaPLinear1, cValveFlowDeltaPLinear2, 
		       cCalcKwLiquefierOrCycleFlowLinear, pObjectiveCost_lom, pObjective_lom, sMPConstraints_Linear, 
		       sMPVariables_Linear, sMPConstraintsExcluded_lom, sMPVariablesExcluded_lom, 
		       mpLinearModel, epProgramStatus_lom, spProgramStatus_lom, pTimeUsed_lom, pGap_lom, 
		       procSolveLinearModel, procConfigureMathProgram_lom, procFixBinariesFromData_lom }
	}
	Section Optimization_Model {
		Section Network_model {
			DeclarationSection Flow_declaration {
				Variable v01DirectionPlus {
					IndexDomain: (gdm::iArc,gdm::iTime);
					Range: binary;
					Comment: "equal to 1 if the flow is going from Origin Node to destination Node";
				}
				Variable v01DirectionMinus {
					IndexDomain: (gdm::iArc,gdm::iTime);
					Range: binary;
					Comment: "equal to 1 if the flow is going from Destination Node to origin Node";
				}
				Constraint cFlowDirection {
					IndexDomain: (gdm::iArc, gdm::iTime);
					Definition: {
						
						v01DirectionPlus(gdm::iArc, gdm::iTime) + v01DirectionMinus(gdm::iArc, gdm::iTime) = 1
					}
					Comment: {
						"
						Only one direccion (binary variable) active"
					}
				}
				Constraint cFlowDirectionPlus {
					IndexDomain: (gdm::iArc, gdm::iTime);
					Definition: {
						
						
						gom::vFlowPlus(gdm::iArc, gdm::iTime) <= gdm::pArcMaxFlow(gdm::iArc) * v01DirectionPlus(gdm::iArc, gdm::iTime)
					}
				}
				Constraint cFlowDirectionMinus {
					IndexDomain: (gdm::iArc, gdm::iTime);
					Definition: {
						
						
						gom::vFlowMinus(gdm::iArc, gdm::iTime) <= -gdm::pArcMinFlow(gdm::iArc) * v01DirectionMinus(gdm::iArc, gdm::iTime)
					}
				}
			}
		}
		Section Coldbox {
			DeclarationSection Material_balance_and_RP_Declaration_Linear {
				Set sRecoveredProducts {
					SubsetOf: gdm::sProducts;
					Index: iRecProd;
					Definition: {
						{gdm::epProductO2, gdm::epProductAr}
					}
				}
				Set sPieceWiseLinearRecovery {
					Index: iPWR;
					Definition: data{'PWR1','PWR2'};
				}
				ElementParameter epPWR1 {
					Range: sPieceWiseLinearRecovery;
					Definition: stringToElement(sPieceWiseLinearRecovery,"PWR1");
				}
				ElementParameter epPWR2 {
					Range: sPieceWiseLinearRecovery;
					Definition: stringToElement(sPieceWiseLinearRecovery,"PWR2");
				}
				Parameter p01PWRecoveryActive {
					IndexDomain: {
						(iRecProd,iPWR,gdm::iColdbox)| not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Range: binary;
					Definition: {
						
						if iRecProd = gdm::epProductO2 then 
							if (iPWR = epPWR1) then
							       (gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear1) or 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear2))
						        else
							       (gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear3) or 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear4))
						        endif
						else
							if (iPWR = epPWR1) then
							       (gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear1) or 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear2))
						    	else
							       (gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear3) or 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear4))
						        endif
						endif
					}
				}
				Parameter p01PWR {
					IndexDomain: {
						(iRecProd,gdm::iColdbox)| not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Range: binary;
					Definition: sum( lom::iPWR, p01PWRecoveryActive(lom::iRecProd, lom::iPWR, gdm::iColdbox)) = 2;
				}
				Set sBreakPoints {
					Index: iBreakPoint;
					Definition: ElementRange(1,3,1);
				}
				ElementParameter epBreakPoint1 {
					Range: sBreakPoints;
					Definition: '1';
				}
				ElementParameter epBreakPoint2 {
					Range: sBreakPoints;
					Definition: '2';
				}
				ElementParameter epBreakPoint3 {
					Range: sBreakPoints;
					Definition: '3';
				}
				Parameter pRectificationPowerBeakPoint {
					IndexDomain: {
						(lom::iRecProd,lom::iBreakPoint, gdm::iColdbox) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						if (lom::iBreakPoint = epBreakPoint1) or (lom::iBreakPoint = epBreakPoint2 and not p01PWR(lom::iRecProd, gdm::iColdbox)) then
							gdm::pColdboxMinRectifPower(gdm::iColdbox)
						elseif lom::iBreakPoint = epBreakPoint3 then
							gdm::pColdboxMaxRectifPower(gdm::iColdbox)
						else
							if lom::iRecProd = gdm::epProductO2 then
								(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear4) - 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear2))
								/
								(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear1) - 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear3))	
							elseif lom::iRecProd = gdm::epProductAr then	
								(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear4) - 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear2))
								/
								(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear1) - 
								gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear3))	
							else
								0 
							endif
						endif
					}
				}
				Parameter pRecoveryBreakPoint {
					IndexDomain: {
						(lom::iRecProd,lom::iBreakPoint, gdm::iColdbox)| not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						if lom::iRecProd = gdm::epProductO2 then
							if lom::iBreakPoint = epBreakPoint1 then
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear1)*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear2)
							elseif p01PWR(lom::iRecProd, gdm::iColdbox) then
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear3)*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear4)
							else
							(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear1)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear3))*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear2)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryO2ParameterLinear4))
							endif	
						elseif lom::iRecProd = gdm::epProductAr then	
							if lom::iBreakPoint = epBreakPoint1 then
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear1)*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear2)
							elseif p01PWR(lom::iRecProd, gdm::iColdbox) then
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear3)*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear4)
							else
							(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear1)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear3))*
							pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox)+
							(gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear2)+
							gdm::pBoxParameterValue(gdm::iColdbox, gdm::epColdboxRecoveryArParameterLinear4))
							endif
						else
							0 
						endif
					}
				}
				Variable v01Recovery {
					IndexDomain: {
						(iRecProd,gdm::iColdbox,gdm::iTime)| not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
						and p01PWR(lom::iRecProd, gdm::iColdbox)
					}
					Range: binary;
				}
				Variable vTotalAirPWL {
					IndexDomain: {
						(iRecProd,iBreakPoint,gdm::iColdbox,gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Range: nonnegative;
				}
				Constraint cRecovery1 {
					IndexDomain: {
						(lom::iRecProd,gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						
						vTotalAirPWL(lom::iRecProd, epBreakPoint1, gdm::iColdbox, gdm::iTime) 
						<=
						v01Recovery(lom::iRecProd, gdm::iColdbox, gdm::iTime)*
						(gdm::pBoxMaxFlow(gdm::iColdbox, gdm::epColdboxNodeConnectionTypeAirHp, gdm::iTime)
						+gdm::pBoxMaxFlow(gdm::iColdbox, gdm::epColdboxNodeConnectionTypeAirMp, gdm::iTime))
					}
				}
				Constraint cRecovery2 {
					IndexDomain: {
						(lom::iRecProd,gdm::iColdbox, gdm::iTime)| not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
						and p01PWR(lom::iRecProd, gdm::iColdbox)
					}
					Definition: {
						
						
						vTotalAirPWL(lom::iRecProd, epBreakPoint3, gdm::iColdbox, gdm::iTime) 
						<=
						(1 - v01Recovery(lom::iRecProd, gdm::iColdbox, gdm::iTime))*
						(gdm::pBoxMaxFlow(gdm::iColdbox, gdm::epColdboxNodeConnectionTypeAirHp, gdm::iTime)
						+gdm::pBoxMaxFlow(gdm::iColdbox, gdm::epColdboxNodeConnectionTypeAirMp, gdm::iTime))
					}
				}
				Constraint cRecovery3 {
					IndexDomain: {
						(lom::iRecProd,gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						sum(lom::iBreakPoint, vTotalAirPWL(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox, gdm::iTime))
						=
						gom::vAirHp(gdm::iColdbox, gdm::iTime) + gom::vAirMp(gdm::iColdbox, gdm::iTime)
					}
				}
				Constraint cRecovery4 {
					IndexDomain: {
						(lom::iRecProd, gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						( gom::vAirHp(gdm::iColdbox, gdm::iTime)
						+ gom::vAirMp(gdm::iColdbox, gdm::iTime))
						-	
						( gom::vHpGaN(gdm::iColdbox, gdm::iTime)
						+ gom::vMpGaN(gdm::iColdbox, gdm::iTime)
						+ gom::vLiN(gdm::iColdbox, gdm::iTime) - gom::vLiNAssist(gdm::iColdbox, gdm::iTime)
						+ gom::vAirTurbineLp(gdm::iColdbox, gdm::iTime)
						)
						= 
						sum(lom::iBreakPoint, 
						pRectificationPowerBeakPoint(lom::iRecProd, lom::iBreakPoint, gdm::iColdbox) *
						vTotalAirPWL(lom::iRecProd, lom::iBreakPoint , gdm::iColdbox, gdm::iTime))
					}
				}
				Constraint cMaterialBalanceO2 {
					IndexDomain: {
						(gdm::iColdbox,gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						gdm::pO2Content * 
						sum(lom::iBreakPoint, pRecoveryBreakPoint(gdm::epProductO2, lom::iBreakPoint, gdm::iColdbox) * 
						vTotalAirPWL(gdm::epProductO2, lom::iBreakPoint, gdm::iColdbox, gdm::iTime))
						=
						gom::vHpGOx(gdm::iColdbox, gdm::iTime)
						+ gom::vMpGOx(gdm::iColdbox, gdm::iTime)
						+ gom::vLpGOx(gdm::iColdbox, gdm::iTime)
						+ gom::vLOx(gdm::iColdbox, gdm::iTime)
						+ gom::vGOxtoWaste(gdm::iColdbox, gdm::iTime)
						- gom::vLOxAssist(gdm::iColdbox, gdm::iTime)
					}
				}
				Constraint cMaterialBalanceAr {
					IndexDomain: {
						(gdm::iColdbox,gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						
						gdm::pArContent *  
						sum(lom::iBreakPoint, pRecoveryBreakPoint(gdm::epProductAr, lom::iBreakPoint, gdm::iColdbox) * 
						vTotalAirPWL(gdm::epProductAr, lom::iBreakPoint, gdm::iColdbox, gdm::iTime))
						=
						gom::vLAr(gdm::iColdbox, gdm::iTime)
					}
				}
				Parameter pRectificationPowerLinear {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						1 * gom::v01Box(gdm::iColdbox, gdm::iTime) -
						(gom::vHpGan(gdm::iColdbox, gdm::iTime) + gom::vMpGan(gdm::iColdbox, gdm::iTime) + gom::vLin(gdm::iColdbox, gdm::iTime) + gom::vAirTurbineLp(gdm::iColdbox, gdm::iTime)- gom::vLinAssist(gdm::iColdbox, gdm::iTime))
						/$(gom::vAirMp(gdm::iColdbox, gdm::iTime)+ gom::vAirHp(gdm::iColdbox, gdm::iTime)+gdm::pEps2)
					}
				}
				Parameter pO2RecoveryLinear {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						( gom::vHpGox(gdm::iColdbox, gdm::iTime)
						+ gom::vMpGox(gdm::iColdbox, gdm::iTime)
						+ gom::vLpGox(gdm::iColdbox, gdm::iTime)
						+ gom::vLox(gdm::iColdbox, gdm::iTime)
						+ gom::vGoxToWaste(gdm::iColdbox, gdm::iTime)
						- gom::vLoxAssist(gdm::iColdbox, gdm::iTime)
						)
						/$ (gdm::pO2Content * (gom::vAirMp(gdm::iColdbox, gdm::iTime) + gom::vAirHp(gdm::iColdbox, gdm::iTime) + gdm::pEps2))
					}
				}
				Parameter pArRecoveryLinear {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRecovery)
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationRectifPower)
						and gdm::p01BoxLinearEquationModel(gdm::iColdbox)
					}
					Definition: {
						gom::vLar(gdm::iColdbox, gdm::iTime)
						/$
						(gdm::pARContent * (gom::vAirMp(gdm::iColdbox, gdm::iTime) + gom::vAirHp(gdm::iColdbox, gdm::iTime) + gdm::pEps2))
					}
				}
			}
			DeclarationSection Power_balance_Declaration_Linear {
				Constraint cPowerBalance_GOK_AOK {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok
						and not gdm::p01ColdboxTypeSpecificEquation( gdm::epColdboxProcess(gdm::iColdbox) $ (gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok), gdm::epColdboxSpecificEquationPowerBalance )
						and gdm::p01BoxLinearEquationModel( gdm::iColdbox )
					}
					Definition: {
						
						gom::vAirHp(gdm::iColdbox, gdm::iTime)
						>=
						  gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear1) * gom::vHpGox(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear2) * gom::vMpGox(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear3) * gom::vHpGan(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear4) * gom::vInternalLiquid(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear5) * gom::v01Box(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear6) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirHp), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear7) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear8) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGOx), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear9) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeMpGOx), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear10) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGAn), gdm::iTime)
						-
						(   max(0,gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear6))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirHp))
						  + max(0,gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear7))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp))
						  + max(0,gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear8))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpgox))
						  + max(0,gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear9))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeMpGox))
						  + max(0,gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear10))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHPgan))
						 )
						* (1 - gom::v01Box(gdm::iColdbox, gdm::iTime))
						
						
						
						
						
						
						/*
						
						gom::vAirHp(gdm::iColdbox, gdm::iTime) =
						 gdm::pColdboxParameterValue(gdm::iColdbox,gdm::epCbParPumpingProcessParLinear1)*gom::vHPGOX(gdm::iColdbox, gdm::iTime)+
						 gdm::pColdboxParameterValue(gdm::iColdbox,gdm::epCbParPumpingProcessParLinear2)*gom::vMPGOX(gdm::iColdbox, gdm::iTime)+
						 gdm::pColdboxParameterValue(gdm::iColdbox,gdm::epCbParPumpingProcessParLinear3)*gom::vHPGAN(gdm::iColdbox, gdm::iTime)+
						 gdm::pColdboxParameterValue(gdm::iColdbox,gdm::epCbParPumpingProcessParLinear4)*gom::vInternalLiquid(gdm::iColdbox, gdm::iTime)
						
						*/
					}
				}
				Constraint cPowerBalance_GOK_AOK_2 {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok
						and not gdm::p01ColdboxTypeSpecificEquation( gdm::epColdboxProcess(gdm::iColdbox) $ (gdm::epColdboxProcess(gdm::iColdbox) = gdm::epColdboxProcessAokGok), gdm::epColdboxSpecificEquationPowerBalance )
						and gdm::p01BoxLinearEquationModel( gdm::iColdbox )
					}
					Definition: {
						
						gom::vAirHp(gdm::iColdbox, gdm::iTime)
						<=
						  gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear1) * gom::vHpGox(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear2) * gom::vMpGox(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear3) * gom::vHpGan(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear4) * gom::vInternalLiquid(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear5) * gom::v01Box(gdm::iColdbox, gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear6) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirHp), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear7) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear8) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGOx), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear9) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeMpGOx), gdm::iTime)
						+ gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear10) * gom::vPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpGAn), gdm::iTime)
						+
						(   abs(gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear6))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirHp))
						  + abs(gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear7))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeAirMp))
						  + abs(gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear8))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHpgox))
						  + abs(gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear9))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeMpGox))
						  + abs(gdm::pBoxParameterValue(gdm::iColdbox,gdm::epColdboxPumpingProcessParameterLinear10))*gdm::pNodeMaxPressure(gdm::epBoxNode(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeHPgan))
						 )
						* (1 - gom::v01Box(gdm::iColdbox, gdm::iTime))
					}
				}
			}
			DeclarationSection Regeneration_Declaration {
				Constraint cWasteGOxToWaste {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | ( gdm::p01BoxLinearEquationModel(gdm::iColdbox) and gdm::pBoxMaxFlow(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx, gdm::iTime) )
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
					}
					Definition: {
						
						
						gom::vGoxToWaste(gdm::iColdbox, gdm::iTime) <= gdm::pColdboxMaxInternalFlow(gdm::iColdbox, gdm::epGoxToWaste, gdm::iTime) * v01LpGanVentClosed(gdm::iColdbox, gdm::iTime)
					}
				}
				Constraint cLpGanVentClosedDef1 {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | ( gdm::p01BoxLinearEquationModel(gdm::iColdbox) and gdm::pBoxMaxFlow(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx, gdm::iTime) )
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
					}
					Definition: {
						
						
						
						gom::vLpGanVent(gdm::iColdbox, gdm::iTime) >= (1 - v01LpGanVentClosed(gdm::iColdbox, gdm::iTime))
					}
				}
				Constraint cLpGanVentClosedDef2 {
					IndexDomain: {
						(gdm::iColdbox, gdm::iTime) | ( gdm::p01BoxLinearEquationModel(gdm::iColdbox) and gdm::pBoxMaxFlow(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx, gdm::iTime) )
						and not gdm::p01ColdboxTypeSpecificEquation(gdm::epColdboxProcess(gdm::iColdbox),gdm::epColdboxSpecificEquationMaterialBalance)
					}
					Definition: {
						
						gom::vLpGanVent(gdm::iColdbox, gdm::iTime) <= (1 - v01LpGanVentClosed(gdm::iColdbox, gdm::iTime)) * gdm::pColdboxMaxLpGanVent(gdm::iColdbox)
					}
				}
				Variable v01LpGanVentClosed {
					IndexDomain: (gdm::iColdbox,gdm::iTime) | gdm::pBoxMaxFlow(gdm::iColdbox,gdm::epColdboxNodeConnectionTypeLpGOx,gdm::iTime) and gdm::p01BoxLinearEquationModel(gdm::iColdbox);
					Range: binary;
				}
			}
		}
		DeclarationSection element_compressor {
			Constraint cCalcKwCompressorLinear {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | ( not gdm::p01CompressorPowerSpecificEquation(gdm::iCompressorArc) and gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) );
				Definition: {
					
					gom::vCompressorPower(gdm::iCompressorArc, gdm::iTime)
					>=
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear1) * gom::vFlow(gdm::iCompressorArc, gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear2) * gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::iCompressorArc), gdm::iTime) * gom::v01Compressor(gdm::iCompressorArc, gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear3) * gom::vPressure(gdm::epNodeFrom(gdm::iCompressorArc), gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear4) * gom::vPressure(gdm::epNodeTo(gdm::iCompressorArc), gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear5) * gom::v01Compressor(gdm::iCompressorArc, gdm::iTime)
					-
					(
						max(0,gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear3))
						*
						gdm::pNodeMaxPressure(gdm::epNodeFrom(gdm::iCompressorArc))
						+
						max(0,gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear4))
						*
						gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::iCompressorArc))
					)
					*
					(1 - gom::v01Compressor(gdm::iCompressorArc, gdm::iTime))
				}
			}
			Constraint cCalcKwCompressorLinear2 {
				IndexDomain: (gdm::iCompressorArc, gdm::iTime) | ( not gdm::p01CompressorPowerSpecificEquation(gdm::iCompressorArc) and gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) );
				Definition: {
					
					gom::vCompressorPower(gdm::iCompressorArc, gdm::iTime)
					<=
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear1) * gom::vFlow(gdm::iCompressorArc, gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear2) * gdm::pCoolingTowerTemperature(gdm::epCompressorCoolingTower(gdm::iCompressorArc), gdm::iTime) * gom::v01Compressor(gdm::iCompressorArc, gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear3) * gom::vPressure(gdm::epNodeFrom(gdm::iCompressorArc), gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear4) * gom::vPressure(gdm::epNodeTo(gdm::iCompressorArc), gdm::iTime) +
					gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear5) * gom::v01Compressor(gdm::iCompressorArc, gdm::iTime)
					+
					(
						abs(gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear3))
						*
						gdm::pNodeMaxPressure(gdm::epNodeFrom(gdm::iCompressorArc))
						+
						abs(gdm::pCompressorParameterValue(gdm::iCompressorArc, gdm::epCompressorParameterLinear4))
						*
						gdm::pNodeMaxPressure(gdm::epNodeTo(gdm::iCompressorArc))
					)
					*
					(1 - gom::v01Compressor(gdm::iCompressorArc, gdm::iTime))
				}
			}
		}
		DeclarationSection element_pipe {
			Constraint cCalcLinearPressureDrop {
				IndexDomain: {
					(gdm::iPipeArc, gdm::iTime) | 
					gdm::p01PipeLinearEquationModel( gdm::iPipeArc ) 
					and not gdm::p01PipePressureDropSpecificEquation( gdm::iPipeArc )
				}
				Definition: {
					
					if gdm::epPipeCalculationMode(gdm::iPipeArc) = gdm::epPipeCalculationModeNoPressureDrop then
					
						! No pressure drop
						gom::vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime) - gom::vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime)
						= 
						gom::vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - gom::vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					
					else 
						gom::vPressure(gdm::epNodeFrom(gdm::iPipeArc), gdm::iTime) - gom::vPressure(gdm::epNodeTo(gdm::iPipeArc), gdm::iTime) =
						(gdm::pPipeLinearPressureDropParam1(gdm::iPipeArc) + gom::pEstimatedPipeLinearPressureDropParam1(gdm::iPipeArc)) * gom::vFlow(gdm::iPipeArc, gdm::iTime) 
						+ 
						gom::vPressureDropSlackPos(gdm::iPipeArc, gdm::iTime) - gom::vPressureDropSlackNeg(gdm::iPipeArc, gdm::iTime)
					endif
				}
			}
		}
		DeclarationSection element_valve {
			Variable v01ControlPressureOn {
				IndexDomain: (gdm::iValveArc,gdm::iTime);
				Range: binary;
				Comment: "if pressure control valve if active";
			}
			Constraint cSetValveSetPointLinear1 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModePressureControl and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)  <=  gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cSetValveSetPointLinear2 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModePressureControl and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)  <= gom::vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime)
				}
			}
			Constraint cSetValveSetPointLinear3 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModePressureControl  and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime) >=  gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime)*v01ControlPressureOn(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cSetValveSetPointLinear4 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModePressureControl and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime) >=  gom::vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime) - gdm::pValveDeltaPressureMax(gdm::iValveArc)*v01ControlPressureOn(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cSetValveSetPointLinear5 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModeFlowControl and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vFlow(gdm::iValveArc, gdm::iTime)
					=
					gdm::pValveSetpoint(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cSetValveSetPointLinear6 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | ( gdm::epValveControlMode(gdm::iValveArc, gdm::iTime) = gdm::epValveControlModeOpenValve and gdm::p01ValveLinearEquationModel( gdm::iValveArc ) );
				Definition: {
					
					gom::vPressure(gdm::epNodeTo(gdm::iValveArc), gdm::iTime)
					=
					gom::vPressure(gdm::epNodeFrom(gdm::iValveArc), gdm::iTime)
				}
			}
			Constraint cValveFlowDeltaPLinear1 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | gdm::p01ValveLinearEquationModel( gdm::iValveArc );
				Definition: {
					
					gom::vDeltaPValve(gdm::iValveArc, gdm::iTime) <= gdm::pValveDeltaPressureMax(gdm::iValveArc) * v01DirectionPlus(gdm::iValveArc, gdm::iTime)
				}
			}
			Constraint cValveFlowDeltaPLinear2 {
				IndexDomain: (gdm::iValveArc, gdm::iTime) | gdm::p01ValveLinearEquationModel( gdm::iValveArc );
				Definition: {
					
					
					gom::vDeltaPValve(gdm::iValveArc, gdm::iTime) >= -gdm::pValveDeltaPressureMax(gdm::iValveArc) * v01DirectionMinus(gdm::iValveArc, gdm::iTime)
				}
			}
		}
		DeclarationSection element_liquefier {
			Constraint cCalcKwLiquefierOrCycleFlowLinear {
				IndexDomain: (gdm::iLiquefierArc, gdm::iTime) | not gdm::p01LiquefierPowerSpecificEquation(gdm::iLiquefierArc) and gdm::p01LiquefierLinearEquationModel( gdm::iLiquefierArc );
				Definition: {
					if gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeBasic then
					
						gom::vLiquefierPower(gdm::iLiquefierArc, gdm::iTime)
						=
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear1)*gom::vFlow(gdm::iLiquefierArc, gdm::iTime) +
						(gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear2)*gdm::pCoolingTowerTemperature(gdm::epLiquefierCoolingTower(gdm::iLiquefierArc), gdm::iTime) +
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear3))*gom::v01Liquefier(gdm::iLiquefierArc, gdm::iTime)
					
					elseif gdm::epLiquefierCalculationMode(gdm::iLiquefierArc)=gdm::epLiquefierCalculationModeAdvanced then
						gom::vFlow(gdm::epLiquefierCycle(gdm::iLiquefierArc), gdm::iTime)
						=
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear1)*gom::vFlow(gdm::iLiquefierArc, gdm::iTime) +
						gdm::pLiquefierParameterValue(gdm::iLiquefierArc, gdm::epLiquefierParameterPerfLinear4)*gom::v01Liquefier(gdm::iLiquefierArc, gdm::iTime)
					else
						0=0
					endif
				}
			}
		}
		DeclarationSection objective_function {
			Parameter pObjectiveCost_lom;
			Parameter pObjective_lom;
		}
		DeclarationSection mathematical_program {
			Set sMPConstraints_Linear {
				SubsetOf: AllConstraints;
				Definition: {
					!Defined in the procConfigureMathProgram for each entity specific
				}
			}
			Set sMPVariables_Linear {
				SubsetOf: AllVariables;
				Definition: {
					!Defined in the procConfigureMathProgram for each entity specific
				}
			}
			Set sMPConstraintsExcluded_lom {
				SubsetOf: AllConstraints;
			}
			Set sMPVariablesExcluded_lom {
				SubsetOf: AllVariables;
			}
			MathematicalProgram mpLinearModel {
				Objective: gom::vObjective;
				Direction: minimize;
				Constraints: sMPConstraints_Linear;
				Variables: sMPVariables_Linear;
				Type: Automatic;
			}
			ElementParameter epProgramStatus_lom {
				Range: AllSolutionStates;
			}
			StringParameter spProgramStatus_lom {
				Definition: epProgramStatus_lom;
			}
			Parameter pTimeUsed_lom;
			Parameter pGap_lom;
		}
	}
	Section Solve_procedures {
		Procedure procSolveLinearModel {
			Body: {
				if p01ApplicationIsOnAimmsPro then
					pro::ManagedSessionRemoveFromCaseIdentifierSet := {};
				
					!Delegate the execution of the procedure to the server
					if pro::DelegateToServer( 
					waitForCompletion: 1,
					completionCallback: 'pro::session::LoadResultsCallback',
					priorityAdjustment: 0,
					timeOut: 600000
					) 
					then
					return 1;
					endif ;
				endif;
				
				gdm::procCheckData;
				
				if gom::procCheckSevereErrors() = 1  then
					!Configure math program 
					lom::procConfigureMathProgram_lom();
				
					!Solve
					BLOCK
						epGMP := GMP::Instance::Generate( lom::mpLinearModel );
						gom::procSolve( epGMP, 0, splProgramStatus );
					ONERROR epError
					DO
						spErrorString := errh::Message(epError);
						if( errh::Severity( epError ) = 'Warning' )
						then
							!It is a warning, mark it as handled and return.
							errh::MarkAsHandled( epError );
						else
							log_message::procLogInfo("",formatstring( "Solver failed for linear model: %s", spErrorString));
							errh::MarkAsHandled( epError );	
							return 0;
						endif;
					ENDBLOCK;
				
					gdm::procLogSlackAllowed("Variant"); !log slack allowed
					log_message::procLogInfo("",formatstring( "Program status for linear model: %s", splProgramStatus));
				
					!Copy objective values to parameters
					lom::pObjectiveCost_lom:= gom::vObjectiveCost;
					lom::pObjective_lom:= gom::vObjective;
				
					! Initialized missing variables
					gom::vRectificationPower.level(gdm::iColdbox,gdm::iTime) := lom::pRectificationPowerLinear(gdm::iColdbox,gdm::iTime);
					gom::vO2Recovery.level(gdm::iColdbox,gdm::iTime)  := lom::pO2RecoveryLinear(gdm::iColdbox,gdm::iTime);
					gom::vArRecovery.level(gdm::iColdbox,gdm::iTime)  := lom::pArRecoveryLinear(gdm::iColdbox,gdm::iTime);
				
				
					epProgramStatus_lom := (GMP::Solution::GetProgramStatus( epGMP, 1 ));
					pTimeUsed_lom := (GMP::Solution::GetTimeUsed( epGMP, 1 ));
					pGap_lom :=( abs( mpLinearModel.Incumbent - mpLinearModel.bestbound ) / $abs( mpLinearModel.Incumbent ) ) * 100;
				
					!Return 1 on (local)optimality
					if( splProgramStatus = "Optimal" or splProgramStatus = "LocallyOptimal" )
					then
						return 1;
					else
						return 0;
					endif;
				
				else
					return 0;
				endif;
			}
			ElementParameter epGMP {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter splProgramStatus;
			StringParameter spErrorString;
			ElementParameter epError {
				Range: errh::PendingErrors;
			}
		}
		Section Config_procedures {
			Procedure procConfigureMathProgram_lom {
				Body: {
					/****
					This procedure is called before any solve and it configures 
					the mathematical program by setting the correct elements in 
					the sets, i.e. it defines the set of
					- Constraints
					- Variables
					... other
					****/
					
					!set definitions of p01 for linear or non-linear constraints all to 1 for linear model
					gdm::p01BoxLinearEquationModel( gdm::iBox ) := 1;
					gdm::p01CompressorLinearEquationModel( gdm::iCompressorArc ) := 1;
					gdm::p01LiquefierLinearEquationModel( gdm::iLiquefierArc ) := 1;
					gdm::p01PipeLinearEquationModel( gdm::iPipeArc ) := 1;
					gdm::p01ValveLinearEquationModel( gdm::iValveArc ) := 1;
					
					!Set definitions of constraint and variables sets
					sMPConstraints_Linear := 
						{IndexConstraints|IndexConstraints in ( GeneralOptimizationModel or LinearOptimizationModel ) }
						- {IndexNonLinearConstraints|IndexNonLinearConstraints in GeneralOptimizationModel}
						- sMPConstraintsExcluded_lom;
					
					sMPVariables_Linear :=
						{IndexVariables|IndexVariables in ( GeneralOptimizationModel or LinearOptimizationModel ) }
						- sMPVariablesExcluded_lom;
					
					!Set definitions of other sets
					gom::procNodeSetsDefinition();
					
					! Call procedure to initialize pAccuBufferInitial based on initial pressures
					gom::procInitializeAccuBuffers();
					
					! Fix unnecessary flow variables based on data
					gom::procFixFlowVariablesFromData();
					lom::procFixBinariesFromData_lom();
				}
			}
			Procedure procFixBinariesFromData_lom {
				Body: {
					
					
					 !Set vFlowPlus = 0 if, by definition, flow cannot be positive and it is not a valve
					for( (gdm::iArc, gdm::iTime) | gdm::pArcMaxFlow(gdm::iArc) <= 0 and not(gdm::iArc in gdm::sValveArcs)) do
						lom::v01DirectionPlus(gdm::iArc, gdm::iTime).nonvar := 1;
						lom::v01DirectionMinus(gdm::iArc, gdm::iTime).nonvar := 1;
						lom::v01DirectionPlus(gdm::iArc, gdm::iTime).level := 0;
						lom::v01DirectionMinus(gdm::iArc, gdm::iTime).level := 1;
					endfor;
					
					! Set vFlowMinus = 0 if, by definition, flow cannot be negavite and it is not a valve
					for( (gdm::iArc, gdm::iTime) | gdm::pArcMinFlow(gdm::iArc) >= 0 and not(gdm::iArc in gdm::sValveArcs)) do
						lom::v01DirectionPlus(gdm::iArc, gdm::iTime).nonvar := 1;
						lom::v01DirectionMinus(gdm::iArc, gdm::iTime).nonvar := 1;
						lom::v01DirectionPlus(gdm::iArc, gdm::iTime).level := 1;
						lom::v01DirectionMinus(gdm::iArc, gdm::iTime).level := 0;
					endfor;
				}
			}
		}
	}
}
